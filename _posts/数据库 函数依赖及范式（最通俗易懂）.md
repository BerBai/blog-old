---
layout:     post
title:      数据库-函数依赖及范式
subtitle:   通俗讲解
date:       2020-05-17
author:     白
header-img: img/post-bg-j.jpg
catalog: true
tags:
    - 数据库
---

# 数据库-函数依赖及范式（通俗易懂）

## 一、基础概念

　　要理解范式，首先必须对知道什么是关系数据库，如果你不知道，我可以简单的不能再简单的说一下：关系数据库就是用二维表来保存数据。表和表之间可以……（省略10W字）。
　　然后你应该理解以下概念：
　　**实体：**现实世界中客观存在并可以被区别的事物。比如“一个学生”、“一本书”、“一门课”等等。值得强调的是这里所说的“事物”不仅仅是看得见摸得着的“东西”，它也可以是虚拟的，不如说“老师与学校的关系”。
　　**属性：**教科书上解释为：“实体所具有的某一特性”，由此可见，属性一开始是个逻辑概念，比如说，“性别”是“人”的一个属性。在关系数据库中，属性又是个物理概念，属性可以看作是“表的一列”。
　　**元组：**表中的一行就是一个元组。
　　**分量：**元组的某个属性值。在一个关系数据库中，它是一个操作原子，即关系数据库在做任何操作的时候，属性是“不可分的”。否则就不是关系数据库了。
　　**码：**表中可以唯一确定一个元组的某个属性（或者属性组），如果这样的码有不止一个，那么大家都叫候选码，我们从候选码中挑一个出来做老大，它就叫主码。
　　**全码：**如果一个码包含了所有的属性，这个码就是全码。
　　**主属性：**一个属性只要在任何一个候选码中出现过，这个属性就是主属性。
　　**非主属性：**与上面相反，没有在任何候选码中出现过，这个属性就是非主属性。
　　**外码：**一个属性（或属性组），它不是码，但是它别的表的码，它就是外码。

## 二、6个范式

　　好了，上面已经介绍了我们掌握范式所需要的全部基础概念，下面我们就来讲范式。首先要明白，范式的包含关系。一个数据库设计如果符合第二范式，一定也符合第一范式。如果符合第三范式，一定也符合第二范式…

### 第一范式（1NF）

**属性不可分。**

　　在前面我们已经介绍了属性值的概念，我们说，它是“不可分的”。而第一范式要求属性也不可分。那么它和属性值不可分有什么区别呢？给一个例子：

<table>
   <tr>
      <th>name</td>
      <th colspan='2'>tel</td>
      <th>age</td>
   </tr>
   <tr>
      <td>大宝</td>
      <td colspan='2'>13612345678</td>
      <td>22</td>
   </tr>
   <tr>
      <td>小明</td>
      <td>13988776655</td>
      <td>010－1234567</td>
      <td>21</td>
   </tr>
</table>

Ps：这个表中，属性值“分”了。

<table>
	<tr>
		<th rowspan='2'>name</td>
		<th colspan='2'>tel</td>
		<th colspan='2'>age</td>
	</tr>
	<tr>
        <td>手机</td>
		<td>座机</td>
	</tr>
	<tr>
		<td>大宝</td>
		<td>13612345678</td>
		<td>021－9876543</td>
		<td>22</td>
	</tr>
	<tr>
		<td>小明</td>
		<td>13988776655</td>
		<td>010－1234567</td>
		<td>21</td>
	</tr>
</table>

Ps：这个表中，属性 “分”了。

　　这两种情况都不满足第一范式。不满足第一范式的数据库，不是关系数据库！所以，我们在任何关系数据库管理系统中，做不出这样的“表”来。（也就是说，**只要是关系数据库就是第一范式**）

### 第二范式（2NF）

**符合1NF，并且，非主属性完全依赖于码，消除部分依赖。**

　　听起来好像很神秘，其实真的没什么。
　　一个候选码中的主属性也可能是好几个。如果一个主属性，它不能单独做为一个候选码，那么它也不能确定任何一个非主属性。给一个反例：我们考虑一个小学的教务 管理系统，学生上课指定一个老师，一本教材，一个教室，一个时间，大家都上课去吧，没有问题。那么数据库怎么设计？（学生上课表）

| 学生 | 课程             | 老师 | 老师职称 | 教材          | 教室 | 上课时间 |
| ---- | ---------------- | ---- | -------- | ------------- | ---- | -------- |
| 小明 | 一年级语文（上） | 大宝 | 副教授   | 《小学语文1》 | 101  | 14：30   |

一个学生上一门课，一定在特定某个教室。所以有（学生，课程）－>教室
一个学生上一门课，一定是特定某个老师教。所以有（学生，课程）－>老师
一个学生上一门课，他老师的职称可以确定。所以有（学生，课程）－>老师职称
一个学生上一门课，一定是特定某个教材。所以有（学生，课程）－>教材
一个学生上一门课，一定在特定时间。所以有（学生，课程）－>上课时间

　　因此（学生，课程）是一个码。
　　然而，一个课程，一定指定了某个教材，一年级语文肯定用的是《小学语文1》，那么就有课程－>教材。（学生，课程）是个码，课程却决定了教材，这就叫做不完全依赖，或者说部分依赖。出现这样的情况，就不满足第二范式！
　　有什么不好吗？你可以想想：
　　1、校长要新增加一门课程叫“微积分”，教材是《大学数学》，怎么办？学生还没选课，而学生又是主属性，主属性不能空，课程怎么记录呢，教材记到哪呢? ……郁闷了吧?(插入异常)
　　2、下学期没学生学一年级语文（上）了，学一年级语文（下）去了，那么表中将不存在一年级语文（上），也就没了《小学语文1》。这时候，校长问：一年级语文（上）用的什么教材啊？……郁闷了吧?(删除异常)
　　3、校长说：一年级语文（上）换教材，换成《大学语文》。有10000个学生选了这么课，改动好大啊！改累死了……郁闷了吧？（修改异常）
　　那应该怎么解决呢？投影分解，将一个表分解成两个或若干个表

| 学生 | 课程             | 老师 | 老师职称 | 教室 | 上课时间 |
| ---- | ---------------- | ---- | -------- | ---- | -------- |
| 小明 | 一年级语文（上） | 大宝 | 副教授   | 101  | 14：30   |

学生上课表新

| 课程             | 教材          |
| ---------------- | ------------- |
| 一年级语文（上） | 《小学语文1》 |

课程的表

### 第三范式（3NF）

**符合2NF，并且，消除传递依赖**

　　上面的“学生上课表新”符合2NF，可以这样验证：两个主属性单独使用，不用确定其它四个非主属性的任何一个。但是它有传递依赖！
　　在哪呢？问题就出在“老师”和“老师职称”这里。一个老师一定能确定一个老师职称。有什么问题吗？想想：
　　1、老师升级了，变教授了，要改数据库，表中有N条，改了N次……（修改异常）
　　2、没人选这个老师的课了，老师的职称也没了记录……（删除异常）
　　3、新来一个老师，还没分配教什么课，他的职称记到哪？……（插入异常）
　　那应该怎么解决呢？和上面一样，投影分解：

| 学生 | 课程             | 老师 | 教室 | 上课时间 |
| ---- | ---------------- | ---- | ---- | -------- |
| 小明 | 一年级语文（上） | 大宝 | 101  | 14：30   |

| 老师 | 老师职称 |
| ---- | -------- |
| 大宝 | 副教授   |

### BC范式（BCNF）

**符合3NF，并且，主属性不依赖于主属性**

　　**若关系模式属于第三范式，且每个属性都不传递依赖于键码，则属于BC范式。**

​		若某公司有若干个仓库；每个仓库只能有一名管理员，一名管理员只能在一个仓库中工作；一个仓库中可以存放多种物品，一种物品也可以存放在不同的仓库中。每种物品在每个仓库中都有对应的数量。
那么关系模式 仓库（仓库名，管理员，物品名，数量） 属于哪一级范式？

​		已知函数依赖集：仓库名 → 管理员，管理员 → 仓库名，（仓库名，物品名）→ 数量
​		码：（管理员，物品名），（仓库名，物品名）
​		主属性：仓库名、管理员、物品名非主属性：数量
​		∵ 不存在非主属性对码的部分函数依赖和传递函数依赖。
​		∴ 此关系模式属于3NF。

​		好，既然此关系模式已经属于了 3NF，那么这个关系模式是否存在问题呢？我们来看以下几种操作：
​		1.先新增加一个仓库，但尚未存放任何物品，是否可以为该仓库指派管理员？——不可以，因为物品名也是主属性，根据实体完整性的要求，主属性不能为空。
某仓库被清空后，需要删除所有与这个仓库相关的物品存放记录，会带来什么问题？——仓库本身与管理员的信息也被随之删除了。
​		2.如果某仓库更换了管理员，会带来什么问题？——这个仓库有几条物品存放记录，就要修改多少次管理员信息。
​		从这里我们可以得出结论，在某些特殊情况下，即使关系模式符合 3NF 的要求，仍然存在着插入异常，修改异常与删除异常的问题，仍然不是 ”好“ 的设计。
​		造成此问题的原因：存在着主属性对于码的部分函数依赖与传递函数依赖。（在此例中就是存在**主属性**【仓库名】对于**码**【（管理员，物品名）】的**部分函数依赖**。

​		解决办法就是要在 3NF 的基础上消除主属性对于码的部分与传递函数依赖。
​		1.仓库表（仓库名，管理员）
​		2.库存表（仓库名，物品名，数量）
​		这样，之前的插入异常，修改异常与删除异常的问题就被解决了。

　　通常BC范式的条件有多种等价的表述：每个非平凡依赖的左边必须包含键码；每个决定因素必须包含键码。BC范式既检查非主属性，又检查主属性。当只检查非主属性时，就成了第三范式。满足BC范式的关系都必然满足第三范式。还可以这么说：**若一个关系达到了第三范式，并且它只有一个候选码，或者它的每个候选码都是单属性，则该关系自然达到BC范式**。

　　一般，一个数据库设计符合3NF或BCNF就可以了。在BC范式以上还有第四范式、第五范式。

### 第四范式

​		**要求把同一表内的多对多关系删除。**

### 第五范式

​		**从最终结构重新建立原始结构。**