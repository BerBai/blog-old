---
layout:     post
title:      C++ 题库
subtitle:   C++笔试题库
date:       2019-04-05
author:     白
header-img: img/post-bg-universe.jpg
catalog: true
tags:
    - 题库
---


##### 1、
```
字符串str1需要11个字节才能存放下（包括末尾的’\0’），而string只有10个字节的空间，strcpy会导致数组越界；
 

```
##### 2、分析下面代码有什么问题？ 
```
  首先，代码根本不能通过编译。因为数组名str1为 char *const类型的右值类型，根本不能赋值。 
  再者，即使想对数组的第一个元素赋值，也要使用 *str1 = 'a';  

  其次，对字符数组赋值后，使用库函数strcpy进行拷贝操作，strcpy会从源地址一直往后拷贝，直到遇到'\0'为止。所以拷贝的长度是不定的。如果一直没有遇到'\0'导致越界访问非法内存，程序就崩了。 
  完美修改方案为： 
void test2()
{
	char string[10], str1[10];
	int i;
	for(i=0; i<9; i++)
	{
		str1[i]  = 'a';
	}
	str1[9] = '\0';
	strcpy( string, str1 );
}

 
```
##### 3、指出下面代码有什么问题？ 
```
if(strlen(str1) <= 10)应改为if(strlen(str1) < 10)，因为strlen的结果未统计’\0’所占用的1个字节。
 

```
##### 4、写出完整版的strcpy函数

```
如果编写一个标准strcpy函数的总分值为10，下面给出几个不同得分的答案：     2分     void strcpy( char *strDest, char *strSrc ) 
{ 
  while( (*strDest++ = * strSrc++) != ‘\0’ ); 
}  4分      void strcpy( char *strDest, const char *strSrc )  
//将源字符串加const，表明其为输入参数，加2分 
{ 
  while( (*strDest++ = * strSrc++) != ‘\0’ ); 
}  7分      void strcpy(char *strDest, const char *strSrc)  
{ 
 //对源地址和目的地址加非0断言，加3分 
 assert( (strDest != NULL) && (strSrc != NULL) ); 
 while( (*strDest++ = * strSrc++) != ‘\0’ ); 
}  10分     //为了实现链式操作，将目的地址返回，加3分！      char * strcpy( char *strDest, const char *strSrc )  
{ 
 assert( (strDest != NULL) && (strSrc != NULL) ); 
 char *address = strDest;  
 while( (*strDest++ = * strSrc++) != ‘\0’ ); 
 return address;  }  

```
##### 5、检查下面代码有什么问题？ 
```
传入中GetMemory( char *p )函数的形参为字符串指针，在函数内部修改形参并不能真正的改变传入形参的实参值，执行完     char *str = NULL; 
GetMemory( str );     后的str仍然为NULL；     1：传入形参并不能真正改变形参的值，执行完之后为空；     2：在函数GetMemory中和Test中没有malloc对应的free，造成内存泄露   

```
##### 6、下面代码会出现什么问题？ 
```
char p[] = "hello world";  
return p;  
的p[]数组为函数内的局部自动变量，在函数返回后，内存已经被释放。这是许多程序员常犯的错误，其根源在于不理解变量的生存期。
 

```
##### 7、下面代码会出现什么问题？ 
```
1. 传入GetMemory的参数为字符串指针的指针，但是在GetMemory中执行申请内存及赋值语句

  

*p = (char *) malloc( num ); 
后未判断内存是否申请成功，应加上：

  

if ( *p == NULL ) 
{ 
 ...//进行申请内存失败处理 
} 
同时应考虑num>0；
  2. 未释放堆内存 动态分配的内存在程序结束之前没有释放，应该调用free, 把malloc生成的内存释放掉

  3. printf(str) 改为 printf("%s",str),否则可使用格式化
  字符串攻击


```
##### 8、下面代码会出现什么问题？ 
```
在执行
 

  

char *str = (char *) malloc(100);
 

  

后未进行内存是否申请成功的判断；另外，在free(str)后未置str为空，导致可能变成一个“野”指针，应加上：
 

  

str = NULL;
 

  

试题6的Test函数中也未对malloc的内存进行释放。
 

```
##### 9、看看下面的一段程序有什么错误? 
```
  1.需要一个返回值void 


  2在swap函数中，p是一个“野”指针，有可能指向系统区，导致程序运行的崩溃。在VC++中DEBUG运行时提示错误“Access Violation”。该程序应该改为：

void swap( int* p1,int* p2 ) 
{ 
 int p; 
 p = *p1; 
 *p1 = *p2; 
 *p2 = p; 
} 

```
##### 10、分别给出BOOL，int，float，指针变量 与“零值”比较的 if 语句（假设变量名为var）

```
  【解答】    
  BOOL型变量：if(!var)    
  int型变量： if(var==0)    
  float型变量：    
  const float EPSINON = 0.00001;    
  if ((x >= - EPSINON) && (x <= EPSINON)    
  指针变量：　　if(var==NULL)    
  【剖析】    

  考查对0值判断的“内功”，BOOL型变量的0判断完全可以写成if(var==0)，而int型变量也可以写成if(!var)，指针变量的判断也可以写成if(!var)，上述写法虽然程序都能正确运行，但是未能清晰地表达程序的意思。
    

  一般的，如果想让if判断一个变量的“真”、“假”，应直接使用if(var)、if(!var)，表明其为“逻辑”判断；如果用if判断一个数值型变量(short、int、long等)，应该用if(var==0)，表明是与0进行“数值”上的比较；而判断指针则适宜用if(var==NULL)，这是一种很好的编程习惯。
     

  浮点型变量并不精确，所以不可将float变量用“==”或“！=”与数字比较，应该设法转化成“>=”或“<=”形式。如果写成if
  (x == 0.0)，则判为错，得0分。   

```
##### 11、以下为Windows NT下的32位C++程序，请计算sizeof的值 
```
sizeof( str ) = 4
 

  

sizeof ( p ) = 4
 

  

【剖析】
 

  

Func ( char str[100] )函数中数组名作为函数形参时，在函数体内，数组名失去了本身的内涵，仅仅只是一个指针；在失去其内涵的同时，它还失去了其常量特性，可以作自增、自减等操作，可以被修改。
 

  

数组名的本质如下：
 

  

（1）数组名指代一种数据结构，这种数据结构就是数组；
 

  

例如：
 

  

char str[10]; 
cout ＜＜ sizeof(str) ＜＜ endl; 
输出结果为10，str指代数据结构char[10]。
 

  

（2）数组名可以转换为指向其指代实体的指针，而且是一个指针常量，不能作自增、自减等操作，不能被修改；
 

  

char str[10]; 
 

  

str++; //编译出错，提示str不是左值 

  


  （3）数组名作为函数形参时，沦为普通指针。
   


  Windows NT 32位平台下，指针的长度（占用内存的大小）为4字节，故sizeof( str ) 、sizeof ( p ) 都为4。
   


```
##### 12、
```
解答：
 

  

#define MIN(A,B) ((A) <= (B) ? (A) : (B))   
MIN(*p++, b)会产生宏的副作用
 

  

剖析：
 

  

这个面试题主要考查面试者对宏定义的使用，宏定义可以实现类似于函数的功能，但是它终归不是函数，而宏定义中括弧中的“参数”也不是真的参数，在宏展开的时候对“参数”进行的是一对一的替换。
 

  

程序员对宏定义的使用要非常小心，特别要注意两个问题：
 

  

（1）谨慎地将宏定义中的“参数”和整个宏用用括弧括起来。所以，严格地讲，下述解答：
 

  

#define MIN(A,B) (A) <= (B) ? (A) : (B) 
#define MIN(A,B) (A <= B ? A : B ) 
都应判0分；
 

  

（2）防止宏的副作用。
 

  

宏定义#define MIN(A,B) ((A) <= (B) ? (A) : (B))对MIN(*p++, b)的作用结果是：
 

  

((*p++) <= (b) ? (*p++) : (b))   

  这个表达式会产生副作用，指针p会作2次++自增操作。
   


  除此之外，另一个应该判0分的解答是：
   
  
    
  
  #define MIN(A,B) ((A) <= (B) ? (A) : (B));  
  这个解答在宏定义的后面加“;”，显示编写者对宏的概念模糊不清，只能被无情地判0分并被面试官淘汰。
   


```
##### 13、为什么标准头文件都有类似以下的结构？ 
```
头文件中的编译宏       #ifndef　__INCvxWorksh 
#define　__INCvxWorksh 
#endif   的作用是防止被重复引用。      作为一种面向对象的语言，C++支持函数重载，而过程式语言C则不支持。函数被C++编译后在symbol库中的名字与C语言的不同。例如，假设某个函数的原型为：       void foo(int x, int y);      该函数被C编译器编译后在symbol库中的名字为_foo，而C++编译器则会产生像_foo_int_int之类的名字。_foo_int_int这样的名字包含了函数名和函数参数数量及类型信息，C++就是靠这种机制来实现函数重载的。      为了实现C和C++的混合编程，C++提供了C连接交换指定符号extern "C"来解决名字匹配问题，函数声明前加上extern "C"后，则编译器就会按照C语言的方式将该函数编译为_foo，这样C语言中就可以调用C++的函数了。

```
##### 14、编写一个函数，作用是把一个char组成的字符串循环右移n个。比如原来是“abcdefghi”如果n=2，移位后应该是“hiabcdefg”
  
```
  void LoopMove(char *str, int steps) 
  { 
  int len = strlen(str); 
  char tmp[MAXSIZE]; 
  strcpy(tmp, str+len-steps); 
  strcpy(tmp+steps, str); 
  *(tmp+len)  = '/0'; 
  strcpy(str, tmp); 
  } 
  或: 
  void LoopMove(char *str, int steps) 
  { 
  int len = strlen(str); 
  char tmp[MAXSIZE]; 
  memcpy(tmp, str+len-steps, steps); 
  memcpy(str+steps, str, len-steps); 
  memcpy(str, tmp, steps); 
  } 

```
##### 15、已知WAV文件格式如下表，打开一个WAV文件，以适当的数据结构组织WAV文件头并解析WAV格式的各项信息。 
```
  将WAV文件格式定义为结构体WAVEFORMAT：  typedef struct tagWaveFormat 
{  
 char cRiffFlag[4];  
 UIN32 nFileLen;  
 char cWaveFlag[4];  
 char cFmtFlag[4];  
 char cTransition[4];  
 UIN16 nFormatTag ;  
 UIN16 nChannels;  
 UIN16 nSamplesPerSec;  
 UIN32 nAvgBytesperSec;  
 UIN16 nBlockAlign;  
 UIN16 nBitNumPerSample;  
 char cDataFlag[4]; UIN32 nAudioLength； } WAVEFORMAT;  假设WAV文件内容读出后存放在指针buffer开始的内存单元内，则分析文件格式的代码很简单，为：    WAVEFORMAT waveFormat;    memcpy( &waveFormat, buffer,sizeof( WAVEFORMAT ) );     直接通过访问waveFormat的成员，就可以获得特定WAV文件的各项格式信息。    【剖析】    试题6考查面试者组织数据结构的能力，有经验的程序设计者将属于一个整体的数据成员组织为一个结构体，利用指针类型转换，可以将memcpy、memset等函数直接用于结构体地址，进行结构体的整体操作。 透过这个题可以看出面试者的程序设计经验是否丰富。

```
##### 16、编写类String的构造函数、析构函数和赋值函数，已知类String的原型为： 
```
//普通构造函数 
String::String(const char *str)  
{ 
 if(str==NULL)  
 { 
 m_data = new char[1]; // 得分点：对空字符串自动申请存放结束标志'\0'的空 
 //加分点：对m_data加NULL 判断 
 *m_data = '\0';  
 }  
 else 
 { 
 int length = strlen(str);  
 m_data = new char[length+1]; 
 strcpy(m_data, str);  
 } 
} 
// String的析构函数 
String::~String(void)  
{ 
 delete [] m_data; // 或delete m_data; 
} 
//拷贝构造函数 
String::String(const String &other) 　　　// 得分点：输入参数为const型 
{  
 int length = strlen(other.m_data);  
 m_data = new char[length+1]; 　　　　
 strcpy(m_data, other.m_data);  
} 
//赋值函数 
String & String::operator =(const String &other) // 得分点：输入参数为const型 
{  
 if(this == &other) 　　//得分点：检查自赋值 
 return *this;  
 delete [] m_data; 　　　　//得分点：释放原有的内存资源 
 int length = strlen( other.m_data );  
 m_data = new char[length+1]; 　
 strcpy( m_data, other.m_data );  
 return *this; 　　　　　　　　//得分点：返回本对象的引用 
}    剖析    能够准确无误地编写出String类的构造函数、拷贝构造函数、赋值函数和析构函数的面试者至少已经具备了C++基本功的60%以上！     在这个类中包括了指针类成员变量m_data，当类中包括指针类成员变量时，一定要重载其拷贝构造函数、赋值函数和析构函数，这既是对C++程序员的基本要求，也是《Effective　C++》中特别强调的条款。     仔细学习这个类，特别注意加注释的得分点和加分点的意义，这样就具备了60%以上的C++基本功！   

```
##### 17、请说出static和const关键字尽可能多的作用

```
【解答】

  

static关键字至少有下列n个作用：
 

  

（1）函数体内static变量的作用范围为该函数体，不同于auto变量，该变量的内存只被分配一次，因此其值在下次调用时仍维持上次的值；
 

  

（2）在模块内的static全局变量可以被模块内所用函数访问，但不能被模块外其它函数访问；
 

  

（3）在模块内的static函数只可被这一模块内的其它函数调用，这个函数的使用范围被限制在声明它的模块内；
 

  

（4）在类中的static成员变量属于整个类所拥有，对类的所有对象只有一份拷贝；
 

  

（5）在类中的static成员函数属于整个类所拥有，这个函数不接收this指针，因而只能访问类的static成员变量。 
 

  

const关键字至少有下列n个作用：
 

  

（1）欲阻止一个变量被改变，可以使用const关键字。在定义该const变量时，通常需要对它进行初始化，因为以后就没有机会再去改变它了；
 

  

（2）对指针来说，可以指定指针本身为const，也可以指定指针所指的数据为const，或二者同时指定为const；
 

  

（3）在一个函数声明中，const可以修饰形参，表明它是一个输入参数，在函数内部不能改变其值；
 

  

（4）对于类的成员函数，若指定其为const类型，则表明其是一个常函数，不能修改类的
成员变量；
 

  

（5）对于类的成员函数，有时候必须指定其返回值为const类型，以使得其返回值不为“左值”。例如：
 

  

const classA operator*(const classA& a1,const classA& a2);
 

  

operator*的返回结果必须是一个const对象。如果不是，这样的变态代码也不会编译出错：
 

  

classA a, b, c;
 

  

(a * b) = c; // 对a*b的结果赋值
 

  

操作(a * b) = c显然不符合编程者的初衷，也没有任何意义。
 

  


```
##### 18、请写一个C函数，若处理器是Big_endian的，则返回0；若是Little_endian的，则返回1

```
【解答】

  

int checkCPU() 
{ 
 { 
 union w 
 {  
 int a; 
 char b; 
 } c; 
 c.a = 1; 
 return (c.b == 1); 
 } 
} 
【剖析】

  


  嵌入式系统开发者应该对Little-endian和Big-endian模式非常了解。采用Little-endian模式的CPU对操作数的存放方式是从低字节到高字节，而Big-endian模式对操作数的存放方式是从高字节到低字节。例如，16bit宽的数0x1234在Little-endian模式CPU内存中的存放方式（假设从地址0x4000开始存放）为： 


  
    
      
               内存地址      
               存放内容      
        
      
               0x4000      
               0x34      
        
      
               0x4001      
               0x12      
        
    
  
     而在Big-endian模式CPU内存中的存放方式则为：   
  
    
      
               内存地址      
               存放内容      
        
      
               0x4000      
               0x12      
        
      
               0x4001      
               0x34      
        
    
  
  
    32bit宽的数0x12345678在Little-endian模式CPU内存中的存放方式（假设从地址0x4000开始存放）为：   
  
    
      
               内存地址      
               存放内容      
        
      
               0x4000      
               0x78      
        
      
               0x4001      
               0x56      
        
      
               0x4002      
               0x34      
        
      
               0x4003      
               0x12      
        
    
  
     而在Big-endian模式CPU内存中的存放方式则为：   
  
    
      
               内存地址      
               存放内容      
        
      
               0x4000      
               0x12      
        
      
               0x4001      
               0x34      
        
      
               0x4002      
               0x56      
        
      
               0x4003      
               0x78      
        
    
  
  
    联合体union的存放顺序是所有成员都从低地址开始存放，面试者的解答利用该特性，轻松地获得了CPU对内存采用Little-endian还是Big-endian模式读写。如果谁能当场给出这个解答，那简直就是一个天才的程序员。   


```
##### 19、写一个函数返回1+2+3+…+n的值（假定结果不会超过长整型变量的范围）

```
  【解答】 
int Sum( int n ) 
{  
 return ( (long)1 + n) * n / 2;　　//或return (1l + n) * n / 2; 
} 
【剖析】

  

对于这个题，只能说，也许最简单的答案就是最好的答案。下面的解答，或者基于下面的解答思路去优化，不管怎么“折腾”，其效率也不可能与直接return ( 1 l + n ) * n / 2相比！ 
 

  

int Sum( int n ) 
{ 
 long sum = 0; 
 for( int i=1; i<=n; i++ ) 
 { 
 sum += i; 
 } 
 return sum; 
}  

```
##### 20、
```
  参考回答:    1. 全局静态变量    在全局变量前加上关键字static，全局变量就定义成一个全局静态变量.    静态存储区，在整个程序运行期间一直存在。    初始化：未经初始化的全局静态变量会被自动初始化为0（自动对象的值是任意的，除非他被显式初始化）；    作用域：全局静态变量在声明他的文件之外是不可见的，准确地说是从定义之处开始，到文件结尾。    2.  局部静态变量    在局部变量之前加上关键字static，局部变量就成为一个局部静态变量。    内存中的位置：静态存储区    初始化：未经初始化的全局静态变量会被自动初始化为0（自动对象的值是任意的，除非他被显式初始化）；    作用域：作用域仍为局部作用域，当定义它的函数或者语句块结束的时候，作用域结束。但是当局部静态变量离开作用域后，并没有销毁，而是仍然驻留在内存当中，只不过我们不能再对它进行访问，直到该函数再次被调用，并且值不变；    3. 静态函数    在函数返回类型前加static，函数就定义为静态函数。函数的定义和声明在默认情况下都是extern的，但静态函数只是在声明他的文件当中可见，不能被其他文件所用。    函数的实现使用static修饰，那么这个函数只可在本cpp内使用，不会同其他cpp中的同名函数引起冲突；    warning：不要再头文件中声明static的全局函数，不要在cpp内声明非static的全局函数，如果你要在多个cpp中复用该函数，就把它的声明提到头文件里去，否则cpp内部声明需加上static修饰；    4. 类的静态成员    在类中，静态成员可以实现多个对象之间的数据共享，并且使用静态数据成员还不会破坏隐藏的原则，即保证了安全性。因此，静态成员是类的所有对象中共享的成员，而不是某个对象的成员。对多个对象来说，静态数据成员只存储一处，供所有对象共用    5. 类的静态函数    静态成员函数和静态数据成员一样，它们都属于类的静态成员，它们都不是对象成员。因此，对静态成员的引用不需要用对象名。    在静态成员函数的实现中不能直接引用类中说明的非静态成员，可以引用类中说明的静态成员（这点非常重要）。如果静态成员函数中要引用非静态成员时，可通过对象来引用。从中可看出，调用静态成员函数使用如下格式：<类名>::<静态成员函数名>(<参数表>); 

```
##### 21、
```
  参考回答:       设计思想上：   C++是面向对象的语言，而C是面向过程的结构化编程语言    语法上：    C++具有重载、继承和多态三种特性    C++相比C，增加多许多类型安全的功能，比如强制类型转换、    C++支持范式编程，比如模板类、函数模板等 

```
##### 22、
```
  参考回答:       对于函数定义和代码块之外的变量声明，static修改标识符的链接属性，由默认的external变为internal，作用域和存储类型不改变，这些符号只能在声明它们的源文件中访问。   对于代码块内部的变量声明，static修改标识符的存储类型，由自动变量改为静态变量，作用域和链接属性不变。这种变量在程序执行之前就创建，在程序执行的整个周期都存在。    对于被static修饰的普通函数，其只能在定义它的源文件中使用，不能在其他源文件中被引用    对于被static修饰的类成员变量和成员函数，它们是属于类的，而不是某个对象，所有对象共享一个静态成员。静态成员通过<类名>::<静态成员>来使用。 

```
##### 23、
```
  参考回答:       1. 全局静态变量   在全局变量前加上关键字static，全局变量就定义成一个全局静态变量。    静态存储区，在整个程序运行期间一直存在。    初始化：未经初始化的全局静态变量会被自动初始化为0（自动对象的值是任意的，除非他被显式初始化）。    作用域：全局静态变量在声明他的文件之外是不可见的，准确地说是从定义之处开始，到文件结尾。    2.  局部静态变量    在局部变量之前加上关键字static，局部变量就成为一个局部静态变量。    内存中的位置：静态存储区。    初始化：未经初始化的全局静态变量会被自动初始化为0（自动对象的值是任意的，除非他被显式初始化）。    作用域：作用域仍为局部作用域，当定义它的函数或者语句块结束的时候，作用域结束。但是当局部静态变量离开作用域后，并没有销毁，而是仍然驻留在内存当中，只不过我们不能再对它进行访问，直到该函数再次被调用，并且值不变。    3. 静态函数    在函数返回类型前加static，函数就定义为静态函数。函数的定义和声明在默认情况下都是extern的，但静态函数只是在声明他的文件当中可见，不能被其他文件所用。    函数的实现使用static修饰，那么这个函数只可在本cpp内使用，不会同其他cpp中的同名函数引起冲突。    warning：不要再头文件中声明static的全局函数，不要在cpp内声明非static的全局函数，如果你要在多个cpp中复用该函数，就把它的声明提到头文件里去，否则cpp内部声明需加上static修饰。    4. 类的静态成员    在类中，静态成员可以实现多个对象之间的数据共享，并且使用静态数据成员还不会破坏隐藏的原则，即保证了安全性。因此，静态成员是类的所有对象中共享的成员，而不是某个对象的成员。对多个对象来说，静态数据成员只存储一处，供所有对象共用。    5. 类的静态函数    静态成员函数和静态数据成员一样，它们都属于类的静态成员，它们都不是对象成员。因此，对静态成员的引用不需要用对象名。    在静态成员函数的实现中不能直接引用类中说明的非静态成员，可以引用类中说明的静态成员（这点非常重要）。如果静态成员函数中要引用非静态成员时，可通过对象来引用。从中可看出，调用静态成员函数使用如下格式：<类名>::<静态成员函数名>(<参数表>); 

```
##### 24、
```
  参考回答:  C++中四种类型转换是：static_cast, dynamic_cast, const_cast, reinterpret_cast   1、const_cast    用于将const变量转为非const    2、static_cast    用于各种隐式转换，比如非const转const，void*转指针等, static_cast能用于多态向上转化，如果向下转能成功但是不安全，结果未知；    3、dynamic_cast    用于动态类型转换。只能用于含有虚函数的类，用于类层次间的向上和向下转化。只能转指针或引用。向下转化时，如果是非法的对于指针返回NULL，对于引用抛异常。要深入了解内部转换的原理。    向上转换：指的是子类向基类的转换    向下转换：指的是基类向子类的转换    它通过判断在执行到该语句的时候变量的运行时类型和要转换的类型是否相同来判断是否能够进行向下转换。    4、reinterpret_cast    几乎什么都可以转，比如将int转指针，可能会出问题，尽量少用；    5、为什么不使用C的强制转换？    C的强制转换表面上看起来功能强大什么都能转，但是转化不够明确，不能进行错误检查，容易出错。 

```
##### 25、
```
  参考回答:      1.指针有自己的一块空间，而引用只是一个别名；   2.使用sizeof看一个指针的大小是4，而引用则是被引用对象的大小；    3.指针可以被初始化为NULL，而引用必须被初始化且必须是一个已有对象 的引用；    4.作为参数传递时，指针需要被解引用才可以对对象进行操作，而直接对引 用的修改都会改变引用所指向的对象；    5.可以有const指针，但是没有const引用；    6.指针在使用中可以指向其它对象，但是引用只能是一个对象的引用，不能 被改变；    7.指针可以有多级指针（**p），而引用至于一级；    8.指针和引用使用++运算符的意义不一样；    9.如果返回动态内存分配的对象或者内存，必须使用指针，引用可能引起内存泄露。 

```
##### 26、
```
  参考回答:       根据面积法，如果P在三角形ABC内，那么三角形ABP的面积+三角形BCP的面积+三角形ACP的面积应该等于三角形ABC的面积。算法如下：   #include <iostream>    #include <math.h>    using namespace std;        #define ABS_FLOAT_0 0.0001        struct point_float    {    float x;    float y;    };        /**    * @brief 计算三角形面积    */    float GetTriangleSquar(const point_float pt0, const point_float pt1, const point_float pt2)    {    point_float AB,   BC;    AB.x = pt1.x - pt0.x;    AB.y = pt1.y - pt0.y;    BC.x = pt2.x - pt1.x;    BC.y = pt2.y - pt1.y;    return fabs((AB.x * BC.y - AB.y * BC.x)) / 2.0f;    }        /**    * @brief 判断给定一点是否在三角形内或边上    */    bool IsInTriangle(const point_float A, const point_float B, const point_float C, const point_float D)    {    float SABC, SADB, SBDC, SADC;    SABC = GetTriangleSquar(A, B, C);    SADB = GetTriangleSquar(A, D, B);    SBDC = GetTriangleSquar(B, D, C);    SADC = GetTriangleSquar(A, D, C);        float SumSuqar = SADB + SBDC + SADC;        if ((-ABS_FLOAT_0 < (SABC - SumSuqar)) && ((SABC - SumSuqar) < ABS_FLOAT_0))    {    return true;    }    else    {    return false;    }    } 

```
##### 27、
```
  参考回答:  C++里面的四个智能指针: auto_ptr, shared_ptr, weak_ptr, unique_ptr 其中后三个是c++11支持，并且第一个已经被11弃用。   为什么要使用智能指针：    智能指针的作用是管理一个指针，因为存在以下这种情况：申请的空间在函数结束时忘记释放，造成内存泄漏。使用智能指针可以很大程度上的避免这个问题，因为智能指针就是一个类，当超出了类的作用域是，类会自动调用析构函数，析构函数会自动释放资源。所以智能指针的作用原理就是在函数结束时自动释放内存空间，不需要手动释放内存空间。        1. auto_ptr（c++98的方案，cpp11已经抛弃）    采用所有权模式。    auto_ptr< string> p1 (new string ("I reigned lonely as a cloud.”));    auto_ptr<string> p2;    p2 = p1; //auto_ptr不会报错.    此时不会报错，p2剥夺了p1的所有权，但是当程序运行时访问p1将会报错。所以auto_ptr的缺点是：存在潜在的内存崩溃问题！        2. unique_ptr（替换auto_ptr）    unique_ptr实现独占式拥有或严格拥有概念，保证同一时间内只有一个智能指针可以指向该对象。它对于避免资源泄露(例如“以new创建对象后因为发生异常而忘记调用delete”)特别有用。    采用所有权模式，还是上面那个例子    unique_ptr<string> p3 (new string ("auto"));   //#4    unique_ptr<string> p4；                       //#5    p4 = p3;//此时会报错！！        编译器认为p4=p3非法，避免了p3不再指向有效数据的问题。因此，unique_ptr比auto_ptr更安全。    另外unique_ptr还有更聪明的地方：当程序试图将一个 unique_ptr 赋值给另一个时，如果源 unique_ptr 是个临时右值，编译器允许这么做；如果源 unique_ptr 将存在一段时间，编译器将禁止这么做，比如：    unique_ptr<string> pu1(new string ("hello world"));    unique_ptr<string> pu2;    pu2 = pu1;                                      // #1 not allowed    unique_ptr<string> pu3;    pu3 = unique_ptr<string>(new string ("You"));   // #2 allowed        其中#1留下悬挂的unique_ptr(pu1)，这可能导致危害。而#2不会留下悬挂的unique_ptr，因为它调用 unique_ptr 的构造函数，该构造函数创建的临时对象在其所有权让给 pu3 后就会被销毁。这种随情况而已的行为表明，unique_ptr 优于允许两种赋值的auto_ptr 。    注：如果确实想执行类似与#1的操作，要安全的重用这种指针，可给它赋新值。C++有一个标准库函数std::move()，让你能够将一个unique_ptr赋给另一个。例如：    unique_ptr<string> ps1, ps2;    ps1 = demo("hello");    ps2 = move(ps1);    ps1 = demo("alexia");    cout << *ps2 << *ps1 << endl;        3. shared_ptr    shared_ptr实现共享式拥有概念。多个智能指针可以指向相同对象，该对象和其相关资源会在“最后一个引用被销毁”时候释放。从名字share就可以看出了资源可以被多个指针共享，它使用计数机制来表明资源被几个指针共享。可以通过成员函数use_count()来查看资源的所有者个数。除了可以通过new来构造，还可以通过传入auto_ptr, unique_ptr,weak_ptr来构造。当我们调用release()时，当前指针会释放资源所有权，计数减一。当计数等于0时，资源会被释放。    shared_ptr 是为了解决 auto_ptr 在对象所有权上的局限性(auto_ptr 是独占的), 在使用引用计数的机制上提供了可以共享所有权的智能指针。    成员函数：    use_count 返回引用计数的个数    unique 返回是否是独占所有权( use_count 为 1)    swap 交换两个 shared_ptr 对象(即交换所拥有的对象)    reset 放弃内部对象的所有权或拥有对象的变更, 会引起原有对象的引用计数的减少    get 返回内部对象(指针), 由于已经重载了()方法, 因此和直接使用对象是一样的.如 shared_ptr<int> sp(new int(1)); sp 与 sp.get()是等价的        4. weak_ptr    weak_ptr 是一种不控制对象生命周期的智能指针, 它指向一个 shared_ptr 管理的对象. 进行该对象的内存管理的是那个强引用的 shared_ptr. weak_ptr只是提供了对管理对象的一个访问手段。weak_ptr 设计的目的是为配合 shared_ptr 而引入的一种智能指针来协助 shared_ptr 工作, 它只可以从一个 shared_ptr 或另一个 weak_ptr 对象构造, 它的构造和析构不会引起引用记数的增加或减少。weak_ptr是用来解决shared_ptr相互引用时的死锁问题,如果说两个shared_ptr相互引用,那么这两个指针的引用计数永远不可能下降为0,资源永远不会释放。它是对对象的一种弱引用，不会增加对象的引用计数，和shared_ptr之间可以相互转化，shared_ptr可以直接赋值给它，它可以通过调用lock函数来获得shared_ptr。    class B;    class A    {    public:    shared_ptr<B> pb_;    ~A()    {    cout<<"A delete\n";    }    };    class B    {    public:    shared_ptr<A> pa_;    ~B()    {    cout<<"B delete\n";    }    };    void fun()    {    shared_ptr<B> pb(new B());    shared_ptr<A> pa(new A());    pb->pa_ = pa;    pa->pb_ = pb;    cout<<pb.use_count()<<endl;    cout<<pa.use_count()<<endl;    }    int main()    {    fun();    return 0;    }    可以看到fun函数中pa ，pb之间互相引用，两个资源的引用计数为2，当要跳出函数时，智能指针pa，pb析构时两个资源引用计数会减一，但是两者引用计数还是为1，导致跳出函数时资源没有被释放（A B的析构函数没有被调用），如果把其中一个改为weak_ptr就可以了，我们把类A里面的shared_ptr pb_; 改为weak_ptr pb_; 运行结果如下，这样的话，资源B的引用开始就只有1，当pb析构时，B的计数变为0，B得到释放，B释放的同时也会使A的计数减一，同时pa析构时使A的计数减一，那么A的计数为0，A得到释放。    注意的是我们不能通过weak_ptr直接访问对象的方法，比如B对象中有一个方法print(),我们不能这样访问，pa->pb_->print(); 英文pb_是一个weak_ptr，应该先把它转化为shared_ptr,如：shared_ptr p = pa->pb_.lock(); p->print(); 

```
##### 28、
```
  参考回答:       1、判断一个数是不是二的倍数，即判断该数二进制末位是不是0：   a % 2 == 0 或者a & 0x0001 == 0。        2、求一个数中1的位数，可以直接逐位除十取余判断：    int fun(long x)    {    int _count = 0;    while(x)    {    if(x % 10 == 1)    ++_count;    x /= 10;    }    return _count;    }        int main()    {    cout << fun(123321) << endl;    return 0;    } 

```
##### 29、
```
  参考回答:       指针和数组的主要区别如下：                                指针                              数组                                      保存数据的地址                              保存数据                                      间接访问数据，首先获得指针的内容，然后将其作为地址，从该地址中提取数据                              直接访问数据，                                      通常用于动态的数据结构                              通常用于固定数目且数据类型相同的元素                                      通过Malloc分配内存，free释放内存                              隐式的分配和删除                                      通常指向匿名数据，操作匿名函数                              自身即为数据名                        

```
##### 30、
```
  参考回答:  野指针就是指向一个已删除的对象或者未申请访问受限内存区域的指针

```
##### 31、
```
  参考回答:       智能指针主要用于管理在堆上分配的内存，它将普通的指针封装为一个栈对象。当栈对象的生存周期结束后，会在析构函数中释放掉申请的内存，从而防止内存泄漏。C++ 11中最常用的智能指针类型为shared_ptr,它采用引用计数的方法，记录当前内存资源被多少个智能指针引用。该引用计数的内存在堆上分配。当新增一个时引用计数加1，当过期时引用计数减一。只有引用计数为0时，智能指针才会自动释放引用的内存资源。对shared_ptr进行初始化时不能将一个普通指针直接赋值给智能指针，因为一个是指针，一个是类。可以通过make_shared函数或者通过构造函数传入普通指针。并可以通过get函数获得普通指针。

```
##### 32、
```
     参考回答:   当两个对象相互使用一个shared_ptr成员变量指向对方，会造成循环引用，使引用计数失效，从而导致内存泄漏。例如：                     上述代码中，parent有一个shared_ptr类型的成员指向孩子，而child也有一个shared_ptr类型的成员指向父亲。然后在创建孩子和父亲对象时也使用了智能指针c和p，随后将c和p分别又赋值给child的智能指针成员parent和parent的智能指针成员child。从而形成了一个循环引用： 

```
##### 33、
```
  参考回答:       为了解决循环引用导致的内存泄漏，引入了weak_ptr弱指针，weak_ptr的构造函数不会修改引用计数的值，从而不会对对象的内存进行管理，其类似一个普通指针，但不指向引用计数的共享内存，但是其可以检测到所管理的对象是否已经被释放，从而避免非法访问。

```
##### 34、
```
  参考回答:       定义：   1、引用：    C++是C语言的继承，它可进行过程化程序设计，又可以进行以抽象数据类型为特点的基于对象的程序设计，还可以进行以继承和多态为特点的面向对象的程序设计。引用就是C++对C语言的重要扩充。引用就是某一变量的一个别名，对引用的操作与对变量直接操作完全一样。引用的声明方法：类型标识符 &引用名=目标变量名；引用引入了对象的一个同义词。定义引用的表示方法与定义指针相似，只是用&代替了*。    2、指针：    指针利用地址，它的值直接指向存在电脑存储器中另一个地方的值。由于通过地址能找到所需的变量单元，可以说，地址指向该变量单元。因此，将地址形象化的称为“指针”。意思是通过它能找到以它为地址的内存单元。    区别：    1、指针有自己的一块空间，而引用只是一个别名；    2、使用sizeof看一个指针的大小是4，而引用则是被引用对象的大小；    3、指针可以被初始化为NULL，而引用必须被初始化且必须是一个已有对象的引用；    4、作为参数传递时，指针需要被解引用才可以对对象进行操作，而直接对引用的修改都会改变引用所指向的对象；    5、可以有const指针，但是没有const引用；    6、指针在使用中可以指向其它对象，但是引用只能是一个对象的引用，不能 被改变；    7、指针可以有多级指针（**p），而引用至于一级；    8、指针和引用使用++运算符的意义不一样；    9、如果返回动态内存分配的对象或者内存，必须使用指针，引用可能引起内存泄露。 

```
##### 35、
```
  参考回答:       C++里面的四个智能指针: auto_ptr, shared_ptr, weak_ptr, unique_ptr 其中后三个是c++11支持，并且第一个已经被11弃用。   为什么要使用智能指针：    智能指针的作用是管理一个指针，因为存在以下这种情况：申请的空间在函数结束时忘记释放，造成内存泄漏。使用智能指针可以很大程度上的避免这个问题，因为智能指针就是一个类，当超出了类的作用域是，类会自动调用析构函数，析构函数会自动释放资源。所以智能指针的作用原理就是在函数结束时自动释放内存空间，不需要手动释放内存空间。        1、auto_ptr（c++98的方案，cpp11已经抛弃）    采用所有权模式。    auto_ptr< string> p1 (new string ("I reigned lonely as a cloud.”));    auto_ptr<string> p2;    p2 = p1; //auto_ptr不会报错.    此时不会报错，p2剥夺了p1的所有权，但是当程序运行时访问p1将会报错。所以auto_ptr的缺点是：存在潜在的内存崩溃问题！        2、unique_ptr（替换auto_ptr）    unique_ptr实现独占式拥有或严格拥有概念，保证同一时间内只有一个智能指针可以指向该对象。它对于避免资源泄露(例如“以new创建对象后因为发生异常而忘记调用delete”)特别有用。    采用所有权模式，还是上面那个例子    unique_ptr<string> p3 (new string ("auto"));           //#4    unique_ptr<string> p4；                           //#5    p4 = p3;//此时会报错！！        编译器认为p4=p3非法，避免了p3不再指向有效数据的问题。因此，unique_ptr比auto_ptr更安全。    另外unique_ptr还有更聪明的地方：当程序试图将一个 unique_ptr 赋值给另一个时，如果源 unique_ptr 是个临时右值，编译器允许这么做；如果源 unique_ptr 将存在一段时间，编译器将禁止这么做，比如：    unique_ptr<string> pu1(new string ("hello world"));    unique_ptr<string> pu2;    pu2 = pu1;                                          // #1 not allowed    unique_ptr<string> pu3;    pu3 = unique_ptr<string>(new string ("You"));           // #2 allowed        其中#1留下悬挂的unique_ptr(pu1)，这可能导致危害。而#2不会留下悬挂的unique_ptr，因为它调用 unique_ptr 的构造函数，该构造函数创建的临时对象在其所有权让给 pu3 后就会被销毁。这种随情况而已的行为表明，unique_ptr 优于允许两种赋值的auto_ptr 。    注：如果确实想执行类似与#1的操作，要安全的重用这种指针，可给它赋新值。C++有一个标准库函数std::move()，让你能够将一个unique_ptr赋给另一个。例如：    unique_ptr<string> ps1, ps2;    ps1 = demo("hello");    ps2 = move(ps1);    ps1 = demo("alexia");    cout << *ps2 << *ps1 << endl;        3、shared_ptr    shared_ptr实现共享式拥有概念。多个智能指针可以指向相同对象，该对象和其相关资源会在“最后一个引用被销毁”时候释放。从名字share就可以看出了资源可以被多个指针共享，它使用计数机制来表明资源被几个指针共享。可以通过成员函数use_count()来查看资源的所有者个数。除了可以通过new来构造，还可以通过传入auto_ptr, unique_ptr,weak_ptr来构造。当我们调用release()时，当前指针会释放资源所有权，计数减一。当计数等于0时，资源会被释放。    shared_ptr 是为了解决 auto_ptr 在对象所有权上的局限性(auto_ptr 是独占的), 在使用引用计数的机制上提供了可以共享所有权的智能指针。    成员函数：    use_count 返回引用计数的个数    unique 返回是否是独占所有权( use_count 为 1)    swap 交换两个 shared_ptr 对象(即交换所拥有的对象)    reset 放弃内部对象的所有权或拥有对象的变更, 会引起原有对象的引用计数的减少    get 返回内部对象(指针), 由于已经重载了()方法, 因此和直接使用对象是一样的.如 shared_ptr<int> sp(new int(1)); sp 与 sp.get()是等价的        4、weak_ptr    weak_ptr 是一种不控制对象生命周期的智能指针, 它指向一个 shared_ptr 管理的对象. 进行该对象的内存管理的是那个强引用的 shared_ptr. weak_ptr只是提供了对管理对象的一个访问手段。weak_ptr 设计的目的是为配合 shared_ptr 而引入的一种智能指针来协助 shared_ptr 工作, 它只可以从一个 shared_ptr 或另一个 weak_ptr 对象构造, 它的构造和析构不会引起引用记数的增加或减少。weak_ptr是用来解决shared_ptr相互引用时的死锁问题,如果说两个shared_ptr相互引用,那么这两个指针的引用计数永远不可能下降为0,资源永远不会释放。它是对对象的一种弱引用，不会增加对象的引用计数，和shared_ptr之间可以相互转化，shared_ptr可以直接赋值给它，它可以通过调用lock函数来获得shared_ptr。    class B;    class A    {    public:    shared_ptr<B> pb_;    ~A()    {    cout<<"A delete\n";    }    };    class B    {    public:    shared_ptr<A> pa_;    ~B()    {    cout<<"B delete\n";    }    };    void fun()    {    shared_ptr<B> pb(new B());    shared_ptr<A> pa(new A());    pb->pa_ = pa;    pa->pb_ = pb;    cout<<pb.use_count()<<endl;    cout<<pa.use_count()<<endl;    }    int main()    {    fun();    return 0;    }    可以看到fun函数中pa ，pb之间互相引用，两个资源的引用计数为2，当要跳出函数时，智能指针pa，pb析构时两个资源引用计数会减一，但是两者引用计数还是为1，导致跳出函数时资源没有被释放（A B的析构函数没有被调用），如果把其中一个改为weak_ptr就可以了，我们把类A里面的shared_ptr pb_; 改为weak_ptr pb_; 运行结果如下，这样的话，资源B的引用开始就只有1，当pb析构时，B的计数变为0，B得到释放，B释放的同时也会使A的计数减一，同时pa析构时使A的计数减一，那么A的计数为0，A得到释放。    注意的是我们不能通过weak_ptr直接访问对象的方法，比如B对象中有一个方法print(),我们不能这样访问，pa->pb_->print(); 英文pb_是一个weak_ptr，应该先把它转化为shared_ptr,如：shared_ptr p = pa->pb_.lock(); p->print(); 

```
##### 36、
```
  参考回答:       将可能会被继承的父类的析构函数设置为虚函数，可以保证当我们new一个子类，然后使用基类指针指向该子类对象，释放基类指针时可以释放掉子类的空间，防止内存泄漏。       C++默认的析构函数不是虚函数是因为虚函数需要额外的虚函数表和虚表指针，占用额外的内存。而对于不会被继承的类来说，其析构函数如果是虚函数，就会浪费内存。因此C++默认的析构函数不是虚函数，而是只有当需要当作父类时，设置为虚函数。 

```
##### 37、
```
  参考回答:       1、定义   函数指针是指向函数的指针变量。    函数指针本身首先是一个指针变量，该指针变量指向一个具体的函数。这正如用指针变量可指向整型变量、字符型、数组一样，这里是指向函数。    C在编译时，每一个函数都有一个入口地址，该入口地址就是函数指针所指向的地址。有了指向函数的指针变量后，可用该指针变量调用函数，就如同用指针变量可引用其他类型变量一样，在这些概念上是大体一致的。    2、用途：    调用函数和做函数的参数，比如回调函数。    3、示例：    char * fun(char * p)  {…}       // 函数fun    char * (*pf)(char * p);             // 函数指针pf    pf = fun;                        // 函数指针pf指向函数fun    pf(p);                        // 通过函数指针pf调用函数fun 

```
##### 38、
```
  参考回答:       Fork：创建一个和当前进程映像一样的进程可以通过fork( )系统调用：   #include <sys/types.h>    #include <unistd.h>    pid_t fork(void);    成功调用fork( )会创建一个新的进程，它几乎与调用fork( )的进程一模一样，这两个进程都会继续运行。在子进程中，成功的fork( )调用会返回0。在父进程中fork( )返回子进程的pid。如果出现错误，fork( )返回一个负值。    最常见的fork( )用法是创建一个新的进程，然后使用exec( )载入二进制映像，替换当前进程的映像。这种情况下，派生（fork）了新的进程，而这个子进程会执行一个新的二进制可执行文件的映像。这种“派生加执行”的方式是很常见的。    在早期的Unix系统中，创建进程比较原始。当调用fork时，内核会把所有的内部数据结构复制一份，复制进程的页表项，然后把父进程的地址空间中的内容逐页的复制到子进程的地址空间中。但从内核角度来说，逐页的复制方式是十分耗时的。现代的Unix系统采取了更多的优化，例如Linux，采用了写时复制的方法，而不是对父进程空间进程整体复制。 

```
##### 39、
```
  参考回答:       析构函数与构造函数对应，当对象结束其生命周期，如对象所在的函数已调用完毕时，系统会自动执行析构函数。   析构函数名也应与类名相同，只是在函数名前面加一个位取反符~，例如~stud( )，以区别于构造函数。它不能带任何参数，也没有返回值（包括void类型）。只能有一个析构函数，不能重载。    如果用户没有编写析构函数，编译系统会自动生成一个缺省的析构函数（即使自定义了析构函数，编译器也总是会为我们合成一个析构函数，并且如果自定义了析构函数，编译器在执行时会先调用自定义的析构函数再调用合成的析构函数），它也不进行任何操作。所以许多简单的类中没有用显式的析构函数。    如果一个类中有指针，且在使用的过程中动态的申请了内存，那么最好显示构造析构函数在销毁类之前，释放掉申请的内存空间，避免内存泄漏。    类析构顺序：1）派生类本身的析构函数；2）对象成员析构函数；3）基类析构函数。 

```
##### 40、
```
  参考回答:       map和set都是C++的关联容器，其底层实现都是红黑树（RB-Tree）。由于 map 和set所开放的各种操作接口，RB-tree 也都提供了，所以几乎所有的 map 和set的操作行为，都只是转调 RB-tree 的操作行为。   map和set区别在于：    （1）map中的元素是key-value（关键字—值）对：关键字起到索引的作用，值则表示与索引相关联的数据；Set与之相对就是关键字的简单集合，set中每个元素只包含一个关键字。    （2）set的迭代器是const的，不允许修改元素的值；map允许修改value，但不允许修改key。其原因是因为map和set是根据关键字排序来保证其有序性的，如果允许修改key的话，那么首先需要删除该键，然后调节平衡，再插入修改后的键值，调节平衡，如此一来，严重破坏了map和set的结构，导致iterator失效，不知道应该指向改变前的位置，还是指向改变后的位置。所以STL中将set的迭代器设置成const，不允许修改迭代器的值；而map的迭代器则不允许修改key值，允许修改value值。    （3）map支持下标操作，set不支持下标操作。map可以用key做下标，map的下标运算符[ ]将关键码作为下标去执行查找，如果关键码不存在，则插入一个具有该关键码和mapped_type类型默认值的元素至map中，因此下标运算符[ ]在map应用中需要慎用，const_map不能用，只希望确定某一个关键值是否存在而不希望插入元素时也不应该使用，mapped_type类型没有默认值也不应该使用。如果find能解决需要，尽可能用find。 

```
##### 41、
```
  参考回答:       STL的分配器用于封装STL容器在内存管理上的底层细节。在C++中，其内存配置和释放如下：   new运算分两个阶段：(1)调用::operator new配置内存;(2)调用对象构造函数构造对象内容    delete运算分两个阶段：(1)调用对象希构函数；(2)掉员工::operator delete释放内存    为了精密分工，STL allocator将两个阶段操作区分开来：内存配置有alloc::allocate()负责，内存释放由alloc::deallocate()负责；对象构造由::construct()负责，对象析构由::destroy()负责。    同时为了提升内存管理的效率，减少申请小内存造成的内存碎片问题，SGI STL采用了两级配置器，当分配的空间大小超过128B时，会使用第一级空间配置器；当分配的空间大小小于128B时，将使用第二级空间配置器。第一级空间配置器直接使用malloc()、realloc()、free()函数进行内存空间的分配和释放，而第二级空间配置器采用了内存池技术，通过空闲链表来管理内存。 

```
##### 42、
```
  参考回答:       参考回答：C++通过 public、protected、private 三个关键字来控制成员变量和成员函数的访问权限，它们分别表示公有的、受保护的、私有的，被称为成员访问限定符。在类的内部（定义类的代码内部），无论成员被声明为 public、protected 还是 private，都是可以互相访问的，没有访问权限的限制。在类的外部（定义类的代码之外），只能通过对象访问成员，并且通过对象只能访问 public 属性的成员，不能访问 private、protected 属性的成员

```
##### 43、
```
  参考回答:  在C++中，可以用struct和class定义类，都可以继承。区别在于：structural的默认继承权限和默认访问权限是public，而class的默认继承权限和默认访问权限是private。   另外，class还可以定义模板类形参，比如template <class T, int i>。 

```
##### 44、
```
  参考回答:       对于C++源文件，从文本到可执行文件一般需要四个过程：   预处理阶段：对源代码文件中文件包含关系（头文件）、预编译语句（宏定义）进行分析和替换，生成预编译文件。    编译阶段：将经过预处理后的预编译文件转换成特定汇编代码，生成汇编文件    汇编阶段：将编译阶段生成的汇编文件转化成机器码，生成可重定位目标文件    链接阶段：将多个目标文件及所需要的库连接成最终的可执行目标文件 

```
##### 45、
```
  参考回答:       Include头文件的顺序：对于include的头文件来说，如果在文件a.h中声明一个在文件b.h中定义的变量，而不引用b.h。那么要在a.c文件中引用b.h文件，并且要先引用b.h，后引用a.h,否则汇报变量类型未声明错误。   双引号和尖括号的区别：编译器预处理阶段查找头文件的路径不一样。    对于使用双引号包含的头文件，查找头文件路径的顺序为：    当前头文件目录    编译器设置的头文件路径（编译器可使用-I显式指定搜索路径）    系统变量CPLUS_INCLUDE_PATH/C_INCLUDE_PATH指定的头文件路径    对于使用尖括号包含的头文件，查找头文件的路径顺序为：    编译器设置的头文件路径（编译器可使用-I显式指定搜索路径）    系统变量CPLUS_INCLUDE_PATH/C_INCLUDE_PATH指定的头文件路径 

```
##### 46、
```
  参考回答:       Malloc函数用于动态分配内存。为了减少内存碎片和系统调用的开销，malloc其采用内存池的方式，先申请大块内存作为堆区，然后将堆区分为多个内存块，以块作为内存管理的基本单位。当用户申请内存时，直接从堆区分配一块合适的空闲块。Malloc采用隐式链表结构将堆区分成连续的、大小不一的块，包含已分配块和未分配块；同时malloc采用显示链表结构来管理所有的空闲块，即使用一个双向链表将空闲块连接起来，每一个空闲块记录了一个连续的、未分配的地址。   当进行内存分配时，Malloc会通过隐式链表遍历所有的空闲块，选择满足要求的块进行分配；当进行内存合并时，malloc采用边界标记法，根据每个块的前后块是否已经分配来决定是否进行块合并。    Malloc在申请内存时，一般会通过brk或者mmap系统调用进行申请。其中当申请内存小于128K时，会使用系统函数brk在堆区中分配；而当申请内存大于128K时，会使用系统函数mmap在映射区分配。 

```
##### 47、
```
  参考回答:       在C++中，虚拟内存分为代码段、数据段、BSS段、堆区、文件映射区以及栈区六部分。   代码段:包括只读存储区和文本区，其中只读存储区存储字符串常量，文本区存储程序的机器代码。    数据段：存储程序中已初始化的全局变量和静态变量    bss 段：存储未初始化的全局变量和静态变量（局部+全局），以及所有被初始化为0的全局变量和静态变量。    堆区：调用new/malloc函数时在堆区动态分配内存，同时需要调用delete/free来手动释放申请的内存。    映射区:存储动态链接库以及调用mmap函数进行的文件映射    栈：使用栈空间存储函数的返回地址、参数、局部变量、返回值 

```
##### 48、
```
     参考回答:           32bitCPU可寻址4G线性空间，每个进程都有各自独立的4G逻辑地址，其中0~3G是用户态空间，3~4G是内核空间，不同进程相同的逻辑地址会映射到不同的物理地址中。其逻辑地址其划分如下：       各个段说明如下：       3G用户空间和1G内核空间       静态区域：       text segment(代码段):包括只读存储区和文本区，其中只读存储区存储字符串常量，文本区存储程序的机器代码。       data segment(数据段)：存储程序中已初始化的全局变量和静态变量       bss segment：存储未初始化的全局变量和静态变量（局部+全局），以及所有被初始化为0的全局变量和静态变量，对于未初始化的全局变量和静态变量，程序运行main之前时会统一清零。即未初始化的全局变量编译器会初始化为0       动态区域：       heap（堆）： 当进程未调用malloc时是没有堆段的，只有调用malloc时采用分配一个堆，并且在程序运行过程中可以动态增加堆大小(移动break指针)，从低地址向高地址增长。分配小内存时使用该区域。  堆的起始地址由mm_struct 结构体中的start_brk标识，结束地址由brk标识。       memory mapping segment(映射区):存储动态链接库等文件映射、申请大内存（malloc时调用mmap函数）       stack（栈）：使用栈空间存储函数的返回地址、参数、局部变量、返回值，从高地址向低地址增长。在创建进程时会有一个最大栈大小，Linux可以通过ulimit命令指定。   

```
##### 49、
```
  参考回答:  内存泄漏通常是由于调用了malloc/new等内存申请的操作，但是缺少了对应的free/delete。为了判断内存是否泄露，我们一方面可以使用linux环境下的内存泄漏检查工具Valgrind,另一方面我们在写代码时可以添加内存申请和释放的统计功能，统计当前申请和释放的内存是否一致，以此来判断内存是否泄露。

```
##### 50、
```
  参考回答:       段错误通常发生在访问非法内存地址的时候，具体来说分为以下几种情况：   使用野指针    试图修改字符串常量的内容 

```
##### 51、
```
  参考回答:  内存泄漏(memory leak)是指由于疏忽或错误造成了程序未能释放掉不再使用的内存的情况。内存泄漏并非指内存在物理上的消失，而是应用程序分配某段内存后，由于设计错误，失去了对该段内存的控制，因而造成了内存的浪费。   内存泄漏的分类：    1. 堆内存泄漏 （Heap leak）。对内存指的是程序运行中根据需要分配通过malloc,realloc new等从堆中分配的一块内存，再是完成后必须通过调用对应的 free或者delete 删掉。如果程序的设计的错误导致这部分内存没有被释放，那么此后这块内存将不会被使用，就会产生Heap Leak.    2. 系统资源泄露（Resource Leak）。主要指程序使用系统分配的资源比如 Bitmap,handle ,SOCKET等没有使用相应的函数释放掉，导致系统资源的浪费，严重可导致系统效能降低，系统运行不稳定。    3. 没有将基类的析构函数定义为虚函数。当基类指针指向子类对象时，如果基类的析构函数不是virtual，那么子类的析构函数将不会被调用，子类的资源没有正确是释放，因此造成内存泄露。 

```
##### 52、
```
  参考回答:       1、new分配内存按照数据类型进行分配，malloc分配内存按照指定的大小分配；   2、new返回的是指定对象的指针，而malloc返回的是void*，因此malloc的返回值一般都需要进行类型转化。    3、new不仅分配一段内存，而且会调用构造函数，malloc不会。    4、new分配的内存要用delete销毁，malloc要用free来销毁；delete销毁的时候会调用对象的析构函数，而free则不会。    5、new是一个操作符可以重载，malloc是一个库函数。    6、malloc分配的内存不够的时候，可以用realloc扩容。扩容的原理？new没用这样操作。    7、new如果分配失败了会抛出bad_malloc的异常，而malloc失败了会返回NULL。    8、申请数组时： new[]一次分配所有内存，多次调用构造函数，搭配使用delete[]，delete[]多次调用析构函数，销毁数组中的每个对象。而malloc则只能sizeof(int) * n。 

```
##### 53、
```
  参考回答:       Linux允许不同进程访问同一个逻辑内存，提供了一组API，头文件在sys/shm.h中。   1）新建共享内存shmget    int shmget(key_t key,size_t size,int shmflg);    key：共享内存键值，可以理解为共享内存的唯一性标记。    size：共享内存大小    shmflag：创建进程和其他进程的读写权限标识。    返回值：相应的共享内存标识符，失败返回-1    2）连接共享内存到当前进程的地址空间shmat    void *shmat(int shm_id,const void *shm_addr,int shmflg);    shm_id：共享内存标识符    shm_addr：指定共享内存连接到当前进程的地址，通常为0，表示由系统来选择。    shmflg：标志位    返回值：指向共享内存第一个字节的指针，失败返回-1    3）当前进程分离共享内存shmdt    int shmdt(const void *shmaddr);    4）控制共享内存shmctl    和信号量的semctl函数类似，控制共享内存    int shmctl(int shm_id,int command,struct shmid_ds *buf);    shm_id：共享内存标识符    command: 有三个值    IPC_STAT:获取共享内存的状态，把共享内存的shmid_ds结构复制到buf中。    IPC_SET:设置共享内存的状态，把buf复制到共享内存的shmid_ds结构。    IPC_RMID:删除共享内存    buf：共享内存管理结构体。 

```
##### 54、
```
  参考回答:       reactor模型要求主线程只负责监听文件描述上是否有事件发生，有的话就立即将该事件通知工作线程，除此之外，主线程不做任何其他实质性的工作，读写数据、接受新的连接以及处理客户请求均在工作线程中完成。其模型组成如下：           1）Handle：即操作系统中的句柄，是对资源在操作系统层面上的一种抽象，它可以是打开的文件、一个连接(Socket)、Timer等。由于Reactor模式一般使用在网络编程中，因而这里一般指Socket Handle，即一个网络连接。       2）Synchronous Event Demultiplexer（同步事件复用器）：阻塞等待一系列的Handle中的事件到来，如果阻塞等待返回，即表示在返回的Handle中可以不阻塞的执行返回的事件类型。这个模块一般使用操作系统的select来实现。       3）Initiation Dispatcher：用于管理Event Handler，即EventHandler的容器，用以注册、移除EventHandler等；另外，它还作为Reactor模式的入口调用Synchronous Event Demultiplexer的select方法以阻塞等待事件返回，当阻塞等待返回时，根据事件发生的Handle将其分发给对应的Event Handler处理，即回调EventHandler中的handle_event()方法。       4）Event Handler：定义事件处理方法：handle_event()，以供InitiationDispatcher回调使用。       5）Concrete Event Handler：事件EventHandler接口，实现特定事件处理逻辑。    

```
##### 55、
```
  参考回答:  在单线程模型中，可以采用I/O复用来提高单线程处理多个请求的能力，然后再采用事件驱动模型，基于异步回调来处理事件来

```
##### 56、
```
  参考回答:       可变参数模板：   C++11的可变参数模板，对参数进行了高度泛化，可以表示任意数目、任意类型的参数，其语法为：在class或typename后面带上省略号”。    例如：    Template<class ... T>    void func(T ... args)    {    cout<<”num is”<<sizeof ...(args)<<endl;    }    func();//args不含任何参数    func(1);//args包含一个int类型的实参    func(1,2.0)//args包含一个int一个double类型的实参    其中T叫做模板参数包，args叫做函数参数包    省略号作用如下：    1）声明一个包含0到任意个模板参数的参数包    2）在模板定义得右边，可以将参数包展成一个个独立的参数    C++11可以使用递归函数的方式展开参数包，获得可变参数的每个值。通过递归函数展开参数包，需要提供一个参数包展开的函数和一个递归终止函数。例如：    #include using namespace std;    // 最终递归函数    void print()    {    cout << "empty" << endl;    }    // 展开函数    template void print(T head, Args... args)    {    cout << head << ","; print(args...);    }    int main()    {    print(1, 2, 3, 4); return 0;    }    参数包Args ...在展开的过程中递归调用自己，没调用一次参数包中的参数就会少一个，直到所有参数都展开为止。当没有参数时就会调用非模板函数printf终止递归过程。    右值引用:    C++中，左值通常指可以取地址，有名字的值就是左值，而不能取地址，没有名字的就是右值。而在指C++11中，右值是由两个概念构成，将亡值和纯右值。纯右值是用于识别临时变量和一些不跟对象关联的值，比如1+3产生的临时变量值，2、true等，而将亡值通常是指具有转移语义的对象，比如返回右值引用T&&的函数返回值等。    C++11中，右值引用就是对一个右值进行引用的类型。由于右值通常不具有名字，所以我们一般只能通过右值表达式获得其引用，比如：    T && a=ReturnRvale();    假设ReturnRvalue()函数返回一个右值，那么上述语句声明了一个名为a的右值引用，其值等于ReturnRvalue函数返回的临时变量的值。    基于右值引用可以实现转移语义和完美转发新特性。    移动语义：    对于一个包含指针成员变量的类，由于编译器默认的拷贝构造函数都是浅拷贝，所有我们一般需要通过实现深拷贝的拷贝构造函数，为指针成员分配新的内存并进行内容拷贝，从而避免悬挂指针的问题。    但是如下列代码所示：            当类HasPtrMem包含一个成员函数GetTemp,其返回值类型是HasPtrMem,如果我们定义了深拷贝的拷贝构造函数，那么在调用该函数时需要调用两次拷贝构造函数。第一次是生成GetTemp函数返回时的临时变量，第二次是将该返回值赋值给main函数中的变量a。与此对应需要调用三次析构函数来释放内存。       而在上述过程中，使用临时变量构造a时会调用拷贝构造函数分配对内存，而临时对象在语句结束后会释放它所使用的堆内存。这样重复申请和释放内存，在申请内存较大时会严重影响性能。因此C++使用移动构造函数，从而保证使用临时对象构造a时不分配内存，从而提高性能。       如下列代码所示，移动构造函数接收一个右值引用作为参数，使用右值引用的参数初始化其指针成员变量。           其原理就是使用在构造对象a时，使用h.d来初始化a，然后将临时对象h的成员变量d指向nullptr，从而保证临时变量析构时不会释放对内存。           完美转发：       完美转发是指在函数模板中，完全依照模板的参数的类型，将参数传递给函数模板中调用的另一个函数，即传入转发函数的是左值对象，目标函数就能获得左值对象，转发函数是右值对象，目标函数就能获得右值对象，而不产生额外的开销。       因此转发函数和目标函数参数一般采用引用类型，从而避免拷贝的开销。其次，由于目标函数可能需要能够既接受左值引用，又接受右值引用，所以考虑转发也需要兼容这两种类型。       C++11采用引用折叠的规则，结合新的模板推导规则实现完美转发。其引用折叠规则如下：           因此，我们将转发函数和目标函数的参数都设置为右值引用类型，           当传入一个X类型的左值引用时，转发函数将被实例为：           经过引用折叠，变为：           当传入一个X类型的右值引用时，转发函数将被实例为：           经过引用折叠，变为：           除此之外，还可以使用forward()函数来完成左值引用到右值引用的转换：           Lambda表达式:       Lambda表达式定义一个匿名函数，并且可以捕获一定范围内的变量，其定义如下：       [capture](params)mutable->return-type{statement}       其中，       [capture]：捕获列表，捕获上下文变量以供lambda使用。同时[]是lambda寅初复，编译器根据该符号来判断接下来代码是否是lambda函数。       (Params)：参数列表，与普通函数的参数列表一致，如果不需要传递参数，则可以连通括号一起省略。       mutable是修饰符，默认情况下lambda函数总是一个const函数，Mutable可以取消其常量性。在使用该修饰符时，参数列表不可省略。       ->return-type:返回类型是返回值类型       {statement}:函数体，内容与普通函数一样，除了可以使用参数之外，还可以使用所捕获的变量。       Lambda表达式与普通函数最大的区别就是其可以通过捕获列表访问一些上下文中的数据。其形式如下:           Lambda的类型被定义为“闭包”的类，其通常用于STL库中，在某些场景下可用于简化仿函数的使用，同时Lambda作为局部函数，也会提高复杂代码的开发加速，轻松在函数内重用代码，无须费心设计接口。   

```
##### 57、
```
  参考回答:       基本概念：   进程是对运行时程序的封装，是系统进行资源调度和分配的的基本单位，实现了操作系统的并发；    线程是进程的子任务，是CPU调度和分派的基本单位，用于保证程序的实时性，实现进程内部的并发；线程是操作系统可识别的最小执行和调度单位。每个线程都独自占用一个虚拟处理器：独自的寄存器组，指令计数器和处理器状态。每个线程完成不同的任务，但是共享同一地址空间（也就是同样的动态内存，映射文件，目标代码等等），打开的文件队列和其他内核资源。        区别：    1.一个线程只能属于一个进程，而一个进程可以有多个线程，但至少有一个线程。线程依赖于进程而存在。    2.进程在执行过程中拥有独立的内存单元，而多个线程共享进程的内存。（资源分配给进程，同一进程的所有线程共享该进程的所有资源。同一进程中的多个线程共享代码段（代码和常量），数据段（全局变量和静态变量），扩展段（堆存储）。但是每个线程拥有自己的栈段，栈段又叫运行时段，用来存放所有局部变量和临时变量。）    3.进程是资源分配的最小单位，线程是CPU调度的最小单位；    4.系统开销： 由于在创建或撤消进程时，系统都要为之分配或回收资源，如内存空间、I／o设备等。因此，操作系统所付出的开销将显著地大于在创建或撤消线程时的开销。类似地，在进行进程切换时，涉及到整个当前进程CPU环境的保存以及新被调度运行的进程的CPU环境的设置。而线程切换只须保存和设置少量寄存器的内容，并不涉及存储器管理方面的操作。可见，进程切换的开销也远大于线程切换的开销。    5.通信：由于同一进程中的多个线程具有相同的地址空间，致使它们之间的同步和通信的实现，也变得比较容易。进程间通信IPC，线程间可以直接读写进程数据段（如全局变量）来进行通信——需要进程同步和互斥手段的辅助，以保证数据的一致性。在有的系统中，线程的切换、同步和通信都无须操作系统内核的干预    6.进程编程调试简单可靠性高，但是创建销毁开销大；线程正相反，开销小，切换速度快，但是编程调试相对复杂。    7.进程间不会相互影响 ；线程一个线程挂掉将导致整个进程挂掉    8.进程适应于多核、多机分布；线程适用于多核        进程间通信的方式：    进程间通信主要包括管道、系统IPC（包括消息队列、信号量、信号、共享内存等）、以及套接字socket。    1.管道：    管道主要包括无名管道和命名管道:管道可用于具有亲缘关系的父子进程间的通信，有名管道除了具有管道所具有的功能外，它还允许无亲缘关系进程间的通信    1.1 普通管道PIPE：    1)它是半双工的（即数据只能在一个方向上流动），具有固定的读端和写端    2)它只能用于具有亲缘关系的进程之间的通信（也是父子进程或者兄弟进程之间）    3)它可以看成是一种特殊的文件，对于它的读写也可以使用普通的read、write等函数。但是它不是普通的文件，并不属于其他任何文件系统，并且只存在于内存中。    1.2 命名管道FIFO：    1)FIFO可以在无关的进程之间交换数据    2)FIFO有路径名与之相关联，它以一种特殊设备文件形式存在于文件系统中。        2. 系统IPC：    2.1 消息队列    消息队列，是消息的链接表，存放在内核中。一个消息队列由一个标识符（即队列ID）来标记。 (消息队列克服了信号传递信息少，管道只能承载无格式字节流以及缓冲区大小受限等特点)具有写权限得进程可以按照一定得规则向消息队列中添加新信息；对消息队列有读权限得进程则可以从消息队列中读取信息；    特点：    1)消息队列是面向记录的，其中的消息具有特定的格式以及特定的优先级。    2)消息队列独立于发送与接收进程。进程终止时，消息队列及其内容并不会被删除。    3)消息队列可以实现消息的随机查询,消息不一定要以先进先出的次序读取,也可以按消息的类型读取。        2.2 信号量semaphore    信号量（semaphore）与已经介绍过的 IPC 结构不同，它是一个计数器，可以用来控制多个进程对共享资源的访问。信号量用于实现进程间的互斥与同步，而不是用于存储进程间通信数据。    特点：    1)信号量用于进程间同步，若要在进程间传递数据需要结合共享内存。    2)信号量基于操作系统的 PV 操作，程序对信号量的操作都是原子操作。    3)每次对信号量的 PV 操作不仅限于对信号量值加 1 或减 1，而且可以加减任意正整数。    4)支持信号量组。        2.3 信号signal    信号是一种比较复杂的通信方式，用于通知接收进程某个事件已经发生。        2.4 共享内存（Shared Memory）    它使得多个进程可以访问同一块内存空间，不同进程可以及时看到对方进程中对共享内存中数据得更新。这种方式需要依靠某种同步操作，如互斥锁和信号量等    特点：    1)共享内存是最快的一种IPC，因为进程是直接对内存进行存取    2)因为多个进程可以同时操作，所以需要进行同步    3)信号量+共享内存通常结合在一起使用，信号量用来同步对共享内存的访问        3.套接字SOCKET：    socket也是一种进程间通信机制，与其他通信机制不同的是，它可用于不同主机之间的进程通信。        线程间通信的方式:    临界区：通过多线程的串行化来访问公共资源或一段代码，速度快，适合控制数据访问；    互斥量Synchronized/Lock：采用互斥对象机制，只有拥有互斥对象的线程才有访问公共资源的权限。因为互斥对象只有一个，所以可以保证公共资源不会被多个线程同时访问    信号量Semphare：为控制具有有限数量的用户资源而设计的，它允许多个线程在同一时刻去访问同一个资源，但一般需要限制同一时刻访问此资源的最大线程数目。    事件(信号)，Wait/Notify：通过通知操作的方式来保持多线程同步，还可以方便的实现多线程优先级的比较操作 

```
##### 58、
```
  参考回答:       为了防止不同进程同一时刻在物理内存中运行而对物理内存的争夺和践踏，采用了虚拟内存。   虚拟内存技术使得不同进程在运行过程中，它所看到的是自己独自占有了当前系统的4G内存。所有进程共享同一物理内存，每个进程只把自己目前需要的虚拟内存空间映射并存储到物理内存上。 事实上，在每个进程创建加载时，内核只是为进程“创建”了虚拟内存的布局，具体就是初始化进程控制表中内存相关的链表，实际上并不立即就把虚拟内存对应位置的程序数据和代码（比如.text .data段）拷贝到物理内存中，只是建立好虚拟内存和磁盘文件之间的映射就好（叫做存储器映射），等到运行到对应的程序时，才会通过缺页异常，来拷贝数据。还有进程运行过程中，要动态分配内存，比如malloc时，也只是分配了虚拟内存，即为这块虚拟内存对应的页表项做相应设置，当进程真正访问到此数据时，才引发缺页异常。    请求分页系统、请求分段系统和请求段页式系统都是针对虚拟内存的，通过请求实现内存与外存的信息置换。        虚拟内存的好处：    1.扩大地址空间；    2.内存保护：每个进程运行在各自的虚拟内存地址空间，互相不能干扰对方。虚存还对特定的内存地址提供写保护，可以防止代码或数据被恶意篡改。    3.公平内存分配。采用了虚存之后，每个进程都相当于有同样大小的虚存空间。    4.当进程通信时，可采用虚存共享的方式实现。    5.当不同的进程使用同样的代码时，比如库文件中的代码，物理内存中可以只存储一份这样的代码，不同的进程只需要把自己的虚拟内存映射过去就可以了，节省内存    6.虚拟内存很适合在多道程序设计系统中使用，许多程序的片段同时保存在内存中。当一个程序等待它的一部分读入内存时，可以把CPU交给另一个进程使用。在内存中可以保留多个进程，系统并发度提高    7.在程序需要分配连续的内存空间的时候，只需要在虚拟内存空间分配连续空间，而不需要实际物理内存的连续空间，可以利用碎片        虚拟内存的代价：    1.虚存的管理需要建立很多数据结构，这些数据结构要占用额外的内存    2.虚拟地址到物理地址的转换，增加了指令的执行时间。    3.页面的换入换出需要磁盘I/O，这是很耗时的    4.如果一页中只有一部分数据，会浪费内存。 

```
##### 59、
```
     参考回答:           一个程序本质上都是由BSS段、data段、text段三个组成的。可以看到一个可执行程序在存储（没有调入内存）时分为代码段、数据区和未初始化数据区三部分。       BSS段（未初始化数据区）：通常用来存放程序中未初始化的全局变量和静态变量的一块内存区域。BSS段属于静态分配，程序结束后静态变量资源由系统自动释放。       数据段：存放程序中已初始化的全局变量的一块内存区域。数据段也属于静态内存分配       代码段：存放程序执行代码的一块内存区域。这部分区域的大小在程序运行前就已经确定，并且内存区域属于只读。在代码段中，也有可能包含一些只读的常数变量       text段和data段在编译时已经分配了空间，而BSS段并不占用可执行文件的大小，它是由链接器来获取内存的。       bss段（未进行初始化的数据）的内容并不存放在磁盘上的程序文件中。其原因是内核在程序开始运行前将它们设置为0。需要存放在程序文件中的只有正文段和初始化数据段。       data段（已经初始化的数据）则为数据分配空间，数据保存到目标文件中。       数据段包含经过初始化的全局变量以及它们的值。BSS段的大小从可执行文件中得到，然后链接器得到这个大小的内存块，紧跟在数据段的后面。当这个内存进入程序的地址空间后全部清零。包含数据段和BSS段的整个区段此时通常称为数据区。       可执行程序在运行时又多出两个区域：栈区和堆区。       栈区：由编译器自动释放，存放函数的参数值、局部变量等。每当一个函数被调用时，该函数的返回类型和一些调用的信息被存放到栈中。然后这个被调用的函数再为他的自动变量和临时变量在栈上分配空间。每调用一个函数一个新的栈就会被使用。栈区是从高地址位向低地址位增长的，是一块连续的内存区域，最大容量是由系统预先定义好的，申请的栈空间超过这个界限时会提示溢出，用户能从栈中获取的空间较小。       堆区：用于动态分配内存，位于BSS和栈中间的地址区域。由程序员申请分配和释放。堆是从低地址位向高地址位增长，采用链式存储结构。频繁的malloc/free造成内存空间的不连续，产生碎片。当申请堆空间时库函数是按照一定的算法搜索可用的足够大的空间。因此堆的效率比栈要低的多。   

```
##### 60、
```
  参考回答:       malloc()和mmap()等内存分配函数，在分配时只是建立了进程虚拟地址空间，并没有分配虚拟内存对应的物理内存。当进程访问这些没有建立映射关系的虚拟内存时，处理器自动触发一个缺页异常。   缺页中断：在请求分页系统中，可以通过查询页表中的状态位来确定所要访问的页面是否存在于内存中。每当所要访问的页面不在内存是，会产生一次缺页中断，此时操作系统会根据页表中的外存地址在外存中找到所缺的一页，将其调入内存。    缺页本身是一种中断，与一般的中断一样，需要经过4个处理步骤：    1、保护CPU现场    2、分析中断原因    3、转入缺页中断处理程序进行处理    4、恢复CPU现场，继续执行    但是缺页中断是由于所要访问的页面不存在于内存时，由硬件所产生的一种特殊的中断，因此，与一般的中断存在区别：    1、在指令执行期间产生和处理缺页中断信号    2、一条指令在执行期间，可能产生多次缺页中断    3、缺页中断返回是，执行产生中断的一条指令，而一般的中断返回是，执行下一条指令。 

```
##### 61、
```
  参考回答:       fork的基础知识：   fork:创建一个和当前进程映像一样的进程可以通过fork( )系统调用：    #include <sys/types.h>    #include <unistd.h>    pid_t fork(void);    成功调用fork( )会创建一个新的进程，它几乎与调用fork( )的进程一模一样，这两个进程都会继续运行。在子进程中，成功的fork( )调用会返回0。在父进程中fork( )返回子进程的pid。如果出现错误，fork( )返回一个负值。    最常见的fork( )用法是创建一个新的进程，然后使用exec( )载入二进制映像，替换当前进程的映像。这种情况下，派生（fork）了新的进程，而这个子进程会执行一个新的二进制可执行文件的映像。这种“派生加执行”的方式是很常见的。    在早期的Unix系统中，创建进程比较原始。当调用fork时，内核会把所有的内部数据结构复制一份，复制进程的页表项，然后把父进程的地址空间中的内容逐页的复制到子进程的地址空间中。但从内核角度来说，逐页的复制方式是十分耗时的。现代的Unix系统采取了更多的优化，例如Linux，采用了写时复制的方法，而不是对父进程空间进程整体复制。        vfork的基础知识：    在实现写时复制之前，Unix的设计者们就一直很关注在fork后立刻执行exec所造成的地址空间的浪费。BSD的开发者们在3.0的BSD系统中引入了vfork( )系统调用。    #include <sys/types.h>    #include <unistd.h>    pid_t vfork(void);    除了子进程必须要立刻执行一次对exec的系统调用，或者调用_exit( )退出，对vfork( )的成功调用所产生的结果和fork( )是一样的。vfork( )会挂起父进程直到子进程终止或者运行了一个新的可执行文件的映像。通过这样的方式，vfork( )避免了地址空间的按页复制。在这个过程中，父进程和子进程共享相同的地址空间和页表项。实际上vfork( )只完成了一件事：复制内部的内核数据结构。因此，子进程也就不能修改地址空间中的任何内存。    vfork( )是一个历史遗留产物，Linux本不应该实现它。需要注意的是，即使增加了写时复制，vfork( )也要比fork( )快，因为它没有进行页表项的复制。然而，写时复制的出现减少了对于替换fork( )争论。实际上，直到2.2.0内核，vfork( )只是一个封装过的fork( )。因为对vfork( )的需求要小于fork( )，所以vfork( )的这种实现方式是可行的。        补充知识点：写时复制    Linux采用了写时复制的方法，以减少fork时对父进程空间进程整体复制带来的开销。    写时复制是一种采取了惰性优化方法来避免复制时的系统开销。它的前提很简单：如果有多个进程要读取它们自己的那部门资源的副本，那么复制是不必要的。每个进程只要保存一个指向这个资源的指针就可以了。只要没有进程要去修改自己的“副本”，就存在着这样的幻觉：每个进程好像独占那个资源。从而就避免了复制带来的负担。如果一个进程要修改自己的那份资源“副本”，那么就会复制那份资源，并把复制的那份提供给进程。不过其中的复制对进程来说是透明的。这个进程就可以修改复制后的资源了，同时其他的进程仍然共享那份没有修改过的资源。所以这就是名称的由来：在写入时进行复制。    写时复制的主要好处在于：如果进程从来就不需要修改资源，则不需要进行复制。惰性算法的好处就在于它们尽量推迟代价高昂的操作，直到必要的时刻才会去执行。    在使用虚拟内存的情况下，写时复制（Copy-On-Write）是以页为基础进行的。所以，只要进程不修改它全部的地址空间，那么就不必复制整个地址空间。在fork( )调用结束后，父进程和子进程都相信它们有一个自己的地址空间，但实际上它们共享父进程的原始页，接下来这些页又可以被其他的父进程或子进程共享。    写时复制在内核中的实现非常简单。与内核页相关的数据结构可以被标记为只读和写时复制。如果有进程试图修改一个页，就会产生一个缺页中断。内核处理缺页中断的方式就是对该页进行一次透明复制。这时会清除页面的COW属性，表示着它不再被共享。    现代的计算机系统结构中都在内存管理单元（MMU）提供了硬件级别的写时复制支持，所以实现是很容易的。    在调用fork( )时，写时复制是有很大优势的。因为大量的fork之后都会跟着执行exec，那么复制整个父进程地址空间中的内容到子进程的地址空间完全是在浪费时间：如果子进程立刻执行一个新的二进制可执行文件的映像，它先前的地址空间就会被交换出去。写时复制可以对这种情况进行优化。        fork和vfork的区别：    1. fork( )的子进程拷贝父进程的数据段和代码段；vfork( )的子进程与父进程共享数据段    2. fork( )的父子进程的执行次序不确定；vfork( )保证子进程先运行，在调用exec或exit之前与父进程数据是共享的，在它调用exec或exit之后父进程才可能被调度运行。    3. vfork( )保证子进程先运行，在它调用exec或exit之后父进程才可能被调度运行。如果在调用这两个函数之前子进程依赖于父进程的进一步动作，则会导致死锁。    4.当需要改变共享数据段中变量的值，则拷贝父进程。 

```
##### 62、
```
  参考回答:       linux默认最大文件句柄数是1024个，在linux服务器文件并发量比较大的情况下，系统会报"too many open files"的错误。故在linux服务器高并发调优时，往往需要预先调优Linux参数，修改Linux最大文件句柄数。   有两种方法：    1. ulimit -n <可以同时打开的文件数>，将当前进程的最大句柄数修改为指定的参数（注：该方法只针对当前进程有效，重新打开一个shell或者重新开启一个进程，参数还是之前的值）    首先用ulimit -a查询Linux相关的参数，如下所示：    core file size          (blocks, -c) 0    data seg size           (kbytes, -d) unlimited    scheduling priority             (-e) 0    file size               (blocks, -f) unlimited    pending signals                 (-i) 94739    max locked memory       (kbytes, -l) 64    max memory size         (kbytes, -m) unlimited    open files                      (-n) 1024    pipe size            (512 bytes, -p) 8    POSIX message queues     (bytes, -q) 819200    real-time priority              (-r) 0    stack size              (kbytes, -s) 8192    cpu time               (seconds, -t) unlimited    max user processes              (-u) 94739    virtual memory          (kbytes, -v) unlimited    file locks                      (-x) unlimited    其中，open files就是最大文件句柄数，默认是1024个。    修改Linux最大文件句柄数：  ulimit -n 2048， 将最大句柄数修改为 2048个。        2. 对所有进程都有效的方法，修改Linux系统参数    vi /etc/security/limits.conf 添加    *　　soft　　nofile　　65536    *　　hard　　nofile　　65536    将最大句柄数改为65536    修改以后保存，注销当前用户，重新登录，修改后的参数就生效了 

```
##### 63、
```
  参考回答:       并发（concurrency）：指宏观上看起来两个程序在同时运行，比如说在单核cpu上的多任务。但是从微观上看两个程序的指令是交织着运行的，你的指令之间穿插着我的指令，我的指令之间穿插着你的，在单个周期内只运行了一个指令。这种并发并不能提高计算机的性能，只能提高效率。   并行（parallelism）：指严格物理意义上的同时运行，比如多核cpu，两个程序分别运行在两个核上，两者之间互不影响，单个周期内每个程序都运行了自己的指令，也就是运行了两条指令。这样说来并行的确提高了计算机的效率。所以现在的cpu都是往多核方面发展。 

```
##### 64、
```
  参考回答:       查看端口号：   使用命令show global variables like 'port';查看端口号 ，mysql的默认端口是3306。（补充：sqlserver默认端口号为：1433；oracle默认端口号为：1521；DB2默认端口号为：5000；PostgreSQL默认端口号为：5432）    修改端口号：    修改端口号：编辑/etc/my.cnf文件，早期版本有可能是my.conf文件名，增加端口参数，并且设定端口，注意该端口未被使用，保存退出。 

```
##### 65、
```
  参考回答:    页式内存管理，内存分成固定长度的一个个页片。操作系统为每一个进程维护了一个从虚拟地址到物理地址的映射关系的数据结构，叫页表，页表的内容就是该进程的虚拟地址到物理地址的一个映射。页表中的每一项都记录了这个页的基地址。通过页表，由逻辑地址的高位部分先找到逻辑地址对应的页基地址，再由页基地址偏移一定长度就得到最后的物理地址，偏移的长度由逻辑地址的低位部分决定。一般情况下，这个过程都可以由硬件完成，所以效率还是比较高的。页式内存管理的优点就是比较灵活，内存管理以较小的页为单位，方便内存换入换出和扩充地址空间。        Linux最初的两级页表机制：    两级分页机制将32位的虚拟空间分成三段，低十二位表示页内偏移，高20分成两段分别表示两级页表的偏移。    * PGD(Page Global Directory): 最高10位，全局页目录表索引    * PTE(Page Table Entry)：中间10位，页表入口索引    当在进行地址转换时，结合在CR3寄存器中存放的页目录(page directory, PGD)的这一页的物理地址，再加上从虚拟地址中抽出高10位叫做页目录表项(内核也称这为pgd)的部分作为偏移, 即定位到可以描述该地址的pgd；从该pgd中可以获取可以描述该地址的页表的物理地址，再加上从虚拟地址中抽取中间10位作为偏移, 即定位到可以描述该地址的pte；在这个pte中即可获取该地址对应的页的物理地址, 加上从虚拟地址中抽取的最后12位，即形成该页的页内偏移, 即可最终完成从虚拟地址到物理地址的转换。从上述过程中，可以看出，对虚拟地址的分级解析过程，实际上就是不断深入页表层次，逐渐定位到最终地址的过程，所以这一过程被叫做page talbe walk。        Linux的三级页表机制：    当X86引入物理地址扩展(Pisycal Addrress Extension, PAE)后，可以支持大于4G的物理内存(36位），但虚拟地址依然是32位，原先的页表项不适用，它实际多4 bytes被扩充到8 bytes，这意味着，每一页现在能存放的pte数目从1024变成512了(4k/8)。相应地，页表层级发生了变化，Linus新增加了一个层级，叫做页中间目录(page middle directory, PMD), 变成：    字段            描述                        位数    cr3            指向一个PDPT            crs寄存器存储    PGD        指向PDPT中4个项中的一个    位31~30    PMD        指向页目录中512项中的一个    位29~21    PTE            指向页表中512项中的一个    位20~12    page offset    4KB页中的偏移            位11~0        现在就同时存在2级页表和3级页表，在代码管理上肯定不方便。巧妙的是，Linux采取了一种抽象方法：所有架构全部使用3级页表: 即PGD -> PMD -> PTE。那只使用2级页表(如非PAE的X86)怎么办？    办法是针对使用2级页表的架构，把PMD抽象掉，即虚设一个PMD表项。这样在page table walk过程中，PGD本直接指向PTE的，现在不了，指向一个虚拟的PMD，然后再由PMD指向PTE。这种抽象保持了代码结构的统一。        Linux的四级页表机制：    硬件在发展，3级页表很快又捉襟见肘了，原因是64位CPU出现了, 比如X86_64， 它的硬件是实实在在支持4级页表的。它支持48位的虚拟地址空间1。如下：    字段            描述                        位数    PML4        指向一个PDPT            位47~39    PGD        指向PDPT中4个项中的一个    位38~30    PMD        指向页目录中512项中的一个    位29~21    PTE            指向页表中512项中的一个    位20~12    page offset    4KB页中的偏移            位11~0        Linux内核针为使用原来的3级列表(PGD->PMD->PTE)，做了折衷。即采用一个唯一的，共享的顶级层次，叫PML4。这个PML4没有编码在地址中，这样就能套用原来的3级列表方案了。不过代价就是，由于只有唯一的PML4, 寻址空间被局限在(239=)512G, 而本来PML4段有9位, 可以支持512个PML4表项的。现在为了使用3级列表方案，只能限制使用一个， 512G的空间很快就又不够用了，解决方案呼之欲出。    在2004年10月，当时的X86_64架构代码的维护者Andi Kleen提交了一个叫做4level page tables for Linux的PATCH系列，为Linux内核带来了4级页表的支持。在他的解决方案中，不出意料地，按照X86_64规范，新增了一个PML4的层级, 在这种解决方案中，X86_64拥一个有512条目的PML4, 512条目的PGD, 512条目的PMD, 512条目的PTE。对于仍使用3级目录的架构来说，它们依然拥有一个虚拟的PML4,相关的代码会在编译时被优化掉。 这样，就把Linux内核的3级列表扩充为4级列表。这系列PATCH工作得不错，不久被纳入Andrew Morton的-mm树接受测试。不出意外的话，它将在v2.6.11版本中释出。但是，另一个知名开发者Nick Piggin提出了一些看法，他认为Andi的Patch很不错，不过他认为最好还是把PGD作为第一级目录，把新增加的层次放在中间，并给出了他自己的Patch:alternate 4-level page tables patches。Andi更想保持自己的PATCH, 他认为Nick不过是玩了改名的游戏，而且他的PATCH经过测试很稳定，快被合并到主线了，不宜再折腾。不过Linus却表达了对Nick Piggin的支持，理由是Nick的做法conceptually least intrusive。毕竟作为Linux的扛把子，稳定对于Linus来说意义重大。最终，不意外地，最后Nick Piggin的PATCH在v2.6.11版本中被合并入主线。在这种方案中，4级页表分别是：PGD -> PUD -> PMD -> PTE。 

```
##### 66、
```
  参考回答:       线程产生的原因：   进程可以使多个程序能并发执行，以提高资源的利用率和系统的吞吐量；但是其具有一些缺点：    进程在同一时间只能干一件事    进程在执行的过程中如果阻塞，整个进程就会挂起，即使进程中有些工作不依赖于等待的资源，仍然不会执行。        因此，操作系统引入了比进程粒度更小的线程，作为并发执行的基本单位，从而减少程序在并发执行时所付出的时空开销，提高并发性。和进程相比，线程的优势如下：    从资源上来讲，线程是一种非常"节俭"的多任务操作方式。在linux系统下，启动一个新的进程必须分配给它独立的地址空间，建立众多的数据表来维护它的代码段、堆栈段和数据段，这是一种"昂贵"的多任务工作方式。    从切换效率上来讲，运行于一个进程中的多个线程，它们之间使用相同的地址空间，而且线程间彼此切换所需时间也远远小于进程间切换所需要的时间。据统计，一个进程的开销大约是一个线程开销的30倍左右。（    从通信机制上来讲，线程间方便的通信机制。对不同进程来说，它们具有独立的数据空间，要进行数据的传递只能通过进程间通信的方式进行，这种方式不仅费时，而且很不方便。线程则不然，由于同一进城下的线程之间贡献数据空间，所以一个线程的数据可以直接为其他线程所用，这不仅快捷，而且方便。    除以上优点外，多线程程序作为一种多任务、并发的工作方式，还有如下优点：    1、使多CPU系统更加有效。操作系统会保证当线程数不大于CPU数目时，不同的线程运行于不同的CPU上。    2、改善程序结构。一个既长又复杂的进程可以考虑分为多个线程，成为几个独立或半独立的运行部分，这样的程序才会利于理解和修改。 

```
##### 67、
```
  参考回答:       在单核机器上写多线程程序，仍然需要线程锁。因为线程锁通常用来实现线程的同步和通信。在单核机器上的多线程程序，仍然存在线程同步的问题。因为在抢占式操作系统中，通常为每个线程分配一个时间片，当某个线程时间片耗尽时，操作系统会将其挂起，然后运行另一个线程。如果这两个线程共享某些数据，不使用线程锁的前提下，可能会导致共享数据修改引起冲突。

```
##### 68、
```
  参考回答:       线程在切换的过程中需要保存当前线程Id、线程状态、堆栈、寄存器状态等信息。其中寄存器主要包括SP PC EAX等寄存器，其主要功能如下：   SP:堆栈指针，指向当前栈的栈顶地址    PC:程序计数器，存储下一条将要执行的指令    EAX:累加寄存器，用于加法乘法的缺省寄存器 

```
##### 69、
```
  参考回答:       信号量   信号量是一种特殊的变量，可用于线程同步。它只取自然数值，并且只支持两种操作：    P(SV):如果信号量SV大于0，将它减一；如果SV值为0，则挂起该线程。    V(SV)：如果有其他进程因为等待SV而挂起，则唤醒，然后将SV+1；否则直接将SV+1。    其系统调用为：    sem_wait（sem_t *sem）：以原子操作的方式将信号量减1，如果信号量值为0，则sem_wait将被阻塞，直到这个信号量具有非0值。    sem_post（sem_t *sem)：以原子操作将信号量值+1。当信号量大于0时，其他正在调用sem_wait等待信号量的线程将被唤醒。        互斥量    互斥量又称互斥锁，主要用于线程互斥，不能保证按序访问，可以和条件锁一起实现同步。当进入临界区      时，需要获得互斥锁并且加锁；当离开临界区时，需要对互斥锁解锁，以唤醒其他等待该互斥锁的线程。其主要的系统调用如下：    pthread_mutex_init:初始化互斥锁    pthread_mutex_destroy：销毁互斥锁    pthread_mutex_lock：以原子操作的方式给一个互斥锁加锁，如果目标互斥锁已经被上锁，pthread_mutex_lock调用将阻塞，直到该互斥锁的占有者将其解锁。    pthread_mutex_unlock:以一个原子操作的方式给一个互斥锁解锁。        条件变量    条件变量，又称条件锁，用于在线程之间同步共享数据的值。条件变量提供一种线程间通信机制：当某个共享数据达到某个值时，唤醒等待这个共享数据的一个/多个线程。即，当某个共享变量等于某个值时，调用 signal/broadcast。此时操作共享变量时需要加锁。其主要的系统调用如下：    pthread_cond_init:初始化条件变量    pthread_cond_destroy：销毁条件变量    pthread_cond_signal：唤醒一个等待目标条件变量的线程。哪个线程被唤醒取决于调度策略和优先级。    pthread_cond_wait：等待目标条件变量。需要一个加锁的互斥锁确保操作的原子性。该函数中在进入wait状态前首先进行解锁，然后接收到信号后会再加锁，保证该线程对共享资源正确访问。 

```
##### 70、
```
       参考回答:  进程是资源分配的最小单位，而线程时CPU调度的最小单位。多线程之间共享同一个进程的地址空间，线程间通信简单，同步复杂，线程创建、销毁和切换简单，速度快，占用内存少，适用于多核分布式系统，但是线程间会相互影响，一个线程意外终止会导致同一个进程的其他线程也终止，程序可靠性弱。而多进程间拥有各自独立的运行地址空间，进程间不会相互影响，程序可靠性强，但是进程创建、销毁和切换复杂，速度慢，占用内存多，进程间通信复杂，但是同步简单，适用于多核、多机分布。

```
##### 71、
```
  参考回答:       1）进程是cpu资源分配的最小单位，线程是cpu调度的最小单位。   2）进程有独立的系统资源，而同一进程内的线程共享进程的大部分系统资源,包括堆、代码段、数据段，每个线程只拥有一些在运行中必不可少的私有属性，比如tcb,线程Id,栈、寄存器。    3）一个进程崩溃，不会对其他进程产生影响；而一个线程崩溃，会让同一进程内的其他线程也死掉。    4）进程在创建、切换和销毁时开销比较大，而线程比较小。进程创建的时候需要分配系统资源，而销毁的的时候需要释放系统资源。进程切换需要分两步：切换页目录、刷新TLB以使用新的地址空间；切换内核栈和硬件上下文（寄存器）；而同一进程的线程间逻辑地址空间是一样的，不需要切换页目录、刷新TLB。    5）进程间通信比较复杂，而同一进程的线程由于共享代码段和数据段，所以通信比较容易。 

```
##### 72、
```
  参考回答:       游戏服务器应该为每个用户开辟一个进程。因为同一进程间的线程会相互影响，一个线程死掉会影响其他线程，从而导致进程崩溃。因此为了保证不同用户之间不会相互影响，应该为每个用户开辟一个进程

```
##### 73、
```
  参考回答:       当访问一个内存中不存在的页，并且内存已满，则需要从内存中调出一个页或将数据送至磁盘对换区，替换一个页，这种现象叫做缺页置换。当前操作系统最常采用的缺页置换算法如下：   先进先出(FIFO)算法：置换最先调入内存的页面，即置换在内存中驻留时间最久的页面。按照进入内存的先后次序排列成队列，从队尾进入，从队首删除。    最近最少使用（LRU）算法: 置换最近一段时间以来最长时间未访问过的页面。根据程序局部性原理，刚被访问的页面，可能马上又要被访问；而较长时间内没有被访问的页面，可能最近不会被访问。    当前最常采用的就是LRU算法。 

```
##### 74、
```
  参考回答:       1）进程是cpu资源分配的最小单位，线程是cpu调度的最小单位。   2）进程有独立的系统资源，而同一进程内的线程共享进程的大部分系统资源,包括堆、代码段、数据段，每个线程只拥有一些在运行中必不可少的私有属性，比如tcb,线程Id,栈、寄存器。    3）一个进程崩溃，不会对其他进程产生影响；而一个线程崩溃，会让同一进程内的其他线程也死掉。    4）进程在创建、切换和销毁时开销比较大，而线程比较小。进程创建的时候需要分配系统资源，而销毁的的时候需要释放系统资源。进程切换需要分两步：切换页目录、刷新TLB以使用新的地址空间；切换内核栈和硬件上下文（寄存器）；而同一进程的线程间逻辑地址空间是一样的，不需要切换页目录、刷新TLB。    5）进程间通信比较复杂，而同一进程的线程由于共享代码段和数据段，所以通信比较容易。 

```
##### 75、
```
  参考回答:       多进程模型的优势是CPU   多线程模型主要优势为线程间切换代价较小，因此适用于I/O密集型的工作场景，因此I/O密集型的工作场景经常会由于I/O阻塞导致频繁的切换线程。同时，多线程模型也适用于单机多核分布式场景。        多进程模型，适用于CPU密集型。同时，多进程模型也适用于多机分布式场景中，易于多机扩展。 

```
##### 76、
```
  参考回答:       死锁是指两个或两个以上进程在执行过程中，因争夺资源而造成的下相互等待的现象。死锁发生的四个必要条件如下：   互斥条件：进程对所分配到的资源不允许其他进程访问，若其他进程访问该资源，只能等待，直至占有该资源的进程使用完成后释放该资源；    请求和保持条件：进程获得一定的资源后，又对其他资源发出请求，但是该资源可能被其他进程占有，此时请求阻塞，但该进程不会释放自己已经占有的资源    不可剥夺条件：进程已获得的资源，在未完成使用之前，不可被剥夺，只能在使用后自己释放    环路等待条件：进程发生死锁后，必然存在一个进程-资源之间的环形链    解决死锁的方法即破坏上述四个条件之一，主要方法如下：    资源一次性分配，从而剥夺请求和保持条件    可剥夺资源：即当进程新的资源未得到满足时，释放已占有的资源，从而破坏不可剥夺的条件    资源有序分配法：系统给每类资源赋予一个序号，每个进程按编号递增的请求资源，释放则相反，从而破坏环路等待的条件 

```
##### 77、
```
  参考回答:       1、概念：   物理地址(physical address)    用于内存芯片级的单元寻址，与处理器和CPU连接的地址总线相对应。        虽然可以直接把物理地址理解成插在机器上那根内存本身，把内存看成一个从0字节一直到最大空量逐字节的编号的大数组，然后把这个数组叫做物理地址，但是事实上，这只是一个硬件提供给软件的抽像，内存的寻址方式并不是这样。所以，说它是“与地址总线相对应”，是更贴切一些，不过抛开对物理内存寻址方式的考虑，直接把物理地址与物理的内存一一对应，也是可以接受的。也许错误的理解更利于形而上的抽像。        虚拟地址(virtual memory)    这是对整个内存（不要与机器上插那条对上号）的抽像描述。它是相对于物理内存来讲的，可以直接理解成“不直实的”，“假的”内存，例如，一个0x08000000内存地址，它并不对就物理地址上那个大数组中0x08000000 - 1那个地址元素；        之所以是这样，是因为现代操作系统都提供了一种内存管理的抽像，即虚拟内存（virtual memory）。进程使用虚拟内存中的地址，由操作系统协助相关硬件，把它“转换”成真正的物理地址。这个“转换”，是所有问题讨论的关键。        有了这样的抽像，一个程序，就可以使用比真实物理地址大得多的地址空间。甚至多个进程可以使用相同的地址。不奇怪，因为转换后的物理地址并非相同的。        ——可以把连接后的程序反编译看一下，发现连接器已经为程序分配了一个地址，例如，要调用某个函数A，代码不是call A，而是call 0x0811111111 ，也就是说，函数A的地址已经被定下来了。没有这样的“转换”，没有虚拟地址的概念，这样做是根本行不通的。        2、地址转换    第一步：CPU段式管理中——逻辑地址转线性地址    CPU要利用其段式内存管理单元，先将为个逻辑地址转换成一个线程地址。    一个逻辑地址由两部份组成，【段标识符：段内偏移量】。    段标识符是由一个16位长的字段组成，称为段选择符。其中前13位是一个索引号。后面3位包含一些硬件细节，如图：            通过段标识符中的索引号从GDT或者LDT找到该段的段描述符，段描述符中的base字段是段的起始地址              段描述符：Base字段，它描述了一个段的开始位置的线性地址。              一些全局的段描述符，就放在“全局段描述符表(GDT)”中，一些局部的，例如每个进程自己的，就放在所谓的“局部段描述符表(LDT)”中。              GDT在内存中的地址和大小存放在CPU的gdtr控制寄存器中，而LDT则在ldtr寄存器中。       段起始地址+ 段内偏移量 = 线性地址           首先，给定一个完整的逻辑地址[段选择符：段内偏移地址]，       1、看段选择符的T1=0还是1，知道当前要转换是GDT中的段，还是LDT中的段，再根据相应寄存器，得到其地址和大小。我们就有了一个数组了。       2、拿出段选择符中前13位，可以在这个数组中，查找到对应的段描述符，这样，它了Base，即基地址就知道了。       3、把Base + offset，就是要转换的线性地址了。           第一步：页式管理——线性地址转物理地址              再利用其页式内存管理单元，转换为最终物理地址。              linux假的段式管理              Intel要求两次转换，这样虽说是兼容了，但是却是很冗余，但是这是intel硬件的要求。              其它某些硬件平台，没有二次转换的概念，Linux也需要提供一个高层抽像，来提供一个统一的界面。              所以，Linux的段式管理，事实上只是“哄骗”了一下硬件而已。              按照Intel的本意，全局的用GDT，每个进程自己的用LDT——不过Linux则对所有的进程都使用了相同的段来对指令和数据寻址。即用户数据段，用户代码段，对应的，内核中的是内核数据段和内核代码段。              在Linux下，逻辑地址与线性地址总是一致的，即逻辑地址的偏移量字段的值与线性地址的值总是相同的。              linux页式管理              CPU的页式内存管理单元，负责把一个线性地址，最终翻译为一个物理地址。              线性地址被分为以固定长度为单位的组，称为页(page)，例如一个32位的机器，线性地址最大可为4G，可以用4KB为一个页来划分，这页，整个线性地址就被划分为一个tatol_page[2^20]的大数组，共有2的20个次方个页。              另一类“页”，我们称之为物理页，或者是页框、页桢的。是分页单元把所有的物理内存也划分为固定长度的管理单位，它的长度一般与内存页是一一对应的。           每个进程都有自己的页目录，当进程处于运行态的时候，其页目录地址存放在cr3寄存器中。              每一个32位的线性地址被划分为三部份，【页目录索引(10位)：页表索引(10位)：页内偏移(12位)】              依据以下步骤进行转换：       从cr3中取出进程的页目录地址（操作系统负责在调度进程的时候，把这个地址装入对应寄存器）；              根据线性地址前十位，在数组中，找到对应的索引项，因为引入了二级管理模式，页目录中的项，不再是页的地址，而是一个页表的地址。（又引入了一个数组），页的地址被放到页表中去了。              根据线性地址的中间十位，在页表（也是数组）中找到页的起始地址；              将页的起始地址与线性地址中最后12位相加。              目的：              内存节约：如果一级页表中的一个页表条目为空，那么那所指的二级页表就根本不会存在。这表现出一种巨大的潜在节约，因为对于一个典型的程序，4GB虚拟地址空间的大部份都会是未分配的；           32位，PGD = 10bit，PUD = PMD = 0，table = 10bit，offset = 12bit       64位，PUD和PMD ≠ 0   

```
##### 78、
```
  参考回答:       1、原因：   1）平台原因（移植原因）：不是所有的硬件平台都能访问任意地址上的任意数据的；某些硬件平台只能在某些地址处取某些特定类型的数据，否则抛出硬件异常。    2）性能原因：数据结构（尤其是栈）应该尽可能地在自然边界上对齐。原因在于，为了访问未对齐的内存，处理器需要作两次内存访问；而对齐的内存访问仅需要一次访问。    2、规则    1）数据成员对齐规则：结构(struct)(或联合(union))的数据成员，第一个数据成员放在offset为0的地方，以后每个数据成员的对齐按照#pragma pack指定的数值和这个数据成员自身长度中，比较小的那个进行。    2）结构(或联合)的整体对齐规则：在数据成员完成各自对齐之后，结构(或联合)本身也要进行对齐，对齐将按照#pragma pack指定的数值和结构(或联合)最大数据成员长度中，比较小的那个进行。    3）结构体作为成员：如果一个结构里有某些结构体成员，则结构体成员要从其内部最大元素大小的整数倍地址开始存储。    3、定义结构体对齐    可以通过预编译命令#pragma pack(n)，n=1,2,4,8,16来改变这一系数，其中的n就是指定的“对齐系数”。    4、举例    #pragma pack(2)    struct AA {    int a;       //长度4 > 2 按2对齐；偏移量为0；存放位置区间[0,3]    char b;  //长度1 < 2 按1对齐；偏移量为4；存放位置区间[4]    short c;     //长度2 = 2 按2对齐；偏移量要提升到2的倍数6；存放位置区间[6,7]    char d;  //长度1 < 2 按1对齐；偏移量为7；存放位置区间[8]；共九个字节    };    #pragma pack() 

```
##### 79、
```
  参考回答:       进程间通信主要包括管道、系统IPC（包括消息队列、信号量、信号、共享内存等）、以及套接字socket。   1.管道：    管道主要包括无名管道和命名管道:管道可用于具有亲缘关系的父子进程间的通信，有名管道除了具有管道所具有的功能外，它还允许无亲缘关系进程间的通信    1.1 普通管道PIPE：    1）它是半双工的（即数据只能在一个方向上流动），具有固定的读端和写端    2）它只能用于具有亲缘关系的进程之间的通信（也是父子进程或者兄弟进程之间）    3）它可以看成是一种特殊的文件，对于它的读写也可以使用普通的read、write等函数。但是它不是普通的文件，并不属于其他任何文件系统，并且只存在于内存中。    1.2 命名管道FIFO：    1）FIFO可以在无关的进程之间交换数据    2）FIFO有路径名与之相关联，它以一种特殊设备文件形式存在于文件系统中。        2. 系统IPC：    2.1 消息队列    消息队列，是消息的链接表，存放在内核中。一个消息队列由一个标识符（即队列ID）来标记。 (消息队列克服了信号传递信息少，管道只能承载无格式字节流以及缓冲区大小受限等特点)具有写权限得进程可以按照一定得规则向消息队列中添加新信息；对消息队列有读权限得进程则可以从消息队列中读取信息；    特点：    1）消息队列是面向记录的，其中的消息具有特定的格式以及特定的优先级。    2）消息队列独立于发送与接收进程。进程终止时，消息队列及其内容并不会被删除。    3）消息队列可以实现消息的随机查询,消息不一定要以先进先出的次序读取,也可以按消息的类型读取。    2.2 信号量semaphore    信号量（semaphore）与已经介绍过的 IPC 结构不同，它是一个计数器，可以用来控制多个进程对共享资源的访问。信号量用于实现进程间的互斥与同步，而不是用于存储进程间通信数据。    特点：    1）信号量用于进程间同步，若要在进程间传递数据需要结合共享内存。    2）信号量基于操作系统的 PV 操作，程序对信号量的操作都是原子操作。    3）每次对信号量的 PV 操作不仅限于对信号量值加 1 或减 1，而且可以加减任意正整数。    4）支持信号量组。    2.3 信号signal    信号是一种比较复杂的通信方式，用于通知接收进程某个事件已经发生。    2.4 共享内存（Shared Memory）    它使得多个进程可以访问同一块内存空间，不同进程可以及时看到对方进程中对共享内存中数据得更新。这种方式需要依靠某种同步操作，如互斥锁和信号量等    特点：    1）共享内存是最快的一种IPC，因为进程是直接对内存进行存取    2）因为多个进程可以同时操作，所以需要进行同步    3）信号量+共享内存通常结合在一起使用，信号量用来同步对共享内存的访问        3. 套接字SOCKET：    socket也是一种进程间通信机制，与其他通信机制不同的是，它可用于不同主机之间的进程通信。 

```
##### 80、
```
  参考回答:       比较常见的内存替换算法有：FIFO，LRU，LFU，LRU-K，2Q。   1、FIFO（先进先出淘汰算法）    思想：最近刚访问的，将来访问的可能性比较大。    实现：使用一个队列，新加入的页面放入队尾，每次淘汰队首的页面，即最先进入的数据，最先被淘汰。    弊端：无法体现页面冷热信息    2、LFU（最不经常访问淘汰算法）    思想：如果数据过去被访问多次，那么将来被访问的频率也更高。    实现：每个数据块一个引用计数，所有数据块按照引用计数排序，具有相同引用计数的数据块则按照时间排序。每次淘汰队尾数据块。    开销：排序开销。    弊端：缓存颠簸。            3、LRU（最近最少使用替换算法）       思想：如果数据最近被访问过，那么将来被访问的几率也更高。       实现：使用一个栈，新页面或者命中的页面则将该页面移动到栈底，每次替换栈顶的缓存页面。       优点：LRU算法对热点数据命中率是很高的。       缺陷：       1）缓存颠簸，当缓存（1，2，3）满了，之后数据访问（0，3，2，1，0，3，2，1。。。）。       2）缓存污染，突然大量偶发性的数据访问，会让内存中存放大量冷数据。       4、LRU-K（LRU-2、LRU-3）       思想：最久未使用K次淘汰算法。       LRU-K中的K代表最近使用的次数，因此LRU可以认为是LRU-1。LRU-K的主要目的是为了解决LRU算法“缓存污染”的问题，其核心思想是将“最近使用过1次”的判断标准扩展为“最近使用过K次”。       相比LRU，LRU-K需要多维护一个队列，用于记录所有缓存数据被访问的历史。只有当数据的访问次数达到K次的时候，才将数据放入缓存。当需要淘汰数据时，LRU-K会淘汰第K次访问时间距当前时间最大的数据。       实现：       1）数据第一次被访问，加入到访问历史列表；       2）如果数据在访问历史列表里后没有达到K次访问，则按照一定规则（FIFO，LRU）淘汰；       3）当访问历史队列中的数据访问次数达到K次后，将数据索引从历史队列删除，将数据移到缓存队列中，并缓存此数据，缓存队列重新按照时间排序；       4）缓存数据队列中被再次访问后，重新排序；       5）需要淘汰数据时，淘汰缓存队列中排在末尾的数据，即：淘汰“倒数第K次访问离现在最久”的数据。       针对问题：       LRU-K的主要目的是为了解决LRU算法“缓存污染”的问题，其核心思想是将“最近使用过1次”的判断标准扩展为“最近使用过K次”。       5、2Q       类似LRU-2。使用一个FIFO队列和一个LRU队列。       实现：       1）新访问的数据插入到FIFO队列；       2）如果数据在FIFO队列中一直没有被再次访问，则最终按照FIFO规则淘汰；       3）如果数据在FIFO队列中被再次访问，则将数据移到LRU队列头部；       4）如果数据在LRU队列再次被访问，则将数据移到LRU队列头部；       5）LRU队列淘汰末尾的数据。       针对问题：LRU的缓存污染       弊端：       当FIFO容量为2时，访问负载是：ABCABCABC会退化为FIFO，用不到LRU。    

```
##### 81、
```
  参考回答:       概念：       进程是对运行时程序的封装，是系统进行资源调度和分配的的基本单位，实现了操作系统的并发；        线程是进程的子任务，是CPU调度和分派的基本单位，用于保证程序的实时性，实现进程内部的并发；线程是操作系统可识别的最小执行和调度单位。每个线程都独自占用一个虚拟处理器：独自的寄存器组，指令计数器和处理器状态。每个线程完成不同的任务，但是共享同一地址空间（也就是同样的动态内存，映射文件，目标代码等等），打开的文件队列和其他内核资源。    线程间通信的方式:    1、临界区：    通过多线程的串行化来访问公共资源或一段代码，速度快，适合控制数据访问；    2、互斥量 Synchronized/Lock：    采用互斥对象机制，只有拥有互斥对象的线程才有访问公共资源的权限。因为互斥对象只有一个，所以可以保证公共资源不会被多个线程同时访问    3、信号量 Semphare：    为控制具有有限数量的用户资源而设计的，它允许多个线程在同一时刻去访问同一个资源，但一般需要限制同一时刻访问此资源的最大线程数目。    4、事件(信号)，Wait/Notify：    通过通知操作的方式来保持多线程同步，还可以方便的实现多线程优先级的比较操作 

```
##### 82、
```
  参考回答:       1、互斥锁和读写锁区别：   互斥锁：mutex，用于保证在任何时刻，都只能有一个线程访问该对象。当获取锁操作失败时，线程会进入睡眠，等待锁释放时被唤醒。    读写锁：rwlock，分为读锁和写锁。处于读操作时，可以允许多个线程同时获得读操作。但是同一时刻只能有一个线程可以获得写锁。其它获取写锁失败的线程都会进入睡眠状态，直到写锁释放时被唤醒。 注意：写锁会阻塞其它读写锁。当有一个线程获得写锁在写时，读锁也不能被其它线程获取；写者优先于读者（一旦有写者，则后续读者必须等待，唤醒时优先考虑写者）。适用于读取数据的频率远远大于写数据的频率的场合。    互斥锁和读写锁的区别：    1）读写锁区分读者和写者，而互斥锁不区分    2）互斥锁同一时间只允许一个线程访问该对象，无论读写；读写锁同一时间内只允许一个写者，但是允许多个读者同时读对象。    2、Linux的4种锁机制：    互斥锁：mutex，用于保证在任何时刻，都只能有一个线程访问该对象。当获取锁操作失败时，线程会进入睡眠，等待锁释放时被唤醒    读写锁：rwlock，分为读锁和写锁。处于读操作时，可以允许多个线程同时获得读操作。但是同一时刻只能有一个线程可以获得写锁。其它获取写锁失败的线程都会进入睡眠状态，直到写锁释放时被唤醒。 注意：写锁会阻塞其它读写锁。当有一个线程获得写锁在写时，读锁也不能被其它线程获取；写者优先于读者（一旦有写者，则后续读者必须等待，唤醒时优先考虑写者）。适用于读取数据的频率远远大于写数据的频率的场合。    自旋锁：spinlock，在任何时刻同样只能有一个线程访问对象。但是当获取锁操作失败时，不会进入睡眠，而是会在原地自旋，直到锁被释放。这样节省了线程从睡眠状态到被唤醒期间的消耗，在加锁时间短暂的环境下会极大的提高效率。但如果加锁时间过长，则会非常浪费CPU资源。    RCU：即read-copy-update，在修改数据时，首先需要读取数据，然后生成一个副本，对副本进行修改。修改完成后，再将老数据update成新的数据。使用RCU时，读者几乎不需要同步开销，既不需要获得锁，也不使用原子指令，不会导致锁竞争，因此就不用考虑死锁问题了。而对于写者的同步开销较大，它需要复制被修改的数据，还必须使用锁机制同步并行其它写者的修改操作。在有大量读操作，少量写操作的情况下效率非常高。 

```
##### 83、
```
  参考回答:       1、一个线程只能属于一个进程，而一个进程可以有多个线程，但至少有一个线程。线程依赖于进程而存在。   2、进程在执行过程中拥有独立的内存单元，而多个线程共享进程的内存。（资源分配给进程，同一进程的所有线程共享该进程的所有资源。同一进程中的多个线程共享代码段（代码和常量），数据段（全局变量和静态变量），扩展段（堆存储）。但是每个线程拥有自己的栈段，栈段又叫运行时段，用来存放所有局部变量和临时变量。）    3、进程是资源分配的最小单位，线程是CPU调度的最小单位。    4、系统开销： 由于在创建或撤消进程时，系统都要为之分配或回收资源，如内存空间、I／o设备等。因此，操作系统所付出的开销将显著地大于在创建或撤消线程时的开销。类似地，在进行进程切换时，涉及到整个当前进程CPU环境的保存以及新被调度运行的进程的CPU环境的设置。而线程切换只须保存和设置少量寄存器的内容，并不涉及存储器管理方面的操作。可见，进程切换的开销也远大于线程切换的开销。    5、通信：由于同一进程中的多个线程具有相同的地址空间，致使它们之间的同步和通信的实现，也变得比较容易。进程间通信IPC，线程间可以直接读写进程数据段（如全局变量）来进行通信——需要进程同步和互斥手段的辅助，以保证数据的一致性。在有的系统中，线程的切换、同步和通信都无须操作系统内核的干预 。    6、进程编程调试简单可靠性高，但是创建销毁开销大；线程正相反，开销小，切换速度快，但是编程调试相对复杂。    7、进程间不会相互影响 ；线程一个线程挂掉将导致整个进程挂掉。    8、进程适应于多核、多机分布；线程适用于多核。 

```
##### 84、
```
  参考回答:       1、进程的五种基本状态：           1）创建状态：进程正在被创建       2）就绪状态：进程被加入到就绪队列中等待CPU调度运行       3）执行状态：进程正在被运行       4）等待阻塞状态：进程因为某种原因，比如等待I/O，等待设备，而暂时不能运行。       5）终止状态：进程运行完毕              2、交换技术              当多个进程竞争内存资源时，会造成内存资源紧张，并且，如果此时没有就绪进程，处理机会空闲，I/0速度比处理机速度慢得多，可能出现全部进程阻塞等待I/O。              针对以上问题，提出了两种解决方法：       1）交换技术：换出一部分进程到外存，腾出内存空间。       2）虚拟存储技术：每个进程只能装入一部分程序和数据。              在交换技术上，将内存暂时不能运行的进程，或者暂时不用的数据和程序，换出到外存，来腾出足够的内存空间，把已经具备运行条件的进程，或进程所需的数据和程序换入到内存。              从而出现了进程的挂起状态：进程被交换到外存，进程状态就成为了挂起状态。              3、活动阻塞，静止阻塞，活动就绪，静止就绪       1）活动阻塞：进程在内存，但是由于某种原因被阻塞了。       2）静止阻塞：进程在外存，同时被某种原因阻塞了。       3）活动就绪：进程在内存，处于就绪状态，只要给CPU和调度就可以直接运行。       4）静止就绪：进程在外存，处于就绪状态，只要调度到内存，给CPU和调度就可以运行。              从而出现了：       活动就绪 ——  静止就绪        （内存不够，调到外存）       活动阻塞 ——  静止阻塞        （内存不够，调到外存）       执行     ——  静止就绪         （时间片用完）   

```
##### 85、
```
  参考回答:       1、程序内存管理：   一个程序本质上都是由BSS段、data段、text段三个组成的。可以看到一个可执行程序在存储（没有调入内存）时分为代码段、数据区和未初始化数据区三部分。            BSS段（未初始化数据区）：通常用来存放程序中未初始化的全局变量和静态变量的一块内存区域。BSS段属于静态分配，程序结束后静态变量资源由系统自动释放。       数据段：存放程序中已初始化的全局变量的一块内存区域。数据段也属于静态内存分配              代码段：存放程序执行代码的一块内存区域。这部分区域的大小在程序运行前就已经确定，并且内存区域属于只读。在代码段中，也有可能包含一些只读的常数变量              text段和data段在编译时已经分配了空间，而BSS段并不占用可执行文件的大小，它是由链接器来获取内存的。              bss段（未进行初始化的数据）的内容并不存放在磁盘上的程序文件中。其原因是内核在程序开始运行前将它们设置为0。需要存放在程序文件中的只有正文段和初始化数据段。              data段（已经初始化的数据）则为数据分配空间，数据保存到目标文件中。              数据段包含经过初始化的全局变量以及它们的值。BSS段的大小从可执行文件中得到，然后链接器得到这个大小的内存块，紧跟在数据段的后面。当这个内存进入程序的地址空间后全部清零。包含数据段和BSS段的整个区段此时通常称为数据区。              可执行程序在运行时又多出两个区域：栈区和堆区。              栈区：由编译器自动释放，存放函数的参数值、局部变量等。每当一个函数被调用时，该函数的返回类型和一些调用的信息被存放到栈中。然后这个被调用的函数再为他的自动变量和临时变量在栈上分配空间。每调用一个函数一个新的栈就会被使用。栈区是从高地址位向低地址位增长的，是一块连续的内存区域，最大容量是由系统预先定义好的，申请的栈空间超过这个界限时会提示溢出，用户能从栈中获取的空间较小。              堆区：用于动态分配内存，位于BSS和栈中间的地址区域。由程序员申请分配和释放。堆是从低地址位向高地址位增长，采用链式存储结构。频繁的 malloc/free造成内存空间的不连续，产生碎片。当申请堆空间时库函数是按照一定的算法搜索可用的足够大的空间。因此堆的效率比栈要低的多。       2、A* a = new A; a->i = 10：       1）A *a：a是一个局部变量，类型为指针，故而操作系统在程序栈区开辟4/8字节的空间（0x000m），分配给指针a。       2）new A：通过new动态的在堆区申请类A大小的空间（0x000n）。       3）a = new A：将指针a的内存区域填入栈中类A申请到的地址的地址。即*（0x000m）=0x000n。       4）a->i：先找到指针a的地址0x000m，通过a的值0x000n和i在类a中偏移offset，得到a->i的地址0x000n + offset，进行*(0x000n + offset) = 10的赋值操作，即内存0x000n + offset的值是10。   

```
##### 86、
```
  参考回答:       1、static修饰符   1）static修饰成员变量    对于非静态数据成员，每个类对象都有自己的拷贝。而静态数据成员被当做是类的成员，无论这个类被定义了多少个，静态数据成员都只有一份拷贝，为该类型的所有对象所共享(包括其派生类)。所以，静态数据成员的值对每个对象都是一样的，它的值可以更新。    因为静态数据成员在全局数据区分配内存，属于本类的所有对象共享，所以它不属于特定的类对象，在没有产生类对象前就可以使用。    2）static修饰成员函数    与普通的成员函数相比，静态成员函数由于不是与任何的对象相联系，因此它不具有this指针。从这个意义上来说，它无法访问属于类对象的非静态数据成员，也无法访问非静态成员函数，只能调用其他的静态成员函数。    Static修饰的成员函数，在代码区分配内存。    2、C++继承和虚函数    C++多态分为静态多态和动态多态。静态多态是通过重载和模板技术实现，在编译的时候确定。动态多态通过虚函数和继承关系来实现，执行动态绑定，在运行的时候确定。    动态多态实现有几个条件：    (1) 虚函数；    (2) 一个基类的指针或引用指向派生类的对象；    基类指针在调用成员函数(虚函数)时，就会去查找该对象的虚函数表。虚函数表的地址在每个对象的首地址。查找该虚函数表中该函数的指针进行调用。    每个对象中保存的只是一个虚函数表的指针，C++内部为每一个类维持一个虚函数表，该类的对象的都指向这同一个虚函数表。    虚函数表中为什么就能准确查找相应的函数指针呢？因为在类设计的时候，虚函数表直接从基类也继承过来，如果覆盖了其中的某个虚函数，那么虚函数表的指针就会被替换，因此可以根据指针准确找到该调用哪个函数。    3、virtual修饰符    如果一个类是局部变量则该类数据存储在栈区，如果一个类是通过new/malloc动态申请的，则该类数据存储在堆区。    如果该类是virutal继承而来的子类，则该类的虚函数表指针和该类其他成员一起存储。虚函数表指针指向只读数据段中的类虚函数表，虚函数表中存放着一个个函数指针，函数指针指向代码段中的具体函数。    如果类中成员是virtual属性，会隐藏父类对应的属性。          

```
##### 87、
```
  参考回答:       为了解决文件共享问题，Linux引入了软链接和硬链接。除了为Linux解决文件共享使用，还带来了隐藏文件路径、增加权限安全及节省存储等好处。若1个inode号对应多个文件名，则为硬链接，即硬链接就是同一个文件使用了不同的别名,使用ln创建。若文件用户数据块中存放的内容是另一个文件的路径名指向，则该文件是软连接。软连接是一个普通文件，有自己独立的inode,但是其数据块内容比较特殊。

```
##### 88、
```
  参考回答:       大端是指低字节存储在高地址；小端存储是指低字节存储在低地址。我们可以根据联合体来判断该系统是大端还是小端。因为联合体变量总是从低地址存储。         

```
##### 89、
```
  参考回答:       静态变量存储在虚拟地址空间的数据段和bss段，C语言中其在代码执行之前初始化，属于编译期初始化。而C++中由于引入对象，对象生成必须调用构造函数，因此C++规定全局或局部静态对象当且仅当对象首次用到时进行构造

```
##### 90、
```
  参考回答:       用户态和内核态是操作系统的两种运行级别，两者最大的区别就是特权级不同。用户态拥有最低的特权级，内核态拥有较高的特权级。运行在用户态的程序不能直接访问操作系统内核数据结构和程序。内核态和用户态之间的转换方式主要包括：系统调用，异常和中断。

```
##### 91、
```

```
##### 92、
```
  参考回答:    TCP保证可靠性：    （1）序列号、确认应答、超时重传    数据到达接收方，接收方需要发出一个确认应答，表示已经收到该数据段，并且确认序号会说明了它下一次需要接收的数据序列号。如果发送发迟迟未收到确认应答，那么可能是发送的数据丢失，也可能是确认应答丢失，这时发送方在等待一定时间后会进行重传。这个时间一般是2*RTT(报文段往返时间）+一个偏差值。    （2）窗口控制与高速重发控制/快速重传（重复确认应答）    TCP会利用窗口控制来提高传输速度，意思是在一个窗口大小内，不用一定要等到应答才能发送下一段数据，窗口大小就是无需等待确认而可以继续发送数据的最大值。如果不使用窗口控制，每一个没收到确认应答的数据都要重发。    使用窗口控制，如果数据段1001-2000丢失，后面数据每次传输，确认应答都会不停地发送序号为1001的应答，表示我要接收1001开始的数据，发送端如果收到3次相同应答，就会立刻进行重发；但还有种情况有可能是数据都收到了，但是有的应答丢失了，这种情况不会进行重发，因为发送端知道，如果是数据段丢失，接收端不会放过它的，会疯狂向它提醒......    （3）拥塞控制    如果把窗口定的很大，发送端连续发送大量的数据，可能会造成网络的拥堵（大家都在用网，你在这狂发，吞吐量就那么大，当然会堵），甚至造成网络的瘫痪。所以TCP在为了防止这种情况而进行了拥塞控制。    慢启动：定义拥塞窗口，一开始将该窗口大小设为1，之后每次收到确认应答（经过一个rtt），将拥塞窗口大小*2。    拥塞避免：设置慢启动阈值，一般开始都设为65536。拥塞避免是指当拥塞窗口大小达到这个阈值，拥塞窗口的值不再指数上升，而是加法增加（每次确认应答/每个rtt，拥塞窗口大小+1），以此来避免拥塞。    将报文段的超时重传看做拥塞，则一旦发生超时重传，我们需要先将阈值设为当前窗口大小的一半，并且将窗口大小设为初值1，然后重新进入慢启动过程。    快速重传：在遇到3次重复确认应答（高速重发控制）时，代表收到了3个报文段，但是这之前的1个段丢失了，便对它进行立即重传。    然后，先将阈值设为当前窗口大小的一半，然后将拥塞窗口大小设为慢启动阈值+3的大小。    这样可以达到：在TCP通信时，网络吞吐量呈现逐渐的上升，并且随着拥堵来降低吞吐量，再进入慢慢上升的过程，网络不会轻易的发生瘫痪。        TCP建立连接和断开连接的过程：            三次握手：       1. Client将标志位SYN置为1，随机产生一个值seq=J，并将该数据包发送给Server，Client进入SYN_SENT状态，等待Server确认。       2. Server收到数据包后由标志位SYN=1知道Client请求建立连接，Server将标志位SYN和ACK都置为1，ack=J+1，随机产生一个值seq=K，并将该数据包发送给Client以确认连接请求，Server进入SYN_RCVD状态。       3. Client收到确认后，检查ack是否为J+1，ACK是否为1，如果正确则将标志位ACK置为1，ack=K+1，并将该数据包发送给Server，Server检查ack是否为K+1，ACK是否为1，如果正确则连接建立成功，Client和Server进入ESTABLISHED状态，完成三次握手，随后Client与Server之间可以开始传输数据了。              四次挥手：       由于TCP连接时全双工的，因此，每个方向都必须要单独进行关闭，这一原则是当一方完成数据发送任务后，发送一个FIN来终止这一方向的连接，收到一个FIN只是意味着这一方向上没有数据流动了，即不会再收到数据了，但是在这个TCP连接上仍然能够发送数据，直到这一方向也发送了FIN。首先进行关闭的一方将执行主动关闭，而另一方则执行被动关闭。       1.数据传输结束后，客户端的应用进程发出连接释放报文段，并停止发送数据，客户端进入FIN_WAIT_1状态，此时客户端依然可以接收服务器发送来的数据。       2.服务器接收到FIN后，发送一个ACK给客户端，确认序号为收到的序号+1，服务器进入CLOSE_WAIT状态。客户端收到后进入FIN_WAIT_2状态。       3.当服务器没有数据要发送时，服务器发送一个FIN报文，此时服务器进入LAST_ACK状态，等待客户端的确认       4.客户端收到服务器的FIN报文后，给服务器发送一个ACK报文，确认序列号为收到的序号+1。此时客户端进入TIME_WAIT状态，等待2MSL（MSL：报文段最大生存时间），然后关闭连接。    

```
##### 93、
```
  参考回答:    四层TCP/IP模型如下：            其状态转移图如下：         

```
##### 94、
```
  参考回答:    HTTP协议和HTTPS协议区别如下：    1）HTTP协议是以明文的方式在网络中传输数据，而HTTPS协议传输的数据则是经过TLS加密后的，HTTPS具有更高的安全性    2）HTTPS在TCP三次握手阶段之后，还需要进行SSL 的handshake，协商加密使用的对称加密密钥    3）HTTPS协议需要服务端申请证书，浏览器端安装对应的根证书    4）HTTP协议端口是80，HTTPS协议端口是443    HTTPS优点：    HTTPS传输数据过程中使用密钥进行加密，所以安全性更高    HTTPS协议可以认证用户和服务器，确保数据发送到正确的用户和服务器    HTTPS缺点：    HTTPS握手阶段延时较高：由于在进行HTTP会话之前还需要进行SSL握手，因此HTTPS协议握手阶段延时增加    HTTPS部署成本高：一方面HTTPS协议需要使用证书来验证自身的安全性，所以需要购买CA证书；另一方面由于采用HTTPS协议需要进行加解密的计算，占用CPU资源较多，需要的服务器配置或数目高 

```
##### 95、
```
  参考回答:    HTTP协议和HTTPS协议区别如下：    1）HTTP协议是以明文的方式在网络中传输数据，而HTTPS协议传输的数据则是经过TLS加密后的，HTTPS具有更高的安全性    2）HTTPS在TCP三次握手阶段之后，还需要进行SSL 的handshake，协商加密使用的对称加密密钥    3）HTTPS协议需要服务端申请证书，浏览器端安装对应的根证书    4）HTTP协议端口是80，HTTPS协议端口是443 

```
##### 96、
```
  参考回答:    HTTP协议的响应报文由状态行、响应头部和响应包体组成，其响应状态码总体描述如下：    1xx：指示信息--表示请求已接收，继续处理。    2xx：成功--表示请求已被成功接收、理解、接受。    3xx：重定向--要完成请求必须进行更进一步的操作。    4xx：客户端错误--请求有语法错误或请求无法实现。    5xx：服务器端错误--服务器未能实现合法的请求。    常见状态代码、状态描述的详细说明如下。    200 OK：客户端请求成功。    206 partial content服务器已经正确处理部分GET请求，实现断点续传或同时分片下载，该请求必须包含Range请求头来指示客户端期望得到的范围    300 multiple choices（可选重定向）:被请求的资源有一系列可供选择的反馈信息，由浏览器/用户自行选择其中一个。    301  moved permanently（永久重定向）：该资源已被永久移动到新位置，将来任何对该资源的访问都要使用本响应返回的若干个URI之一。    302 move temporarily(临时重定向)：请求的资源现在临时从不同的URI中获得，    304：not modified :如果客户端发送一个待条件的GET请求并且该请求以经被允许，而文档内容未被改变，则返回304,该响应不包含包体（即可直接使用缓存）。    403 Forbidden：服务器收到请求，但是拒绝提供服务。    t Found：请求资源不存在，举个例子：输入了错误的URL。 

```
##### 97、
```
  参考回答:    MAC地址是一个硬件地址，用来定义网络设备的位置，主要由数据链路层负责。而IP地址是IP协议提供的一种统一的地址格式，为互联网上的每一个网络和每一台主机分配一个逻辑地址，以此来屏蔽物理地址的差异。 

```
##### 98、
```
  中断是指CPU对系统发生的某个事件做出的一种反应，CPU暂停正在执行的程序，保存现场后自动去执行相应的处理程序，处理完该事件后再返回中断处继续执行原来的程序。中断一般三类，一种是由CPU外部引起的，如I/O中断、时钟中断，一种是来自CPU内部事件或程序执行中引起的中断，例如程序非法操作，地址越界、浮点溢出），最后一种是在程序中使用了系统调用引起的。而中断处理一般分为中断响应和中断处理两个步骤，中断响应由硬件实施，中断处理主要由软件实施。 

```
##### 99、
```
  参考回答:    OSI七层模型及其包含的协议如下:    物理层: 通过媒介传输比特,确定机械及电气规范,传输单位为bit，主要包括的协议为：IEE802.3 CLOCK RJ45        数据链路层: 将比特组装成帧和点到点的传递,传输单位为帧,主要包括的协议为MAC VLAN PPP        网络层：负责数据包从源到宿的传递和网际互连，传输单位为包,主要包括的协议为IP ARP ICMP        传输层：提供端到端的可靠报文传递和错误恢复，传输单位为报文,主要包括的协议为TCP UDP        会话层：建立、管理和终止会话，传输单位为SPDU，主要包括的协议为RPC NFS        表示层: 对数据进行翻译、加密和压缩,传输单位为PPDU，主要包括的协议为JPEG ASII        应用层: 允许访问OSI环境的手段,传输单位为APDU，主要包括的协议为FTP HTTP DNS    TCP/IP 4层模型包括：    网络接口层：MAC VLAN    网络层:IP ARP ICMP    传输层:TCP UDP    应用层:HTTP DNS SMTP 

```
##### 100、
```
  参考回答:    TCP的三次握手过程如下：    C-> SYN -> S    S->SYN/ACK->C    C->ACK->S        三次握手的原因：三次握手可以防止已经失效的连接请求报文突然又传输到服务器端导致的服务器资源浪费。例如，客户端先发送了一个SYN，但是由于网络阻塞，该SYN数据包在某个节点长期滞留。然后客户端又重传SYN数据包并正确建立TCP连接，然后传输完数据后关闭该连接。该连接释放后失效的SYN数据包才到达服务器端。在二次握手的前提下，服务器端会认为这是客户端发起的又一次请求，然后发送SYN ，并且在服务器端创建socket套接字，一直等待客户端发送数据。但是由于客户端并没有发起新的请求，所以会丢弃服务端的SYN 。此时服务器会一直等待客户端发送数据从而造成资源浪费。    TCP的四次挥手过程如下：    C->FIN->S    S->ACK->C    S->FIN->C    C->ACK->S        四次挥手的原因：由于连接的关闭控制权在应用层，所以被动关闭的一方在接收到FIN包时，TCP协议栈会直接发送一个ACK确认包，优先关闭一端的通信。然后通知应用层，由应用层决定什么时候发送FIN包。应用层可以使用系统调用函数read==0来判断对端是否关闭连接。 

```
##### 101、
```
  参考回答:    浏览器中输入URL    浏览器要将URL解析为IP地址，解析域名就要用到DNS协议，首先主机会查询DNS的缓存，如果没有就给本地DNS发送查询请求。DNS查询分为两种方式，一种是递归查询，一种是迭代查询。如果是迭代查询，本地的DNS服务器，向根域名服务器发送查询请求，根域名服务器告知该域名的一级域名服务器，然后本地服务器给该一级域名服务器发送查询请求，然后依次类推直到查询到该域名的IP地址。DNS服务器是基于UDP的，因此会用到UDP协议。        得到IP地址后，浏览器就要与服务器建立一个http连接。因此要用到http协议，http协议报文格式上面已经提到。http生成一个get请求报文，将该报文传给TCP层处理，所以还会用到TCP协议。如果采用https还会使用https协议先对http数据进行加密。TCP层如果有需要先将HTTP数据包分片，分片依据路径MTU和MSS。TCP的数据包然后会发送给IP层，用到IP协议。IP层通过路由选路，一跳一跳发送到目的地址。当然在一个网段内的寻址是通过以太网协议实现(也可以是其他物理层协议，比如PPP，SLIP)，以太网协议需要直到目的IP地址的物理地址，有需要ARP协议。    其中：    1、DNS协议，http协议，https协议属于应用层    应用层是体系结构中的最高层。应用层确定进程之间通信的性质以满足用户的需要。这里的进程就是指正在运行的程序。应用层不仅要提供应用进程所需要的信息交换和远地操作，而且还要作为互相作用的应用进程的用户代理，来完成一些为进行语义上有意义的信息交换所必须的功能。应用层直接为用户的应用进程提供服务。    2、TCP/UDP属于传输层    传输层的任务就是负责主机中两个进程之间的通信。因特网的传输层可使用两种不同协议：即面向连接的传输控制协议TCP，和无连接的用户数据报协议UDP。面向连接的服务能够提供可靠的交付，但无连接服务则不保证提供可靠的交付，它只是“尽最大努力交付”。这两种服务方式都很有用，备有其优缺点。在分组交换网内的各个交换结点机都没有传输层。    3、IP协议，ARP协议属于网络层    网络层负责为分组交换网上的不同主机提供通信。在发送数据时，网络层将运输层产生的报文段或用户数据报封装成分组或包进行传送。在TCP/IP体系中，分组也叫作IP数据报，或简称为数据报。网络层的另一个任务就是要选择合适的路由，使源主机运输层所传下来的分组能够交付到目的主机。 4、数据链路层    当发送数据时，数据链路层的任务是将在网络层交下来的IP数据报组装成帧，在两个相邻结点间的链路上传送以帧为单位的数据。每一帧包括数据和必要的控制信息（如同步信息、地址信息、差错控制、以及流量控制信息等）。控制信息使接收端能够知道—个帧从哪个比特开始和到哪个比特结束。控制信息还使接收端能够检测到所收到的帧中有无差错。 5、物理层    物理层的任务就是透明地传送比特流。在物理层上所传数据的单位是比特。传递信息所利用的一些物理媒体，如双绞线、同轴电缆、光缆等，并不在物理层之内而是在物理层的下面。因此也有人把物理媒体当做第0层。 

```
##### 102、
```
  参考回答:    拥塞控制是防止过多的数据注入网络，使得网络中的路由器或者链路过载。流量控制是点对点的通信量控制，而拥塞控制是全局的网络流量整体性的控制。发送双方都有一个拥塞窗口——cwnd。    1、慢开始    最开始发送方的拥塞窗口为1，由小到大逐渐增大发送窗口和拥塞窗口。每经过一个传输轮次，拥塞窗口cwnd加倍。当cwnd超过慢开始门限，则使用拥塞避免算法，避免cwnd增长过大。    2、拥塞避免    每经过一个往返时间RTT，cwnd就增长1。    在慢开始和拥塞避免的过程中，一旦发现网络拥塞，就把慢开始门限设为当前值的一半，并且重新设置cwnd为1，重新慢启动。（乘法减小，加法增大）    3、快重传    接收方每次收到一个失序的报文段后就立即发出重复确认，发送方只要连续收到三个重复确认就立即重传（尽早重传未被确认的报文段）。    4、快恢复    当发送方连续收到了三个重复确认，就乘法减半（慢开始门限减半），将当前的cwnd设置为慢开始门限，并且采用拥塞避免算法（连续收到了三个重复请求，说明当前网络可能没有拥塞）。        采用快恢复算法时，慢开始只在建立连接和网络超时才使用。        达到什么情况的时候开始减慢增长的速度？        采用慢开始和拥塞避免算法的时候    1. 一旦cwnd>慢开始门限，就采用拥塞避免算法，减慢增长速度    2. 一旦出现丢包的情况，就重新进行慢开始，减慢增长速度    采用快恢复和快重传算法的时候    1. 一旦cwnd>慢开始门限，就采用拥塞避免算法，减慢增长速度    2. 一旦发送方连续收到了三个重复确认，就采用拥塞避免算法，减慢增长速度 

```
##### 103、
```
  参考回答:    1、序列号、确认应答、超时重传    数据到达接收方，接收方需要发出一个确认应答，表示已经收到该数据段，并且确认序号会说明了它下一次需要接收的数据序列号。如果发送发迟迟未收到确认应答，那么可能是发送的数据丢失，也可能是确认应答丢失，这时发送方在等待一定时间后会进行重传。这个时间一般是2*RTT(报文段往返时间）+一个偏差值。    2、窗口控制与高速重发控制/快速重传（重复确认应答）    TCP会利用窗口控制来提高传输速度，意思是在一个窗口大小内，不用一定要等到应答才能发送下一段数据，窗口大小就是无需等待确认而可以继续发送数据的最大值。如果不使用窗口控制，每一个没收到确认应答的数据都要重发。    使用窗口控制，如果数据段1001-2000丢失，后面数据每次传输，确认应答都会不停地发送序号为1001的应答，表示我要接收1001开始的数据，发送端如果收到3次相同应答，就会立刻进行重发；但还有种情况有可能是数据都收到了，但是有的应答丢失了，这种情况不会进行重发，因为发送端知道，如果是数据段丢失，接收端不会放过它的，会疯狂向它提醒......    3、拥塞控制    如果把窗口定的很大，发送端连续发送大量的数据，可能会造成网络的拥堵（大家都在用网，你在这狂发，吞吐量就那么大，当然会堵），甚至造成网络的瘫痪。所以TCP在为了防止这种情况而进行了拥塞控制。    慢启动：定义拥塞窗口，一开始将该窗口大小设为1，之后每次收到确认应答（经过一个rtt），将拥塞窗口大小*2。    拥塞避免：设置慢启动阈值，一般开始都设为65536。拥塞避免是指当拥塞窗口大小达到这个阈值，拥塞窗口的值不再指数上升，而是加法增加（每次确认应答/每个rtt，拥塞窗口大小+1），以此来避免拥塞。    将报文段的超时重传看做拥塞，则一旦发生超时重传，我们需要先将阈值设为当前窗口大小的一半，并且将窗口大小设为初值1，然后重新进入慢启动过程。    快速重传：在遇到3次重复确认应答（高速重发控制）时，代表收到了3个报文段，但是这之前的1个段丢失了，便对它进行立即重传。    然后，先将阈值设为当前窗口大小的一半，然后将拥塞窗口大小设为慢启动阈值+3的大小。    这样可以达到：在TCP通信时，网络吞吐量呈现逐渐的上升，并且随着拥堵来降低吞吐量，再进入慢慢上升的过程，网络不会轻易的发生瘫痪。            TCP三次握手    深信服    TCP的三次握手过程如下：        1）首先客户端发送seq=c的SYN数据包    服务器端响应一个seq=s,ack=c+1的SYN+ACK数据包    最后客户端回复一个seq=c+1,ack=s+1的ACK数据包，三次握手完成 

```
##### 104、
```
  参考回答:    事务（Transaction）是由一系列对系统中数据进行访问与更新的操作所组成的一个程序执行逻辑单元。事务是DBMS中最基础的单位，事务不可分割。    事务具有4个基本特征，分别是：原子性（Atomicity）、一致性（Consistency）、隔离性（Isolation）、持久性（Duration），简称ACID。    1. 原子性（Atomicity）    原子性是指事务包含的所有操作要么全部成功，要么全部失败回滚，[删删删]因此事务的操作如果成功就必须要完全应用到数据库，如果操作失败则不能对数据库有任何影响。    2. 一致性（Consistency）    一致性是指事务必须使数据库从一个一致性状态变换到另一个一致性状态，也就是说一个事务执行之前和执行之后都必须处于一致性状态。    拿转账来说，假设用户A和用户B两者的钱加起来一共是5000，那么不管A和B之间如何转账，转几次账，事务结束后两个用户的钱相加起来应该还得是5000，这就是事务的一致性。    3. 隔离性（Isolation）    隔离性是当多个用户并发访问数据库时，比如操作同一张表时，数据库为每一个用户开启的事务，不能被其他事务的操作所干扰，多个并发事务之间要相互隔离。    即要达到这么一种效果：对于任意两个并发的事务T1和T2，在事务T1看来，T2要么在T1开始之前就已经结束，要么在T1结束之后才开始，这样每个事务都感觉不到有其他事务在并发地执行。    多个事务并发访问时，事务之间是隔离的，一个事务不应该影响其它事务运行效果。    这指的是在并发环境中，当不同的事务同时操纵相同的数据时，每个事务都有各自的完整数据空间。由并发事务所做的修改必须与任何其他并发事务所做的修改隔离。    不同的隔离级别：    Read Uncommitted（读取未提交[添加中文释义]内容）：最低的隔离级别，什么都不需要做，一个事务可以读到另一个事务未提交的结果。所有的并发事务问题都会发生。    Read Committed（读取提交内容）：只有在事务提交后，其更新结果才会被其他事务看见。可以解决脏读问题。    Repeated Read（可重复读）：在一个事务中，对于同一份数据的读取结果总是相同的，无论是否有其他事务对这份数据进行操作，以及这个事务是否提交。可以解决脏读、不可重复读。    Serialization（可串行化）：事务串行化执行，隔离级别最高，牺牲了系统的并发性。可以解决并发事务的所有问题。    4. 持久性（Durability）    持久性是指一个事务一旦被提交了，那么对数据库中的数据的改变就是永久性的，即便是在数据库系统遇到故障的情况下也不会丢失提交事务的操作。    例如我们在使用JDBC操作数据库时，在提交事务方法后，提示用户事务操作完成，当我们程序执行完成直到看到提示后，就可以认定事务以及正确提交，即使这时候数据库出现了问题，也必须要将我们的事务完全执行完成，否则就会造成我们看到提示事务处理完毕，但是数据库因为故障而没有执行事务的重大错误。 

```
##### 105、
```
  参考回答:    第一范式：当关系模式R的所有属性都不能再分解为更基本的数据单位时，称R是满足第一范式，即属性不可分    第二范式：如果关系模式R满足第一范式，并且R得所有非主属性都完全依赖于R的每一个候选关键属性，称R满足第二范式    第三范式：设R是一个满足第一范式条件的关系模式，X是R的任意属性集，如果X非传递依赖于R的任意一个候选关键字，称R满足第三范式，即非主属性不传递依赖于键码 

```
##### 106、
```
  参考回答:    1)原子性：事务被视为不可分割的最小单元，事物的所有操作要不成功，要不失败回滚，而回滚可以通过日志来实现，日志记录着事务所执行的修改操作，在回滚时反向执行这些修改操作。    2)一致性：数据库在事务执行前后都保持一致性状态，在一致性状态下，所有事务对一个数据的读取结果都是相同的。    3)隔离性：一个事务所做的修改在最终提交以前，对其他事务是可不见的。    4)持久性：一旦事务提交，则其所做的修改将会永远保存到数据库中。 

```
##### 107、
```
  参考回答:    Mysql主要包含四种隔离状态：                             事务隔离级别                              脏读                              不可重复读                              幻读                                      读未提交（read-uncommitted）                              是                              是                              是                                      不可重复读（read-committed）                              否                              是                              是                                      可重复读（repeatable-read）                              否                              否                              是                                      串行化（serializable）                              否                              否                              否                         

```
##### 108、
```
  参考回答:    MVCC是一种多版本并发控制机制，是MySQL的InnoDB存储引擎实现隔离级别的一种具体方式，用于实现提交读和可重复读这两种隔离级别。MVCC是通过保存数据在某个时间点的快照来实现该机制，其在每行记录后面保存两个隐藏的列，分别保存这个行的创建版本号和删除版本号，然后Innodb的MVCC使用到的快照存储在Undo日志中，该日志通过回滚指针把一个数据行所有快照连接起来。 

```
##### 109、
```
  参考回答:    通过建立索引对查询进行优化    对查询进行优化，应尽量避免全表扫描 

```
##### 110、
```
  参考回答:    】内存管理机制上：Redis 数据全部存在内存，定期写入磁盘，当内存不够时，可以选择指定的 LRU 算法删除数据。MongoDB 数据存在内存，由 linux系统 mmap 实现，当内存不够时，只将热点数据放入内存，其他数据存在磁盘。    支持的数据结构上：Redis 支持的数据结构丰富，包括hash、set、list等。    MongoDB 数据结构比较单一，但是支持丰富的数据表达，索引，最类似关系型数据库，支持的查询语言非常丰富 

```
##### 111、
```
  参考回答:    在Mysql数据库中，常用的引擎为Innodb和MyIASM,其中Innodb是一个事务型的存储引擎，有行级锁定和外键约束，提供了对数据库ACID事物的支持，实现了SQL标准的四种隔离级别，即读未提交，不可重复读，可重复读以及串行,其涉及目标就是处理大数据容量的数据库系统。而MyIASM引擎是Mysql默认的引擎，不提供数据库事务的支持，也不支持行级锁和外键，因此当写操作时需要锁定整个表，效率较低。不过其保存了表的行数，当金星select count(*)form table时，可直接读取已经保存的值，不需要进行全表扫描。因此当表的读操作远多于写操作，并且不需要事务支持时，可以优先选择MyIASM 

```
##### 112、
```
  参考回答:    Redis服务器是一个事件驱动程序，服务器需要处理以下两类事件：文件事件（服务器对套接字操作的抽象）和时间事件（服务器对定时操作的抽象）。Redis的定时机制就是借助时间事件实现的。    一个时间事件主要由以下三个属性组成：id：时间事件标识号；when：记录时间事件的到达时间；timeProc：时间事件处理器，当时间事件到达时，服务器就会调用相应的处理器来处理时间。一个时间事件根据时间事件处理器的返回值来判断是定时事件还是周期性事件        一个时间事件主要由以下三个属性组成：id：时间事件标识号；when：记录时间事件的到达时间；timeProc：时间事件处理器，当时间事件到达时，服务器就会调用相应的处理器来处理时间。一个时间事件根据时间事件处理器的返回值来判断是定时事件还是周期性事件。 

```
##### 113、
```
  参考回答:    虽然Redis文件事件处理器以单线程方式运行，但是通过使用I/O多路复用程序来监听多个套接字，文件事件处理器既实现了高性能的网络通信模型，又可以很好地与Redis服务器中其他同样以单线程运行的模块进行对接，这保持了Redis内部单线程设计的简单性。 

```
##### 114、
```
  参考回答:    1）字符串：整数值、embstr编码的简单动态字符串、简单动态字符串（SDS)    2）列表：压缩列表、双端链表    3）哈希：压缩列表、字典    4）集合：整数集合、字典    5）有序集合：压缩列表、跳跃表和字典 

```
##### 115、
```
  参考回答:    因为redis是单线程，当K很多时，如果一次性将键值对全部rehash，庞大的计算量会影响服务器性能，甚至可能会导致服务器在一段时间内停止服务。不可能一步完成整个rehash操作，所以redis是分多次、渐进式的rehash。渐进性哈希分为两种：    1）操作redis时，额外做一步rehash    对redis做读取、插入、删除等操作时，会把位于table[dict->rehashidx]位置的链表移动到新的dictht中，然后把rehashidx做加一操作，移动到后面一个槽位。    2）后台定时任务调用rehash    后台定时任务rehash调用链，同时可以通过server.hz控制rehash调用频率 

```
##### 116、
```
  参考回答:    1）数据类型 ：redis数据类型丰富，支持set liset等类型；memcache支持简单数据类型，需要客户端自己处理复杂对象    2）持久性：redis支持数据落地持久化存储；memcache不支持数据持久存储。)    3）分布式存储：redis支持master-slave复制模式；memcache可以使用一致性hash做分布式。    4）value大小不同：memcache是一个内存缓存，key的长度小于250字符，单个item存储要小于1M，不适合虚拟机使用    5）数据一致性不同：redis使用的是单线程模型，保证了数据按顺序提交；memcache需要使用cas保证数据一致性。CAS（Check and Set）是一个确保并发一致性的机制，属于“乐观锁”范畴；原理很简单：拿版本号，操作，对比版本号，如果一致就操作，不一致就放弃任何操作    6）cpu利用：redis单线程模型只能使用一个cpu，可以开启多个redis进程 

```
##### 117、
```

```
##### 118、
```

```
##### 119、
```
  参考回答:    平衡二叉树（AVL树）：    平衡二叉树又称为AVL树，是一种特殊的二叉排序树。其左右子树都是平衡二叉树，且左右子树高度之差的绝对值不超过1。一句话表述为：以树中所有结点为根的树的左右子树高度之差的绝对值不超过1。将二叉树上结点的左子树深度减去右子树深度的值称为平衡因子BF，那么平衡二叉树上的所有结点的平衡因子只可能是-1、0和1。只要二叉树上有一个结点的平衡因子的绝对值大于1，则该二叉树就是不平衡的。        红黑树：    红黑树是一种二叉查找树，但在每个节点增加一个存储位表示节点的颜色，可以是红或黑（非红即黑）。通过对任何一条从根到叶子的路径上各个节点着色的方式的限制，红黑树确保没有一条路径会比其它路径长出两倍，因此，红黑树是一种弱平衡二叉树，相对于要求严格的AVL树来说，它的旋转次数少，所以对于搜索，插入，删除操作较多的情况下，通常使用红黑树。    性质：    1. 每个节点非红即黑    2. 根节点是黑的;    3. 每个叶节点（叶节点即树尾端NULL指针或NULL节点）都是黑的;    4. 如果一个节点是红色的，则它的子节点必须是黑色的。    5. 对于任意节点而言，其到叶子点树NULL指针的每条路径都包含相同数目的黑节点;        区别：    AVL 树是高度平衡的，频繁的插入和删除，会引起频繁的rebalance，导致效率下降；红黑树不是高度平衡的，算是一种折中，插入最多两次旋转，删除最多三次旋转。 

```
##### 120、
```
  参考回答:    哈夫曼编码是哈夫曼树的一种应用，广泛用于数据文件压缩。哈夫曼编码算法用字符在文件中出现的频率来建立使用0，1表示个字符的最优表示方式，其具体算法如下：    (1)哈夫曼算法以自底向上的方式构造表示最优前缀码的二叉树T。    (2)算法以|C|个叶结点开始，执行|C|－1次的“合并”运算后产生最终所要求的树T。    (3)假设编码字符集中每一字符c的频率是f(c)。以f为键值的优先队列Q用在贪心选择时有效地确定算法当前要合并的2棵具有最小频率的树。一旦2棵具有最小频率的树合并后，产生一棵新的树，其频率为合并的2棵树的频率之和，并将新树插入优先队列Q。经过n－1次的合并后，优先队列中只剩下一棵树，即所要求的树T。 

```
##### 121、
```
  参考回答:    1、红黑树：    红黑树是一种二叉查找树，但在每个节点增加一个存储位表示节点的颜色，可以是红或黑（非红即黑）。通过对任何一条从根到叶子的路径上各个节点着色的方式的限制，红黑树确保没有一条路径会比其它路径长出两倍，因此，红黑树是一种弱平衡二叉树，相对于要求严格的AVL树来说，它的旋转次数少，所以对于搜索，插入，删除操作较多的情况下，通常使用红黑树。    性质：    1. 每个节点非红即黑    2. 根节点是黑的;    3. 每个叶节点（叶节点即树尾端NULL指针或NULL节点）都是黑的;    4. 如果一个节点是红色的，则它的子节点必须是黑色的。    5. 对于任意节点而言，其到叶子点树NULL指针的每条路径都包含相同数目的黑节点;    2、平衡二叉树（AVL树）：    红黑树是在AVL树的基础上提出来的。    平衡二叉树又称为AVL树，是一种特殊的二叉排序树。其左右子树都是平衡二叉树，且左右子树高度之差的绝对值不超过1。    AVL树中所有结点为根的树的左右子树高度之差的绝对值不超过1。    将二叉树上结点的左子树深度减去右子树深度的值称为平衡因子BF，那么平衡二叉树上的所有结点的平衡因子只可能是-1、0和1。只要二叉树上有一个结点的平衡因子的绝对值大于1，则该二叉树就是不平衡的。    3、红黑树较AVL树的优点：    AVL 树是高度平衡的，频繁的插入和删除，会引起频繁的rebalance，导致效率下降；红黑树不是高度平衡的，算是一种折中，插入最多两次旋转，删除最多三次旋转。    所以红黑树在查找，插入删除的性能都是O(logn)，且性能稳定，所以STL里面很多结构包括map底层实现都是使用的红黑树。 

```
##### 122、
```
  参考回答:    B+是一种多路搜索树，主要为磁盘或其他直接存取辅助设备而设计的一种平衡查找树，在B+树中，每个节点的可以有多个孩子，并且按照关键字大小有序排列。所有记录节点都是按照键值的大小顺序存放在同一层的叶节点中。相比B树，其具有以下几个特点：    每个节点上的指针上限为2d而不是2d+1（d为节点的出度）    内节点不存储data,只存储key    叶子节点不存储指针 

```
##### 123、
```
  参考回答:    map底层是基于红黑树实现的，因此map内部元素排列是有序的。而unordered_map底层则是基于哈希表实现的，因此其元素的排列顺序是杂乱无序的。 

```
##### 124、
```
  参考回答:    对于map，其底层是基于红黑树实现的，优点如下：    1)有序性，这是map结构最大的优点，其元素的有序性在很多应用中都会简化很多的操作    2)map的查找、删除、增加等一系列操作时间复杂度稳定，都为logn    缺点如下：    1）查找、删除、增加等操作平均时间复杂度较慢，与n相关    对于unordered_map来说，其底层是一个哈希表，优点如下：    查找、删除、添加的速度快，时间复杂度为常数级O(c)    缺点如下：    因为unordered_map内部基于哈希表，以（key,value）对的形式存储，因此空间占用率高    Unordered_map的查找、删除、添加的时间复杂度不稳定，平均为O(c)，取决于哈希函数。极端情况下可能为O(n) 

```
##### 125、
```
  参考回答:    Linux epoll机制是通过红黑树和双向链表实现的。 首先通过epoll_create()系统调用在内核中创建一个eventpoll类型的句柄，其中包括红黑树根节点和双向链表头节点。然后通过epoll_ctl()系统调用，向epoll对象的红黑树结构中添加、删除、修改感兴趣的事件，返回0标识成功，返回-1表示失败。最后通过epoll_wait()系统调用判断双向链表是否为空，如果为空则阻塞。当文件描述符状态改变，fd上的回调函数被调用，该函数将fd加入到双向链表中，此时epoll_wait函数被唤醒，返回就绪好的事件。 

```
##### 126、
```
  参考回答:    1、直接全部排序（只适用于内存够的情况）    当数据量较小的情况下，内存中可以容纳所有数据。则最简单也是最容易想到的方法是将数据全部排序，然后取排序后的数据中的前K个。    这种方法对数据量比较敏感，当数据量较大的情况下，内存不能完全容纳全部数据，这种方法便不适应了。即使内存能够满足要求，该方法将全部数据都排序了，而题目只要求找出top K个数据，所以该方法并不十分高效，不建议使用。    2、快速排序的变形 （只使用于内存够的情况）    这是一个基于快速排序的变形，因为第一种方法中说到将所有元素都排序并不十分高效，只需要找出前K个最大的就行。    这种方法类似于快速排序，首先选择一个划分元，将比这个划分元大的元素放到它的前面，比划分元小的元素放到它的后面，此时完成了一趟排序。如果此时这个划分元的序号index刚好等于K，那么这个划分元以及它左边的数，刚好就是前K个最大的元素；如果index  > K，那么前K大的数据在index的左边，那么就继续递归的从index-1个数中进行一趟排序；如果index < K，那么再从划分元的右边继续进行排序，直到找到序号index刚好等于K为止。再将前K个数进行排序后，返回Top K个元素。这种方法就避免了对除了Top K个元素以外的数据进行排序所带来的不必要的开销。    3、最小堆法    这是一种局部淘汰法。先读取前K个数，建立一个最小堆。然后将剩余的所有数字依次与最小堆的堆顶进行比较，如果小于或等于堆顶数据，则继续比较下一个；否则，删除堆顶元素，并将新数据插入堆中，重新调整最小堆。当遍历完全部数据后，最小堆中的数据即为最大的K个数。    4、分治法    将全部数据分成N份，前提是每份的数据都可以读到内存中进行处理，找到每份数据中最大的K个数。此时剩下N*K个数据，如果内存不能容纳N*K个数据，则再继续分治处理，分成M份，找出每份数据中最大的K个数，如果M*K个数仍然不能读到内存中，则继续分治处理。直到剩余的数可以读入内存中，那么可以对这些数使用快速排序的变形或者归并排序进行处理。    5、Hash法    如果这些数据中有很多重复的数据，可以先通过hash法，把重复的数去掉。这样如果重复率很高的话，会减少很大的内存用量，从而缩小运算空间。处理后的数据如果能够读入内存，则可以直接排序；否则可以使用分治法或者最小堆法来处理数据。 

```
##### 127、
```
  参考回答:    栈溢出概念：    栈溢出指的是程序向栈中某个变量中写入的字节数超过了这个变量本身所申请的字节数，因而导致栈中与其相邻的变量的值被改变。    栈溢出的原因：    1. 局部数组过大。当函数内部的数组过大时，有可能导致堆栈溢出。局部变量是存储在栈中的，因此这个很好理解。解决这类问题的办法有两个，一是增大栈空间,二是改用动态分配，使用堆（heap）而不是栈（stack）。    2. 递归调用层次太多。递归函数在运行时会执行压栈操作，当压栈次数太多时，也会导致堆栈溢出。    3. 指针或数组越界。这种情况最常见，例如进行字符串拷贝，或处理用户输入等等。    栈溢出例子：    #include <stdio.h>    #include <string.h>    int main(int argc, char* argv[]) {    char buf[256];    strcpy(buf,argv[1]);    printf("Input:%s\n",buf);    return 0;    }    上述代码中的strcpy(buf,argv[1]);这一行发生了缓冲区溢出错误，因为源缓冲区内容是用户输入的。 

```
##### 128、
```
  参考回答:    堆和栈的区别：    堆是由低地址向高地址扩展；栈是由高地址向低地址扩展        堆中的内存需要手动申请和手动释放；栈中内存是由OS自动申请和自动释放，存放着参数、局部变量等内存        堆中频繁调用malloc和free,会产生内存碎片，降低程序效率；而栈由于其先进后出的特性，不会产生内存碎片        堆的分配效率较低，而栈的分配效率较高        栈的效率高的原因：        栈是操作系统提供的数据结构，计算机底层对栈提供了一系列支持：分配专门的寄存器存储栈的地址，压栈和入栈有专门的指令执行；而堆是由C/C++函数库提供的，机制复杂，需要一些列分配内存、合并内存和释放内存的算法，因此效率较低。 

```
##### 129、
```
  参考回答:    class Solution    {    public:    void push(int node) {    stack1.push(node);    }        int pop() {    if(stack2.size()!=0){    int tmp = stack2.top();    stack2.pop();    return tmp;    }    else{    while(stack1.size()!=0){    int tmp = stack1.top();    stack1.pop();    stack2.push(tmp);    }    return pop();    }        }        private:    stack<int> stack1;    stack<int> stack2; }； 

```
##### 130、
```
  参考回答:    1）申请方式：    栈由系统自动分配和管理，堆由程序员手动分配和管理。    2）效率：    栈由系统分配，速度快，不会有内存碎片。    堆由程序员分配，速度较慢，可能由于操作不当产生内存碎片。    3）扩展方向    栈从高地址向低地址进行扩展，堆由低地址向高地址进行扩展。    4）程序局部变量是使用的栈空间，new/malloc动态申请的内存是堆空间，函数调用时会进行形参和返回值的压栈出栈，也是用的栈空间。 

```
##### 131、
```
  参考回答:    数组的特点：    数组是将元素在内存中连续存放，由于每个元素占用内存相同，可以通过下标迅速访问数组中任何元素。数组的插入数据和删除数据效率低，插入数据时，这个位置后面的数据在内存中都要向后移。删除数据时，这个数据后面的数据都要往前移动。但数组的随机读取效率很高。因为数组是连续的，知道每一个数据的内存地址，可以直接找到给地址的数据。如果应用需要快速访问数据，很少或不插入和删除元素，就应该用数组。数组需要预留空间，在使用前要先申请占内存的大小，可能会浪费内存空间。并且数组不利于扩展，数组定义的空间不够时要重新定义数组。        链表的特点：    链表中的元素在内存中不是顺序存储的，而是通过存在元素中的指针联系到一起。比如：上一个元素有个指针指到下一个元素，以此类推，直到最后一个元素。如果要访问链表中一个元素，需要从第一个元素开始，一直找到需要的元素位置。但是增加和删除一个元素对于链表数据结构就非常简单了，只要修改元素中的指针就可以了。如果应用需要经常插入和删除元素你就需要用链表数据结构了。不指定大小，扩展方便。链表大小不用定义，数据随意增删。        各自的优缺点    数组的优点：    1. 随机访问性强    2. 查找速度快    数组的缺点:    1. 插入和删除效率低    2. 可能浪费内存    3. 内存空间要求高，必须有足够的连续内存空间。    4. 数组大小固定，不能动态拓展        链表的优点:    1. 插入删除速度快    2. 内存利用率高，不会浪费内存    3. 大小没有固定，拓展很灵活。    链表的缺点:    不能随机查找，必须从第一个开始遍历，查找效率低 

```
##### 132、
```
  参考回答:    把每个数放到自己对应序号的位置上，如果其他位置上有和自己对应序号相同的数，那么即为有重复的数值。时间复杂度为O(N),同时为了节省空间复杂度，可以在原数组上进行操作，空间复杂度为O(1)    bool IsDuplicateNumber(int *array, int n)    {    if(array==NULL) return false;    int i,temp;    for(i=0;i<n;i++)    {    while(array[i]!=i)    {    if(array[array[i]]==array[i])    return true;    temp=array[array[i]];    array[array[i]]=array[i];    array[i]=temp;    }    }    return false;    } 

```
##### 133、
```
  参考回答:    int once_quick_sort(vector<int> &data, int left, int right)    {    int key = data[left];    while (left < right)    {    while (left < right && key <= data[right])    {    right--;    }    if (left < right)    {    data[left++] = data[right];    }    while (left < right && key > data[left])    {    left++;    }    if (left < right)    {    data[right--] = data[left];    }    }    data[left] = key;    return left;    }    int quick_sort(vector<int> & data, int left, int right)    {    if (left >= right )    {    return 1;    }    int middle = 0;    middle = once_quick_sort(data, left, right);    quick_sort(data, left, middle-1);    quick_sort(data, middle + 1, right);    }； 

```
##### 134、
```
  参考回答:    nt once_quick_sort(vector<int> &data, int left, int right)    {    int key = data[left];    while (left < right)    {    while (left < right && key <= data[right])    {    right--;    }    if (left < right)    {    data[left++] = data[right];    }    while (left < right && key > data[left])    {    left++;    }    if (left < right)    {    data[right--] = data[left];    }    }    data[left] = key;    return left;    }    int quick_sort(vector<int> & data, int left, int right)    {    if (left >= right )    {    return 1;    }    int middle = 0;    middle = once_quick_sort(data, left, right);    quick_sort(data, left, middle-1);    quick_sort(data, middle + 1, right);    } 

```
##### 135、
```
  参考回答:    首先使用快速排序算法将数组按照从大到小排序，然后取第k个，其时间复杂度最快为O(nlogn)    使用堆排序，建立最大堆，然后调整堆，知道获得第k个元素，其时间复杂度为O(n+klogn)    首先利用哈希表统计数组中个元素出现的次数，然后利用计数排序的思想，线性从大到小扫描过程中，前面有k-1个数则为第k大的数    利用快排思想，从数组中随机选择一个数i，然后将数组分成两部分Dl,Dr，Dl的元素都小于i,Dr的元素都大于i。然后统计Dr元素个数，如果Dr元素个数等于k-1,那么第k大的数即为k，如果Dr元素个数小于k,那么继续求Dl中第k-Dr大的元素；如果Dr元素个数大于k,那么继续求Dr中第k大的元素。        当有相同元素的时候，    首先利用哈希表统计数组中个元素出现的次数，然后利用计数排序的思想，线性从大到小扫描过程中，前面有k-1个数则为第k大的数，平均情况下时间复杂度为O(n) 

```
##### 136、
```
  参考回答:    插入排序：对于一个带排序数组来说，其初始有序数组元素个数为1，然后从第二个元素，插入到有序数组中。对于每一次插入操作，从后往前遍历当前有序数组，如果当前元素大于要插入的元素，则后移一位；如果当前元素小于或等于要插入的元素，则将要插入的元素插入到当前元素的下一位中。    希尔排序：先将整个待排序记录分割成若干子序列，然后分别进行直接插入排序，待整个序列中的记录基本有序时，在对全体记录进行一次直接插入排序。其子序列的构成不是简单的逐段分割，而是将每隔某个增量的记录组成一个子序列。希尔排序时间复杂度与增量序列的选取有关，其最后一个值必须为1.    归并排序：该算法采用分治法；对于包含m个元素的待排序序列，将其看成m个长度为1的子序列。然后两两合归并，得到n/2个长度为2或者1的有序子序列；然后再两两归并，直到得到1个长度为m的有序序列。    冒泡排序：对于包含n个元素的带排序数组，重复遍历数组，首先比较第一个和第二个元素，若为逆序，则交换元素位置；然后比较第二个和第三个元素，重复上述过程。每次遍历会把当前前n-i个元素中的最大的元素移到n-i位置。遍历n次，完成排序。    快速排序：通过一趟排序将要排序的数据分割成独立的两部分，其中一部分的所有数据都比另外一部分的所有数据都要小，然后再按此方法对这两部分数据分别进行快速排序，整个排序过程可以递归进行，以此达到整个数据变成有序序列。    选择排序：每次循环，选择当前无序数组中最小的那个元素，然后将其与无序数组的第一个元素交换位置，从而使有序数组元素加1，无序数组元素减1.初始时无序数组为空。    堆排序：堆排序是一种选择排序，利用堆这种数据结构来完成选择。其算法思想是将带排序数据构造一个最大堆（升序）/最小堆（降序），然后将堆顶元素与待排序数组的最后一个元素交换位置，此时末尾元素就是最大/最小的值。然后将剩余n-1个元素重新构造成最大堆/最小堆。    各个排序的时间复杂度、空间复杂度及稳定性如下：          

```
##### 137、
```
  参考回答:    1、冒泡排序：    从数组中第一个数开始，依次遍历数组中的每一个数，通过相邻比较交换，每一轮循环下来找出剩余未排序数的中的最大数并“冒泡”至数列的顶端。    稳定性：稳定    平均时间复杂度：O(n ^ 2)    2、插入排序：    从待排序的n个记录中的第二个记录开始，依次与前面的记录比较并寻找插入的位置，每次外循环结束后，将当前的数插入到合适的位置。    稳定性：稳定    平均时间复杂度：O(n ^ 2)    3、希尔排序（缩小增量排序）：    希尔排序法是对相邻指定距离(称为增量)的元素进行比较，并不断把增量缩小至1，完成排序。    希尔排序开始时增量较大，分组较多，每组的记录数目较少，故在各组内采用直接插入排序较快，后来增量di逐渐缩小，分组数减少，各组的记录数增多，但由于已经按di−1分组排序，文件叫接近于有序状态，所以新的一趟排序过程较快。因此希尔 排序在效率上比直接插入排序有较大的改进。    在直接插入排序的基础上，将直接插入排序中的1全部改变成增量d即可，因为希尔排序最后一轮的增量d就为1。    稳定性：不稳定    平均时间复杂度：希尔排序算法的时间复杂度分析比较复杂，实际所需的时间取决于各次排序时增量的个数和增量的取值。时间复杂度在O(n ^ 1.3)到O(n ^ 2)之间。    4、选择排序：    从所有记录中选出最小的一个数据元素与第一个位置的记录交换；然后在剩下的记录当中再找最小的与第二个位置的记录交换，循环到只剩下最后一个数据元素为止。    稳定性：不稳定    平均时间复杂度：O(n ^ 2)    5、快速排序    1）从待排序的n个记录中任意选取一个记录（通常选取第一个记录）为分区标准;    2）把所有小于该排序列的记录移动到左边，把所有大于该排序码的记录移动到右边，中间放所选记录，称之为第一趟排序；    3）然后对前后两个子序列分别重复上述过程，直到所有记录都排好序。    稳定性：不稳定    平均时间复杂度：O(nlogn)    6、堆排序：    堆：    1、完全二叉树或者是近似完全二叉树。    2、大顶堆：父节点不小于子节点键值，小顶堆：父节点不大于子节点键值。左右孩子没有大小的顺序。    堆排序在选择排序的基础上提出的，步骤：    1、建立堆    2、删除堆顶元素，同时交换堆顶元素和最后一个元素，再重新调整堆结构，直至全部删除堆中元素。    稳定性：不稳定    平均时间复杂度：O(nlogn)    7、归并排序：    采用分治思想，现将序列分为一个个子序列，对子序列进行排序合并，直至整个序列有序。    稳定性：稳定    平均时间复杂度：O(nlogn)    8、计数排序：    思想：如果比元素x小的元素个数有n个，则元素x排序后位置为n+1。    步骤：    1）找出待排序的数组中最大的元素；    2）统计数组中每个值为i的元素出现的次数，存入数组C的第i项；    3）对所有的计数累加（从C中的第一个元素开始，每一项和前一项相加）；    4）反向填充目标数组：将每个元素i放在新数组的第C(i)项，每放一个元素就将C(i)减去1。    稳定性：稳定    时间复杂度：O(n+k)，k是待排序数的范围。    9、桶排序：    步骤：    1）设置一个定量的数组当作空桶子； 常见的排序算法及其复杂度：     2）寻访序列，并且把记录一个一个放到对应的桶子去；    3）对每个不是空的桶子进行排序。    4）从不是空的桶子里把项目再放回原来的序列中。    时间复杂度：O(n+C) ，C为桶内排序时间。 

```
##### 138、
```
  参考回答:    1.直接全部排序（只适用于内存够的情况）    当数据量较小的情况下，内存中可以容纳所有数据。则最简单也是最容易想到的方法是将数据全部排序，然后取排序后的数据中的前K个。    这种方法对数据量比较敏感，当数据量较大的情况下，内存不能完全容纳全部数据，这种方法便不适应了。即使内存能够满足要求，该方法将全部数据都排序了，而题目只要求找出top K个数据，所以该方法并不十分高效，不建议使用。        2.快速排序的变形 （只使用于内存够的情况）    这是一个基于快速排序的变形，因为第一种方法中说到将所有元素都排序并不十分高效，只需要找出前K个最大的就行。    这种方法类似于快速排序，首先选择一个划分元，将比这个划分元大的元素放到它的前面，比划分元小的元素放到它的后面，此时完成了一趟排序。如果此时这个划分元的序号index刚好等于K，那么这个划分元以及它左边的数，刚好就是前K个最大的元素；如果index  > K，那么前K大的数据在index的左边，那么就继续递归的从index-1个数中进行一趟排序；如果index < K，那么再从划分元的右边继续进行排序，直到找到序号index刚好等于K为止。再将前K个数进行排序后，返回Top K个元素。这种方法就避免了对除了Top K个元素以外的数据进行排序所带来的不必要的开销。        3.最小堆法    这是一种局部淘汰法。先读取前K个数，建立一个最小堆。然后将剩余的所有数字依次与最小堆的堆顶进行比较，如果小于或等于堆顶数据，则继续比较下一个；否则，删除堆顶元素，并将新数据插入堆中，重新调整最小堆。当遍历完全部数据后，最小堆中的数据即为最大的K个数。        4.分治法    将全部数据分成N份，前提是每份的数据都可以读到内存中进行处理，找到每份数据中最大的K个数。此时剩下N*K个数据，如果内存不能容纳N*K个数据，则再继续分治处理，分成M份，找出每份数据中最大的K个数，如果M*K个数仍然不能读到内存中，则继续分治处理。直到剩余的数可以读入内存中，那么可以对这些数使用快速排序的变形或者归并排序进行处理。        5.Hash法    如果这些数据中有很多重复的数据，可以先通过hash法，把重复的数去掉。这样如果重复率很高的话，会减少很大的内存用量，从而缩小运算空间。处理后的数据如果能够读入内存，则可以直接排序；否则可以使用分治法或者最小堆法来处理数据。 

```
##### 139、
```
  参考回答:    hash表的实现主要包括构造哈希和处理哈希冲突两个方面：    对于构造哈希来说，主要包括直接地址法、平方取中法、除留余数    法等。    对于处理哈希冲突来说，最常用的处理冲突的方法有开放定址法、再哈希法、链地址法、建立公共溢出区等方法。SGL版本使用链地址法，使用一个链表保持相同散列值的元素。    虽然链地址法并不要求哈希桶长度必须为质数，但SGI STL仍然以质数来设计哈希桶长度，并且将28个质数（逐渐呈现大约两倍的关系）计算好，以备随时访问，同时提供一个函数，用来查询在这28个质数之中，“最接近某数并大于某数”的质数。 

```
##### 140、
```
  参考回答:    C++的hash表中有一个负载因子loadFactor，当loadFactor<=1时，hash表查找的期望复杂度为O(1). 因此，每次往hash表中添加元素时，我们必须保证是在loadFactor <1的情况下，才能够添加。    因此，当Hash表中loadFactor==1时，Hash就需要进行rehash。rehash过程中，会模仿C++的vector扩容方式，Hash表中每次发现loadFactor ==1时，就开辟一个原来桶数组的两倍空间，称为新桶数组，然后把原来的桶数组中元素全部重新哈希到新的桶数组中。 

```
##### 141、
```
  参考回答:    哈希表的桶个数使用质数，可以最大程度减少冲突概率，使哈希后的数据分布的更加均匀。如果使用合数，可能会造成很多数据分布会集中在某些点上，从而影响哈希表效率。    算法：    给定一个数字数组，返回哈夫曼树的头指针    struct BTreeNode* CreateHuffman(ElemType a[], int n)    {    int i, j;    struct BTreeNode **b, *q;    b = malloc(n*sizeof(struct BTreeNode));    for (i = 0; i < n; i++)    {    b[i] = malloc(sizeof(struct BTreeNode));    b[i]->data = a[i];    b[i]->left = b[i]->right = NULL;    }    for (i = 1; i < n; i++)    {        int k1 = -1, k2;    for (j = 0; j < n; j++)    {    if (b[j] != NULL && k1 == -1)    {    k1 = j;    continue;    }    if (b[j] != NULL)    {    k2 = j;    break;    }    }    for (j = k2; j < n; j++)    {    if (b[j] != NULL)    {    if (b[j]->data < b[k1]->data)    {    k2 = k1;    k1 = j;    }    else if (b[j]->data < b[k2]->data)    k2 = j;    }    }    q = malloc(sizeof(struct BTreeNode));    q->data = b[k1]->data + b[k2]->data;    q->left = b[k1];    q->right = b[k2];        b[k1] = q;    b[k2] = NULL;    }    free(b);    return q;    } 

```
##### 142、
```
  参考回答:    当哈希表关键字集合很大时，关键字值不同的元素可能会映象到哈希表的同一地址上，这样的现象称为哈希冲突。目前常用的解决哈希冲突的方法如下：    开放定址法: 当发生地址冲突时，按照某种方法继续探测哈希表中的其他存储单元，直到找到空位置为止。    再哈希法：当发生哈希冲突时使用另一个哈希函数计算地址值，直到冲突不再发生。这种方法不易产生聚集，但是增加计算时间，同时需要准备许多哈希函数。    链地址法：将所有哈希值相同的Key通过链表存储。key按顺序插入到链表中    建立公共溢出区：采用一个溢出表存储产生冲突的关键字。如果公共溢出区还产生冲突，再采用处理冲突方法处理。 

```
##### 143、
```
  参考回答:    int substr(string & str1, string &str2)    {    int len1 = str1.length();    int len2 = str2.length();    vector<vector<int>>dp(len1,vector<int>(len2,0));    for (int i = 0; i < len1; i++)    {    dp[i][0] = str1[i]==str1[0]?1:0;    }    for (int j = 0; j <= len2; j++)    {    dp[0][j] = str1[0]==str2[j]?1:0;    }    for (int i = 1; i < len1; i++)    {    for (int j = 1; j < len2; j++)    {    if (str1[i] == str2[j])    {    dp[i][j] = dp[i - 1][j - 1]+1;    }    }    }    int longest = 0;    int longest_index = 0;    for (int i = 0; i < len1; i++)    {    for (int j = 0; j < len2; j++)    {    if (longest < dp[i][j])    {    longest = dp[i][j];    longest_index = i;    }    }    }    //字符串为从第i个开始往前数longest个    for (int i = longest_index-longest+1; i <=longest_index; i++)    {    cout << str1[i] << endl;    }    return longest;    } 

```
##### 144、
```
  参考回答:    int LongestPalindromicSubstring(string & a)    {    int len = a.length();    vector<vector<int>>dp(len, vector<int>(len, 0));    for (int i = 0; i < len; i++)    {    dp[i][i] = 1;    }    int max_len = 1;    int start_index = 0;    for (int i= len - 2; i >= 0; i--)    {    for (int j = i + 1; j < len; j++)    {    if (a[i] == a[j])    {    if (j - i == 1)    {    dp[i][j] = 2;        }    else    {    if (j - i > 1)    {    dp[i][j] = dp[i + 1][j - 1] + 2;    }    }    if (max_len < dp[i][j])    {    max_len =  dp[i][j];    start_index = i;    }    }    else    {    dp[i][j] = 0;    }    }    }    cout << "max len is " << max_len << endl;    cout << "star index is" << start_index << endl;    return max_len;    } 

```
##### 145、
```
  参考回答:    int LongestPalindromicSubstring(string & a)    {    int len = a.length();    vector<vector<int>>dp(len, vector<int>(len, 0));    for (int i = 0; i < len; i++)    {    dp[i][i] = 1;    }    int max_len = 1;    int start_index = 0;    for (int i= len - 2; i >= 0; i--)    {    for (int j = i + 1; j < len; j++)    {    if (a[i] == a[j])    {    if (j - i == 1)    {    dp[i][j] = 2;    }    else    {    if (j - i > 1)    {    dp[i][j] = dp[i + 1][j - 1] + 2;    }    }    if (max_len < dp[i][j])    {    max_len =  dp[i][j];    start_index = i;    }    }    else    {    dp[i][j] = 0;    }    }    }    cout << "max len is " << max_len << endl;    cout << "star index is" << start_index << endl;    return max_len;    } 

```
##### 146、
```
  参考回答:    class Solution {    public:    ListNode* mergeTwoLists(ListNode* l1, ListNode* l2) {    if(l1 == NULL)    {    return l2;    }    if(l2 == NULL)    {    return l1;    }        if(l1->val < l2->val)    {    l1->next=mergeTwoLists(l1->next,l2);    return l1;    }    else    {    l2->next=mergeTwoLists(l1,l2->next);    return l2;    }    }    }; 

```
##### 147、
```
  参考回答:    Void reversal_list(mylist * a_list)    {    mylist * forward_node = nullptr;    mylist * cur_node = a_list->next;    mylist* next_node = cur_node->next;    if(cur_node == nullptr)    {    return ;    }    while(1)    {    cur_node->next = forward_node;    forward_node = cur_node;    cur_node = next_node;    if(cur_node == nullptr)    {    break;    }    next_node = cur_node->next;    }    a_list->next = forward_node;    } 

```
##### 148、
```
  参考回答:    思路：使用栈存储链表前半部分，然后一个个出栈，与后半部分元素比较，如果链表长度未知，可以使用快慢指针的方法，将慢指针指向的元素入栈，然后如果快指针指向了链表尾部，此时慢指针指向了链表中间    bool is_palindromic_list2(mylist *a_list)    {    if(a_list == nullptr)    {    return false;    }    stack<int>list_value;    mylist * fast =a_list;    mylist *slow =a_list;    while(fast->next!=nullptr && fast->next->next!=nullptr)    {    list_value.push(slow->next->value);    slow = slow->next;    fast = fast->next->next;    }    cout<<"middle elem value is "<<slow->next->value<<endl;    if(fast->next != nullptr)    {    cout<<"the list has odd num of node"<<endl;    slow =slow->next;    }        int cur_value;    while(!list_value.empty())    {    cur_value = list_value.top();    cout<<"stack top value is"<<cur_value<<endl;    cout<<"list value is "<<slow->next->value<<endl;        if(cur_value != slow->next->value)    {    return false;    }    list_value.pop();    slow = slow->next;    }    return true;    } 

```
##### 149、
```
  参考回答:    常见的设计模式如下：    单例模式：单例模式主要解决一个全局使用的类频繁的创建和销毁的问题。单例模式下可以确保某一个类只有一个实例，而且自行实例化并向整个系统提供这个实例。单例模式有三个要素：一是某个类只能有一个实例；二是它必须自行创建这个实例；三是它必须自行向整个系统提供这个实例。    工厂模式：工厂模式主要解决接口选择的问题。该模式下定义一个创建对象的接口，让其子类自己决定实例化哪一个工厂类，使其创建过程延迟到子类进行。    观察者模式：定义对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并被自动更新。    单例模式的多线程安全问题：    在单例模式的实现中，如果不采取任何措施，在多线程下是不安全的，可能会同时创建多个实例。因此，为了保证单例模式在多线程下的线程安全，一般采用下面几种方式实现单例模式：    1)饿汉式：基于class loader机制避免多线程的同步问题，不过，instance在类装载时就实例化，可能会产生垃圾对象。            2)懒汉式：通过双重锁机制实现线程安全。         

```
##### 150、
```
  参考回答:    常见的设计模式如下：    单例模式：单例模式主要解决一个全局使用的类频繁的创建和销毁的问题。单例模式下可以确保某一个类只有一个实例，而且自行实例化并向整个系统提供这个实例。单例模式有三个要素：一是某个类只能有一个实例；二是它必须自行创建这个实例；三是它必须自行向整个系统提供这个实例。    工厂模式：工厂模式主要解决接口选择的问题。该模式下定义一个创建对象的接口，让其子类自己决定实例化哪一个工厂类，使其创建过程延迟到子类进行。    观察者模式：定义对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并被自动更新。    装饰器模式：对已经存在的某些类进行装饰，以此来扩展一些功能，从而动态的为一个对象增加新的功能。装饰器模式是一种用于代替继承的技术，无需通过继承增加子类就能扩展对象的新功能。使用对象的关联关系代替继承关系，更加灵活，同时避免类型体系的快速膨胀。 

```
##### 151、
```
  参考回答:    单例的实现主要是通过以下两个步骤：    将该类的构造方法定义为私有方法，这样其他处的代码就无法通过调用该类的构造方法来实例化该类的对象，只有通过该类提供的静态方法来得到该类的唯一实例；        在该类内提供一个静态方法，当我们调用这个方法时，如果类持有的引用不为空就返回这个引用，如果类保持的引用为空就创建该类的实例并将实例的引用赋予该类保持的引用。        单例模式的实现主要有两种一种是饿汉式，一种是懒汉式。饿汉式线程安全的单例模式如下：            懒汉式线程安全的单例模式如下         

```
##### 152、
```
  参考回答:    1、单一职责原则    单一职责有2个含义，一个是避免相同的职责分散到不同的类中，另一个是避免一个类承担太多职责。减少类的耦合，提高类的复用性。    2、接口隔离原则    表明客户端不应该被强迫实现一些他们不会使用的接口，应该把胖接口中额方法分组，然后用多个接口代替它，每个接口服务于一个子模块。简单说，就是使用多个专门的接口比使用单个接口好很多。    该原则观点如下： 1）一个类对另外一个类的依赖性应当是建立在最小的接口上    2）客户端程序不应该依赖它不需要的接口方法。    3、开放-封闭原则    open模块的行为必须是开放的、支持扩展的，而不是僵化的。    closed在对模块的功能进行扩展时，不应该影响或大规模影响已有的程序模块。一句话概括：一个模块在扩展性方面应该是开放的而在更改性方面应该是封闭的。    核心思想就是对抽象编程，而不对具体编程。    4、替换原则    子类型必须能够替换掉他们的父类型、并出现在父类能够出现的任何地方。    主要针对继承的设计原则    1）父类的方法都要在子类中实现或者重写，并且派生类只实现其抽象类中生命的方法，而不应当给出多余的,方法定义或实现。    2）在客户端程序中只应该使用父类对象而不应当直接使用子类对象，这样可以实现运行期间绑定。    5、依赖倒置原则    上层模块不应该依赖于下层模块，他们共同依赖于一个抽象，即：父类不能依赖子类，他们都要依赖抽象类。    抽象不能依赖于具体，具体应该要依赖于抽象。 

```
##### 153、
```

```
##### 154、
```
  参考回答:    Merge会自动根据两个分支的共同祖先和两个分支的最新提交 进行一个三方合并，然后将合并中修改的内容生成一个新的 commit，即merge合并两个分支并生成一个新的提交,并且仍然后保存原来分支的commit记录        Rebase会从两个分支的共同祖先开始提取当前分支上的修改，然后将当前分支上的所有修改合并到目标分支的最新提交后面，如果提取的修改有多个，那git将依次应用到最新的提交后面。Rebase后只剩下一个分支的commit记录 

```
##### 155、
```
  参考回答:       静态函数在编译的时候就已经确定运行时机，虚函数在运行的时候动态绑定。虚函数因为用了虚函数表机制，调用的时候会增加一次内存开销

```
##### 156、
```
  参考回答:       重载：两个函数名相同，但是参数列表不同（个数，类型），返回值类型没有要求，在同一作用域中 重写：子类继承了父类，父类中的函数是虚函数，在子类中重新定义了这个虚函数，这种情况是重写

```
##### 157、
```
  参考回答:       1.加了static关键字的全局变量只能在本文件中使用。例如在a.c中定义了static int a=10;那么在b.c中用extern int a是拿不到a的值得，a的作用域只在a.c中。 2.static定义的静态局部变量分配在数据段上，普通的局部变量分配在栈上，会因为函数栈帧的释放而被释放掉。 3. 对一个类中成员变量和成员函数来说，加了static关键字，则此变量/函数就没有了this指针了，必须通过类名才能访问

```
##### 158、
```
  参考回答:       strcpy是字符串拷贝函数，原型：   char *strcpy(char* dest, const char *src);    从src逐字节拷贝到dest，直到遇到'\0'结束，因为没有指定长度，可能会导致拷贝越界，造成缓冲区溢出漏洞,安全版本是strncpy函数。 strlen函数是计算字符串长度的函数，返回从开始到'\0'之间的字符个数。 

```
##### 159、
```
  参考回答:       多态的实现主要分为静态多态和动态多态，静态多态主要是重载，在编译的时候就已经确定；动态多态是用虚函数机制实现的，在运行期间动态绑定。举个例子：一个父类类型的指针指向一个子类对象时候，使用父类的指针去调用子类中重写了的父类中的虚函数的时候，会调用子类重写过后的函数，在父类中声明为加了virtual关键字的函数，在子类中重写时候不需要加virtual也是虚函数。 虚函数的实现：在有虚函数的类中，类的最开始部分是一个虚函数表的指针，这个指针指向一个虚函数表，表中放了虚函数的地址，实际的虚函数在代码段(.text)中。当子类继承了父类的时候也会继承其虚函数表，当子类重写父类中虚函数时候，会将其继承到的虚函数表中的地址替换为重新写的函数地址。使用了虚函数，会增加访问内存开销，降低效率。

```
##### 160、
```
  参考回答:       ++i先自增1，再返回，i++先返回i,再自增1

```
##### 161、
```
  参考回答:       1. ++i 实现：   int&  int::operator++（）    {    *this +=1；    return *this；    }    2.  i++ 实现：    const int  int::operator（int）    {    int oldValue = *this；    ++（*this）；    return oldValue；    } 

```
##### 162、
```
	参考回答: 

__attribute((constructor))void before()
{
    printf("before main\n");
}

```
##### 163、
```
	参考回答；

for(int i = 0; i + 20; i--)
cout << "hello" << endl; 

```
##### 164、
```
  参考回答:       核心要理解引用计数，什么时候销毁底层指针，还有赋值，拷贝构造时候的引用计数的变化，析构的时候要判断底层指针的引用计数为0了才能真正释放底层指针的内存   template <typename T>    class SmartPtr    {    private:    T *ptr;    //底层真实的指针    int *use_count;//保存当前对象被多少指针引用计数    public:    SmartPtr(T *p); //SmartPtr<int>p(new int(2));    SmartPtr(const SmartPtr<T>&orig);//SmartPtr<int>q(p);    SmartPtr<T>&operator=(const SmartPtr<T> &rhs);//q=p    ~SmartPtr();    T operator*();  //为了能把智能指针当成普通指针操作定义解引用操作    T*operator->();  //定义取成员操作    T* operator+(int i);//定义指针加一个常数    int operator-(SmartPtr<T>&t1,SmartPtr<T>&t2);//定义两个指针相减    void getcount()    {    return *use_count    }    };    template <typename T>    int SmartPtr<T>::operator-(SmartPtr<T> &t1, SmartPtr<T> &t2)    {    return t1.ptr-t2.ptr;    }    template <typename T>    SmartPtr<T>::SmartPtr(T *p)    {    ptr=p;    try    {    use_count=new int(1);    }catch (...)    {    delete ptr;    //申请失败释放真实指针和引用计数的内存    ptr= nullptr;    delete use_count;    use_count= nullptr;        }            }    template <typename T>    SmartPtr<T>::SmartPtr(const SmartPtr<T> &orig) //复制构造函数    {    use_count=orig.use_count;//引用计数保存在一块内存，所有的SmarPtr对象的引用计数都指向这里    this->ptr=orig.ptr;    ++(*use_count);//当前对象的引用计数加1        }        template <typename T>    SmartPtr<T>& SmartPtr<T>::operator=(const SmartPtr<T> &rhs)    {    //重载=运算符，例如SmartPtr<int>p,q; p=q;这个语句中，首先给q指向的对象的引用计数加1，因为p重新指向了q所指的对象，所以p需要先给原来的对象的引用计数减1，如果减一后为0，先释放掉p原来指向的内存，然后讲q指向的对象的引用计数加1后赋值给p    ++*(rhs.use_count);    if((--*(use_count))==0)    {        delete ptr;    ptr= nullptr;    delete use_count;    use_count= nullptr;    }    ptr=rhs.ptr;    *use_count=*(rhs.use_count);    return *this;        }    template <typename T>    SmartPtr<T>::~SmartPtr()    {    getcount();    if(--(*use_count)==0)  //SmartPtr的对象会在其生命周期结束的时候调用其析构函数，在析构函数中检测当前对象的引用计数是不是只有正在结束生命周期的这个SmartPtr引用，如果是，就释放掉，如果不是，就还有其他的SmartPtr引用当前对象，就等待其他的SmartPtr对象在其生命周期结束的时候调用析构函数释放掉    {    getcount();    delete ptr;    ptr= nullptr;    delete use_count;    use_count=nullptr;    }    }        template <typename T>    T SmartPtr<T>::operator*()    {    return *ptr;    }    template <typename T>    T*  SmartPtr<T>::operator->()    {    return ptr;    }    template <typename T>    T* SmartPtr<T>::operator+(int i)    {    T *temp=ptr+i;    return temp;    }    }     

```
##### 165、
```
  参考回答:       const char * arr = "123";   //字符串123保存在常量区，const本来是修饰arr指向的值不能通过arr去修改，但是字符串“123”在常量区，本来就不能改变，所以加不加const效果都一样    char * brr = "123";    //字符串123保存在常量区，这个arr指针指向的是同一个位置，同样不能通过brr去修改"123"的值    const char crr[] = "123";    //这里123本来是在栈上的，但是编译器可能会做某些优化，将其放到常量区    char drr[] = "123";    //字符串123保存在栈区，可以通过drr去修改 

```
##### 166、
```
  参考回答:       常量在C++里的定义就是一个top-level const加上对象类型，常量定义必须初始化。对于局部对象，常量存放在栈区，对于全局对象，常量存放在全局/静态存储区。对于字面值常量，常量存放在常量存储区。

```
##### 167、
```
  参考回答:       const修饰的成员函数表明函数调用不会对对象做出任何更改，事实上，如果确认不会对对象做更改，就应该为函数加上const限定，这样无论const对象还是普通对象都可以调用该函数。

```
##### 168、
```
  参考回答:       不会，这相当于函数的重载。

```
##### 169、
```
  参考回答:       首先，对于内置类型，低精度的变量给高精度变量赋值会发生隐式类型转换，其次，对于只存在单个参数的构造函数的对象构造来说，函数调用可以直接使用该参数传入，编译器会自动调用其构造函数生成临时对象。

```
##### 170、
```
  参考回答:       reinterpret_cast：可以用于任意类型的指针之间的转换，对转换的结果不做任何保证 dynamic_cast：这种其实也是不被推荐使用的，更多使用static_cast，dynamic本身只能用于存在虚函数的父子关系的强制类型转换，对于指针，转换失败则返回nullptr，对于引用，转换失败会抛出异常 const_cast：对于未定义const版本的成员函数，我们通常需要使用const_cast来去除const引用对象的const，完成函数调用。另外一种使用方式，结合static_cast，可以在非const版本的成员函数内添加const，调用完const版本的成员函数后，再使用const_cast去除const限定。 static_cast：完成基础数据类型；同一个继承体系中类型的转换；任意类型与空指针类型void* 之间的转换。

```
##### 171、
```
  参考回答:       默认是1M，不过可以调整

```
##### 172、
```
  参考回答:       C++调用C函数需要extern C，因为C语言没有函数重载。

```
##### 173、
```
  参考回答:       首先，new/delete是C++的关键字，而malloc/free是C语言的库函数，后者使用必须指明申请内存空间的大小，对于类类型的对象，后者不会调用构造函数和析构函数

```
##### 174、
```
  参考回答:       运行时类型检查，在C++层面主要体现在dynamic_cast和typeid,VS中虚函数表的-1位置存放了指向type_info的指针。对于存在虚函数的类型，typeid和dynamic_cast都会去查询type_info

```
##### 175、
```
  参考回答:    子类若重写父类虚函数，虚函数表中，该函数的地址会被替换，对于存在虚函数的类的对象，在VS中，对象的对象模型的头部存放指向虚函数表的指针，通过该机制实现多态。 

```
##### 176、
```
  参考回答:       每一个函数调用都会分配函数栈，在栈内进行函数执行过程。调用前，先把返回地址压栈，然后把当前函数的esp指针压栈。

```
##### 177、
```
  参考回答:       从右到左

```
##### 178、
```
  参考回答:       生成一个临时变量，把它的引用作为函数参数传入函数内。

```
##### 179、
```
  参考回答:  不能。如果是这种情况下，调用拷贝构造函数的时候，首先要将实参传递给形参，这个传递的时候又要调用拷贝构造函数。。如此循环，无法完成拷贝，栈也会满。

```
##### 180、
```
  参考回答:       malloc需要给定申请内存的大小，返回的指针需要强转。 new会调用构造函数，不用指定内存大小，返回的指针不用强转。

```
##### 181、
```
  参考回答:       select在使用前，先将需要监控的描述符对应的bit位置1，然后将其传给select,当有任何一个事件发生时，select将会返回所有的描述符，需要在应用程序自己遍历去检查哪个描述符上有事件发生，效率很低，并且其不断在内核态和用户态进行描述符的拷贝，开销很大

```
##### 182、
```
  参考回答:       父进程产生子进程使用fork拷贝出来一个父进程的副本，此时只拷贝了父进程的页表，两个进程都读同一块内存，当有进程写的时候使用写实拷贝机制分配内存，exec函数可以加载一个elf文件去替换父进程，从此父进程和子进程就可以运行不同的程序了。fork从父进程返回子进程的pid，从子进程返回0.调用了wait的父进程将会发生阻塞，直到有子进程状态改变,执行成功返回0，错误返回-1。exec执行成功则子进程从新的程序开始运行，无返回值，执行失败返回-1

```
##### 183、
```
  参考回答:       静态函数在编译的时候就已经确定运行时机，虚函数在运行的时候动态绑定。虚函数因为用了虚函数表机制，调用的时候会增加一次内存开销

```
##### 184、
```
  参考回答:       重载：两个函数名相同，但是参数列表不同（个数，类型），返回值类型没有要求，在同一作用域中 重写：子类继承了父类，父类中的函数是虚函数，在子类中重新定义了这个虚函数，这种情况是重写

```
##### 185、
```
  参考回答:       1.加了static关键字的全局变量只能在本文件中使用。例如在a.c中定义了static int a=10;那么在b.c中用extern int a是拿不到a的值得，a的作用域只在a.c中。 2.static定义的静态局部变量分配在数据段上，普通的局部变量分配在栈上，会因为函数栈帧的释放而被释放掉。 3. 对一个类中成员变量和成员函数来说，加了static关键字，则此变量/函数就没有了this指针了，必须通过类名才能访问

```
##### 186、
```
  参考回答:       strcpy是字符串拷贝函数，原型：   char *strcpy(char* dest, const char *src);    从src逐字节拷贝到dest，直到遇到'\0'结束，因为没有指定长度，可能会导致拷贝越界，造成缓冲区溢出漏洞,安全版本是strncpy函数。 strlen函数是计算字符串长度的函数，返回从开始到'\0'之间的字符个数。 

```
##### 187、
```
  参考回答:       这个主要考察的是迭代器失效的问题。1.对于序列容器vector,deque来说，使用erase(itertor)后，后边的每个元素的迭代器都会失效，但是后边每个元素都会往前移动一个位置，但是erase会返回下一个有效的迭代器；2.对于关联容器map set来说，使用了erase(iterator)后，当前元素的迭代器失效，但是其结构是红黑树，删除当前元素的，不会影响到下一个元素的迭代器，所以在调用erase之前，记录下一个元素的迭代器即可。3.对于list来说，它使用了不连续分配的内存，并且它的erase方法也会返回下一个有效的iterator，因此上面两种正确的方法都可以使用。

```
##### 188、
```
  参考回答:       红黑树。unordered map底层结构是哈希表

```
##### 189、
```
  参考回答:       STL主要由：以下几部分组成： 容器迭代器仿函数算法分配器配接器 他们之间的关系：分配器给容器分配存储空间，算法通过迭代器获取容器中的内容，仿函数可以协助算法完成各种操作，配接器用来套接适配仿函数

```
##### 190、请你说说STL中map与unordered_map

```
  参考回答:  1、Map映射，map 的所有元素都是 pair，同时拥有实值（value）和键值（key）。pair 的第一元素被视为键值，第二元素被视为实值。所有元素都会根据元素的键值自动被排序。不允许键值重复。   底层实现：红黑树    适用场景：有序键值对不重复映射    2、Multimap    多重映射。multimap 的所有元素都是 pair，同时拥有实值（value）和键值（key）。pair 的第一元素被视为键值，第二元素被视为实值。所有元素都会根据元素的键值自动被排序。允许键值重复。    底层实现：红黑树    适用场景：有序键值对可重复映射 

```
##### 191、
```
  参考回答:       1、概念：   1）Vector    连续存储的容器，动态数组，在堆上分配空间    底层实现：数组    两倍容量增长：    vector 增加（插入）新元素时，如果未超过当时的容量，则还有剩余空间，那么直接添加到最后（插入指定位置），然后调整迭代器。    如果没有剩余空间了，则会重新配置原有元素个数的两倍空间，然后将原空间元素通过复制的方式初始化新空间，再向新空间增加元素，最后析构并释放原空间，之前的迭代器会失效。    性能：    访问：O(1)    插入：在最后插入（空间够）：很快    在最后插入（空间不够）：需要内存申请和释放，以及对之前数据进行拷贝。    在中间插入（空间够）：内存拷贝    在中间插入（空间不够）：需要内存申请和释放，以及对之前数据进行拷贝。    删除：在最后删除：很快    在中间删除：内存拷贝    适用场景：经常随机访问，且不经常对非尾节点进行插入删除。    2、List    动态链表，在堆上分配空间，每插入一个元数都会分配空间，每删除一个元素都会释放空间。    底层：双向链表    性能：    访问：随机访问性能很差，只能快速访问头尾节点。    插入：很快，一般是常数开销    删除：很快，一般是常数开销    适用场景：经常插入删除大量数据    2、区别：    1）vector底层实现是数组；list是双向 链表。    2）vector支持随机访问，list不支持。    3）vector是顺序内存，list不是。    4）vector在中间节点进行插入删除会导致内存拷贝，list不会。    5）vector一次性分配好内存，不够时才进行2倍扩容；list每次插入新节点都会进行内存申请。    6）vector随机访问性能好，插入删除性能差；list随机访问性能差，插入删除性能好。    3、应用    vector拥有一段连续的内存空间，因此支持随机访问，如果需要高效的随即访问，而不在乎插入和删除的效率，使用vector。    list拥有一段不连续的内存空间，如果需要高效的插入和删除，而不关心随机访问，则应使用list。 

```
##### 192、
```
  参考回答:       1、迭代器   Iterator（迭代器）模式又称Cursor（游标）模式，用于提供一种方法顺序访问一个聚合对象中各个元素, 而又不需暴露该对象的内部表示。或者这样说可能更容易理解：Iterator模式是运用于聚合对象的一种模式，通过运用该模式，使得我们可以在不知道对象内部表示的情况下，按照一定顺序（由iterator提供的方法）访问聚合对象中的各个元素。    由于Iterator模式的以上特性：与聚合对象耦合，在一定程度上限制了它的广泛运用，一般仅用于底层聚合支持类，如STL的list、vector、stack等容器类及ostream_iterator等扩展iterator。    2、迭代器和指针的区别    迭代器不是指针，是类模板，表现的像指针。他只是模拟了指针的一些功能，通过重载了指针的一些操作符，->、*、++、--等。迭代器封装了指针，是一个“可遍历STL（ Standard Template Library）容器内全部或部分元素”的对象， 本质是封装了原生指针，是指针概念的一种提升（lift），提供了比指针更高级的行为，相当于一种智能指针，他可以根据不同类型的数据结构来实现不同的++，--等操作。    迭代器返回的是对象引用而不是对象的值，所以cout只能输出迭代器使用*取值后的值而不能直接输出其自身。    3、迭代器产生原因    Iterator类的访问方式就是把不同集合类的访问逻辑抽象出来，使得不用暴露集合内部的结构而达到循环遍历集合的效果。 

```
##### 193、
```
  参考回答:       调用顺序：   int epoll_create(int size);    int epoll_ctl(int epfd, int op, int fd, struct epoll_event *event);    int epoll_wait(int epfd, struct epoll_event *events,int maxevents, int timeout);    首先创建一个epoll对象，然后使用epoll_ctl对这个对象进行操作，把需要监控的描述添加进去，这些描述如将会以epoll_event结构体的形式组成一颗红黑树，接着阻塞在epoll_wait，进入大循环，当某个fd上有事件发生时，内核将会把其对应的结构体放入到一个链表中，返回有事件发生的链表。 

```
##### 194、
```
  参考回答:       这个主要考察的是迭代器失效的问题。1.对于序列容器vector,deque来说，使用erase(itertor)后，后边的每个元素的迭代器都会失效，但是后边每个元素都会往前移动一个位置，但是erase会返回下一个有效的迭代器；2.对于关联容器map set来说，使用了erase(iterator)后，当前元素的迭代器失效，但是其结构是红黑树，删除当前元素的，不会影响到下一个元素的迭代器，所以在调用erase之前，记录下一个元素的迭代器即可。3.对于list来说，它使用了不连续分配的内存，并且它的erase方法也会返回下一个有效的iterator，因此上面两种正确的方法都可以使用。

```
##### 195、
```
  参考回答:       红黑树。unordered map底层结构是哈希表

```
##### 196、
```
  参考回答:       vector<int> findMax(vector<int>num)   {        if(num.size()==0)return num;    vector<int>res(num.size());    int i=0;    stack<int>s;    while(i<num.size())    {    if(s.empty()||num[s.top()]>=num[i])    {    s.push(i++);    }    else    {    res[s.top()]=num[i];    s.pop();    }    }    while(!s.empty())    {    res[s.top()]=INT_MAX;    s.pop();    }    for(int i=0; i<res.size(); i++)    cout<<res[i]<<endl;    return res;    } 

```
##### 197、
```
  参考回答:       resize()：改变当前容器内含有元素的数量(size())，eg: vector<int>v; v.resize(len);v的size变为len,如果原来v的size小于len，那么容器新增（len-size）个元素，元素的值为默认为0.当v.push_back(3);之后，则是3是放在了v的末尾，即下标为len，此时容器是size为len+1； reserve()：改变当前容器的最大容量（capacity）,它不会生成元素，只是确定这个容器允许放入多少对象，如果reserve(len)的值大于当前的capacity()，那么会重新分配一块能存len个对象的空间，然后把之前v.size()个对象通过copy construtor复制过来，销毁之前的内存； 测试代码如下： #include <iostream>
#include <vector>
using namespace std;
int main() {
    vector<int> a;
    a.reserve(100);
    a.resize(50);
    cout<<a.size()<<"  "<<a.capacity()<<endl;
        //50  100
    a.resize(150);
    cout<<a.size()<<"  "<<a.capacity()<<endl;
        //150  200
    a.reserve(50);
    cout<<a.size()<<"  "<<a.capacity()<<endl;
        //150  200
    a.resize(50);
    cout<<a.size()<<"  "<<a.capacity()<<endl;
        //50  200    
} 

```
##### 198、
```
  参考回答:  1、set   集合，所有元素都会根据元素的值自动被排序，且不允许重复。    底层实现：红黑树    set 底层是通过红黑树（RB-tree）来实现的，由于红黑树是一种平衡二叉搜索树，自动排序的效果很不错，所以标准的 STL 的 set 即以 RB-Tree 为底层机制。又由于 set 所开放的各种操作接口，RB-tree 也都提供了，所以几乎所有的 set 操作行为，都只有转调用 RB-tree 的操作行为而已。    适用场景：有序不重复集合    2、map    映射。map 的所有元素都是 pair，同时拥有实值（value）和键值（key）。pair 的第一元素被视为键值，第二元素被视为实值。所有元素都会根据元素的键值自动被排序。不允许键值重复。    底层：红黑树    适用场景：有序键值对不重复映射 

```
##### 199、
```
  参考回答:       多线程，线程池，io复用

```
##### 200、
```
  参考回答:  提前创建好一个线程池，用生产者消费者模型，创建一个任务队列，队列作为临界资源，有了新连接，就挂在到任务队列上，队列为空所有线程睡眠。改进死循环：使用select epoll这样的技术

```
##### 201、
```
  参考回答:       给阻塞时候缺少的资源

```
##### 202、
```
  参考回答:       使用ps命令查看

```
##### 203、
```

```
##### 204、
```
  参考回答:    被调度使用cpu的运行权 

```
##### 205、
```
  参考回答:       同步的时候用一个互斥量，在访问共享资源前对互斥量进行加锁，在访问完成后释放互斥量上的锁。对互斥量进行加锁以后，任何其他试图再次对互斥量加锁的线程将会被阻塞直到当前线程释放该互斥锁。如果释放互斥锁时有多个线程阻塞，所有在该互斥锁上的阻塞线程都会变成可运行状态，第一个变为运行状态的线程可以对互斥量加锁，其他线程将会看到互斥锁依然被锁住，只能回去再次等待它重新变为可用。在这种方式下，每次只有一个线程可以向前执行

```
##### 206、
```
  参考回答:       单核cpu，并且开了抢占可以造成这种情况。

```
##### 207、
```

```
##### 208、
```
  参考回答:       当用户有操作(鼠标，键盘等)时，系统会将这些时间转化为消息。每个打开的进程系统都为其维护了一个消息队列，系统会将这些消息放到进程的消息队列中，而应用程序会循环从消息队列中取出来消息，完成对应的操作。

```
##### 209、
```
  参考回答:       锁包括互斥锁，条件变量，自旋锁和读写锁

```
##### 210、
```
  参考回答:       生产者消费者问题利用互斥锁和条件变量可以很容易解决，条件变量这里起到了替代信号量的作用

```
##### 211、
```
  参考回答:       1.互斥条件：一个资源每次只能被一个进程使用。 2.请求与保持条件：一个进程因请求资源而阻塞时，对已获得的资源保持不放。 3.不剥夺条件:进程已获得的资源，在末使用完之前，不能强行剥夺。 4.循环等待条件:若干进程之间形成一种头尾相接的循环等待资源关系。

```
##### 212、
```
  参考回答:  1）概念：   进程是对运行时程序的封装，是系统进行资源调度和分配的的基本单位，实现了操作系统的并发；    线程是进程的子任务，是CPU调度和分派的基本单位，用于保证程序的实时性，实现进程内部的并发；线程是操作系统可识别的最小执行和调度单位。每个线程都独自占用一个虚拟处理器：独自的寄存器组，指令计数器和处理器状态。每个线程完成不同的任务，但是共享同一地址空间（也就是同样的动态内存，映射文件，目标代码等等），打开的文件队列和其他内核资源。    2）进程间通信的方式:    进程间通信主要包括管道、系统IPC（包括消息队列、信号量、信号、共享内存等）、以及套接字socket。    1、管道：    管道主要包括无名管道和命名管道:管道可用于具有亲缘关系的父子进程间的通信，有名管道除了具有管道所具有的功能外，它还允许无亲缘关系进程间的通信    普通管道PIPE：    它是半双工的（即数据只能在一个方向上流动），具有固定的读端和写端    它只能用于具有亲缘关系的进程之间的通信（也是父子进程或者兄弟进程之间）    它可以看成是一种特殊的文件，对于它的读写也可以使用普通的read、write等函数。但是它不是普通的文件，并不属于其他任何文件系统，并且只存在于内存中。    命名管道FIFO：    FIFO可以在无关的进程之间交换数据    FIFO有路径名与之相关联，它以一种特殊设备文件形式存在于文件系统中。    2、消息队列    消息队列，是消息的链接表，存放在内核中。一个消息队列由一个标识符（即队列ID）来标记。消息队列克服了信号传递信息少，管道只能承载无格式字节流以及缓冲区大小受限等特点。具有写权限得进程可以按照一定得规则向消息队列中添加新信息，对消息队列有读权限得进程则可以从消息队列中读取信息。消息队列是面向记录的，其中的消息具有特定的格式以及特定的优先级。    消息队列独立于发送与接收进程。进程终止时，消息队列及其内容并不会被删除。    消息队列可以实现消息的随机查询,消息不一定要以先进先出的次序读取，也可以按消息的类型读取。    3、信号量semaphore    信号量（semaphore）与已经介绍过的 IPC 结构不同，它是一个计数器，可以用    来控制多个进程对共享资源的访问。信号量用于实现进程间的互斥与同步，而不是用于    存储进程间通信数据。    信号量用于进程间同步，若要在进程间传递数据需要结合共享内存。    信号量基于操作系统的PV 操作，程序对信号量的操作都是原子操作。    每次对信号量的PV 操作不仅限于对信号量值加 1 或减 1，而且可以加减任    意正整数。    支持信号量组。    4信号signal    信号是一种比较复杂的通信方式，用于通知接收进程某个事件已经发生。    5共享内存（Shared Memory）    它使得多个进程可以访问同一块内存空间，不同进程可以及时看到对方进程中对共享内存中数据得更新。这种方式需要依靠某种同步操作，如互斥锁和信号量等。    共享内存是最快的一种IPC，因为进程是直接对内存进行存取    因为多个进程可以同时操作，所以需要进行同步    信号量+共享内存通常结合在一起使用，信号量用来同步对共享内存的访问    6、套接字SOCKET：    socket也是一种进程间通信机制，与其他通信机制不同的是，它可用于不同主机之间的进程通信。    3）线程间通信的方式:    1、临界区：    通过多线程的串行化来访问公共资源或一段代码，速度快，适合控制数据访问；    2、互斥量 Synchronized/Lock：    采用互斥对象机制，只有拥有互斥对象的线程才有访问公共资源的权限。因为互斥对象只有一个，所以可以保证公共资源不会被多个线程同时访问    3、信号量 Semphare：    为控制具有有限数量的用户资源而设计的，它允许多个线程在同一时刻去访问同一个资源，但一般需要限制同一时刻访问此资源的最大线程数目。    4、事件(信号)，Wait/Notify：    通过通知操作的方式来保持多线程同步，还可以方便的实现多线程优先级的比较操作。 

```
##### 213、
```
  参考回答:       1、内存溢出   指程序申请内存时，没有足够的内存供申请者使用。内存溢出就是你要的内存空间超过了系统实际分配给你的空间，此时系统相当于没法满足你的需求，就会报内存溢出的错误    内存溢出原因：    内存中加载的数据量过于庞大，如一次从数据库取出过多数据    集合类中有对对象的引用，使用完后未清空，使得不能回收    代码中存在死循环或循环产生过多重复的对象实体    使用的第三方软件中的BUG    启动参数内存值设定的过小    2、内存泄漏    内存泄漏是指由于疏忽或错误造成了程序未能释放掉不再使用的内存的情况。内存泄漏并非指内存在物理上的消失，而是应用程序分配某段内存后，由于设计错误，失去了对该段内存的控制，因而造成了内存的浪费。    内存泄漏的分类：    1、堆内存泄漏 （Heap leak）。对内存指的是程序运行中根据需要分配通过malloc,realloc new等从堆中分配的一块内存，再是完成后必须通过调用对应的 free或者delete 删掉。如果程序的设计的错误导致这部分内存没有被释放，那么此后这块内存将不会被使用，就会产生Heap Leak。    2、系统资源泄露（Resource Leak）。主要指程序使用系统分配的资源比如 Bitmap,handle ,SOCKET等没有使用相应的函数释放掉，导致系统资源的浪费，严重可导致系统效能降低，系统运行不稳定。    3、没有将基类的析构函数定义为虚函数。当基类指针指向子类对象时，如果基类的析构函数不是virtual，那么子类的析构函数将不会被调用，子类的资源没有正确是释放，因此造成内存泄露。 

```
##### 214、
```
  参考回答:       1）进程和线程区别   1、一个线程只能属于一个进程，而一个进程可以有多个线程，但至少有一个线程。线程依赖于进程而存在。    2、进程在执行过程中拥有独立的内存单元，而多个线程共享进程的内存。（资源分配给进程，同一进程的所有线程共享该进程的所有资源。同一进程中的多个线程共享代码段（代码和常量），数据段（全局变量和静态变量），扩展段（堆存储）。但是每个线程拥有自己的栈段，栈段又叫运行时段，用来存放所有局部变量和临时变量。）    3、进程是资源分配的最小单位，线程是CPU调度的最小单位。    4、系统开销： 由于在创建或撤消进程时，系统都要为之分配或回收资源，如内存空间、I／o设备等。因此，操作系统所付出的开销将显著地大于在创建或撤消线程时的开销。类似地，在进行进程切换时，涉及到整个当前进程CPU环境的保存以及新被调度运行的进程的CPU环境的设置。而线程切换只须保存和设置少量寄存器的内容，并不涉及存储器管理方面的操作。可见，进程切换的开销也远大于线程切换的开销。    5、通信：由于同一进程中的多个线程具有相同的地址空间，致使它们之间的同步和通信的实现，也变得比较容易。进程间通信IPC，线程间可以直接读写进程数据段（如全局变量）来进行通信——需要进程同步和互斥手段的辅助，以保证数据的一致性。在有的系统中，线程的切换、同步和通信都无须操作系统内核的干预 。    6、进程编程调试简单可靠性高，但是创建销毁开销大；线程正相反，开销小，切换速度快，但是编程调试相对复杂。    7、进程间不会相互影响；线程一个线程挂掉将导致整个进程挂掉。    8、进程适应于多核、多机分布；线程适用于多核。    2、常用线程模型    1、Future模型    该模型通常在使用的时候需要结合Callable接口配合使用。    Future是把结果放在将来获取，当前主线程并不急于获取处理结果。允许子线程先进行处理一段时间，处理结束之后就把结果保存下来，当主线程需要使用的时候再向子线程索取。    Callable是类似于Runnable的接口，其中call方法类似于run方法，所不同的是run方法不能抛出受检异常没有返回值，而call方法则可以抛出受检异常并可设置返回值。两者的方法体都是线程执行体。    2、fork&join模型    该模型包含递归思想和回溯思想，递归用来拆分任务，回溯用合并结果。可以用来处理一些可以进行拆分的大任务。其主要是把一个大任务逐级拆分为多个子任务，然后分别在子线程中执行，当每个子线程执行结束之后逐级回溯，返回结果进行汇总合并，最终得出想要的结果。    这里模拟一个摘苹果的场景：有100棵苹果树，每棵苹果树有10个苹果，现在要把他们摘下来。为了节约时间，规定每个线程最多只能摘10棵苹树以便于节约时间。各个线程摘完之后汇总计算总苹果树。    3、actor模型    actor模型属于一种基于消息传递机制并行任务处理思想，它以消息的形式来进行线程间数据传输，避免了全局变量的使用，进而避免了数据同步错误的隐患。actor在接受到消息之后可以自己进行处理，也可以继续传递（分发）给其它actor进行处理。在使用actor模型的时候需要使用第三方Akka提供的框架。    4、生产者消费者模型    生产者消费者模型都比较熟悉，其核心是使用一个缓存来保存任务。开启一个/多个线程来生产任务，然后再开启一个/多个来从缓存中取出任务进行处理。这样的好处是任务的生成和处理分隔开，生产者不需要处理任务，只负责向生成任务然后保存到缓存。而消费者只需要从缓存中取出任务进行处理。使用的时候可以根据任务的生成情况和处理情况开启不同的线程来处理。比如，生成的任务速度较快，那么就可以灵活的多开启几个消费者线程进行处理，这样就可以避免任务的处理响应缓慢的问题。    5、master-worker模型    master-worker模型类似于任务分发策略，开启一个master线程接收任务，然后在master中根据任务的具体情况进行分发给其它worker子线程，然后由子线程处理任务。如需返回结果，则worker处理结束之后把处理结果返回给master。 

```
##### 215、
```
  参考回答:       1、概念：   协程，又称微线程，纤程，英文名Coroutine。协程看上去也是子程序，但执行过程中，在子程序内部可中断，然后转而执行别的子程序，在适当的时候再返回来接着执行。    例如：    def A() :    print '1'    print '2'    print '3'        def B() :    print 'x'    print 'y'    print 'z'    由协程运行结果可能是12x3yz。在执行A的过程中，可以随时中断，去执行B，B也可能在执行过程中中断再去执行A。但协程的特点在于是一个线程执行。    2）协程和线程区别    那和多线程比，协程最大的优势就是协程极高的执行效率。因为子程序切换不是线程切换，而是由程序自身控制，因此，没有线程切换的开销，和多线程比，线程数量越多，协程的性能优势就越明显。    第二大优势就是不需要多线程的锁机制，因为只有一个线程，也不存在同时写变量冲突，在协程中控制共享资源不加锁，只需要判断状态就好了，所以执行效率比多线程高很多。    3）其他    在协程上利用多核CPU呢——多进程+协程，既充分利用多核，又充分发挥协程的高效率，可获得极高的性能。    Python对协程的支持还非常有限，用在generator中的yield可以一定程度上实现协程。虽然支持不完全，但已经可以发挥相当大的威力了。 

```
##### 216、系统调用是什么，你用过哪些系统调用

```
  参考回答:       1）概念：   在计算机中，系统调用（英语：system call），又称为系统呼叫，指运行在使用者空间的程序向操作系统内核请求需要更高权限运行的服务。系统调用提供了用户程序与操作系统之间的接口（即系统调用是用户程序和内核交互的接口）。    操作系统中的状态分为管态（核心态）和目态（用户态）。大多数系统交互式操作需求在内核态执行。如设备IO操作或者进程间通信。特权指令：一类只能在核心态下运行而不能在用户态下运行的特殊指令。不同的操作系统特权指令会有所差异，但是一般来说主要是和硬件相关的一些指令。用户程序只在用户态下运行，有时需要访问系统核心功能，这时通过系统调用接口使用系统调用。    应用程序有时会需要一些危险的、权限很高的指令，如果把这些权限放心地交给用户程序是很危险的(比如一个进程可能修改另一个进程的内存区，导致其不能运行)，但是又不能完全不给这些权限。于是有了系统调用，危险的指令被包装成系统调用，用户程序只能调用而无权自己运行那些危险的指令。另外，计算机硬件的资源是有限的，为了更好的管理这些资源，所有的资源都由操作系统控制，进程只能向操作系统请求这些资源。操作系统是这些资源的唯一入口，这个入口就是系统调用。    2）系统调用举例：    对文件进行写操作，程序向打开的文件写入字符串“hello world”，open和write都是系统调用。如下：  #include<stdio.h>
#include<stdlib.h>
#include<string.h>
#include<errno.h>
#include<unistd.h>
#include<sys/types.h>
#include<sys/stat.h>
#include<fcntl.h>
int main(int argc, char *argv[])
{
    if (argc<2)
        return 0;
    //用读写追加方式打开一个已经存在的文件
    int fd = open(argv[1], O_RDWR | O_APPEND);
    if (fd == -1)
    {
        printf("error is %s\n", strerror(errno));
    }
    else
    {
        //打印文件描述符号
        printf("success fd = %d\n", fd);
        char buf[100];
        memset(buf, 0, sizeof(buf));
        strcpy(buf, "hello world\n");
        write(fd, buf, strlen(buf));
        close(fd);
    }
    return 0;
}   还有写数据write，创建进程fork，vfork等都是系统调用。 

```
##### 217、请你来手写一下fork调用示例

```
  参考回答:       1、概念：   Fork：创建一个和当前进程映像一样的进程可以通过fork( )系统调用：    成功调用fork( )会创建一个新的进程，它几乎与调用fork( )的进程一模一样，这两个进程都会继续运行。在子进程中，成功的fork( )调用会返回0。在父进程中fork( )返回子进程的pid。如果出现错误，fork( )返回一个负值。    最常见的fork( )用法是创建一个新的进程，然后使用exec( )载入二进制映像，替换当前进程的映像。这种情况下，派生（fork）了新的进程，而这个子进程会执行一个新的二进制可执行文件的映像。这种“派生加执行”的方式是很常见的。    在早期的Unix系统中，创建进程比较原始。当调用fork时，内核会把所有的内部数据结构复制一份，复制进程的页表项，然后把父进程的地址空间中的内容逐页的复制到子进程的地址空间中。但从内核角度来说，逐页的复制方式是十分耗时的。现代的Unix系统采取了更多的优化，例如Linux，采用了写时复制的方法，而不是对父进程空间进程整体复制。    2、fork实例    int main(void)    {    pid_t pid;    signal(SIGCHLD, SIG_IGN);    printf("before fork pid:%d\n", getpid());    int abc = 10;    pid = fork();    if (pid == -1) {           //错误返回    perror("tile");    return -1;    }    if (pid > 0) {              //父进程空间    abc++;    printf("parent:pid:%d \n", getpid());    printf("abc:%d \n", abc);    sleep(20);    }    else if (pid == 0) {       //子进程空间    abc++;    printf("child:%d,parent: %d\n", getpid(), getppid());    printf("abc:%d", abc);    }    printf("fork after...\n"); } 

```
##### 218、
```
  参考回答:       1）用户态切换到内核态的3种方式   1、系统调用    这是用户进程主动要求切换到内核态的一种方式，用户进程通过系统调用申请操作系统提供的服务程序完成工作。而系统调用的机制其核心还是使用了操作系统为用户特别开放的一个中断来实现，例如Linux的ine 80h中断。    2、异常    当CPU在执行运行在用户态的程序时，发现了某些事件不可知的异常，这是会触发由当前运行进程切换到处理此。异常的内核相关程序中，也就到了内核态，比如缺页异常。    3、外围设备的中断    当外围设备完成用户请求的操作之后，会向CPU发出相应的中断信号，这时CPU会暂停执行下一条将要执行的指令，转而去执行中断信号的处理程序，如果先执行的指令是用户态下的程序，那么这个转换的过程自然也就发生了有用户态到内核态的切换。比如硬盘读写操作完成，系统会切换到硬盘读写的中断处理程序中执行后续操作等。    2）切换操作    从出发方式看，可以在认为存在前述3种不同的类型，但是从最终实际完成由用户态到内核态的切换操作上来说，涉及的关键步骤是完全一样的，没有任何区别，都相当于执行了一个中断响应的过程，因为系统调用实际上最终是中断机制实现的，而异常和中断处理机制基本上是一样的，用户态切换到内核态的步骤主要包括：    1、从当前进程的描述符中提取其内核栈的ss0及esp0信息。    2、使用ss0和esp0指向的内核栈将当前进程的cs,eip，eflags，ss,esp信息保存起来，这个过程也完成了由用户栈找到内核栈的切换过程，同时保存了被暂停执行的程序的下一条指令。    3、将先前由中断向量检索得到的中断处理程序的cs，eip信息装入相应的寄存器，开始执行中断处理程序，这时就转到了内核态的程序执行了。 

```
##### 219、
```
  参考回答:  1）预编译   主要处理源代码文件中的以“#”开头的预编译指令。处理规则见下    1、删除所有的#define，展开所有的宏定义。    2、处理所有的条件预编译指令，如“#if”、“#endif”、“#ifdef”、“#elif”和“#else”。    3、处理“#include”预编译指令，将文件内容替换到它的位置，这个过程是递归进行的，文件中包含其他文件。    4、删除所有的注释，“//”和“/**/”。    5、保留所有的#pragma 编译器指令，编译器需要用到他们，如：#pragma once 是为了防止有文件被重复引用。    6、添加行号和文件标识，便于编译时编译器产生调试用的行号信息，和编译时产生编译错误或警告是能够显示行号。    2）编译    把预编译之后生成的xxx.i或xxx.ii文件，进行一系列词法分析、语法分析、语义分析及优化后，生成相应的汇编代码文件。    1、词法分析：利用类似于“有限状态机”的算法，将源代码程序输入到扫描机中，将其中的字符序列分割成一系列的记号。    2、语法分析：语法分析器对由扫描器产生的记号，进行语法分析，产生语法树。由语法分析器输出的语法树是一种以表达式为节点的树。    3、语义分析：语法分析器只是完成了对表达式语法层面的分析，语义分析器则对表达式是否有意义进行判断，其分析的语义是静态语义——在编译期能分期的语义，相对应的动态语义是在运行期才能确定的语义。    4、优化：源代码级别的一个优化过程。    5、目标代码生成：由代码生成器将中间代码转换成目标机器代码，生成一系列的代码序列——汇编语言表示。    6、目标代码优化：目标代码优化器对上述的目标机器代码进行优化：寻找合适的寻址方式、使用位移来替代乘法运算、删除多余的指令等。    3）汇编    将汇编代码转变成机器可以执行的指令(机器码文件)。 汇编器的汇编过程相对于编译器来说更简单，没有复杂的语法，也没有语义，更不需要做指令优化，只是根据汇编指令和机器指令的对照表一一翻译过来，汇编过程有汇编器as完成。经汇编之后，产生目标文件(与可执行文件格式几乎一样)xxx.o(Windows下)、xxx.obj(Linux下)。    4）链接    将不同的源文件产生的目标文件进行链接，从而形成一个可以执行的程序。链接分为静态链接和动态链接：    1、静态链接：    函数和数据被编译进一个二进制文件。在使用静态库的情况下，在编译链接可执行文件时，链接器从库中复制这些函数和数据并把它们和应用程序的其它模块组合起来创建最终的可执行文件。    空间浪费：因为每个可执行程序中对所有需要的目标文件都要有一份副本，所以如果多个程序对同一个目标文件都有依赖，会出现同一个目标文件都在内存存在多个副本；    更新困难：每当库函数的代码修改了，这个时候就需要重新进行编译链接形成可执行程序。    运行速度快：但是静态链接的优点就是，在可执行程序中已经具备了所有执行程序所需要的任何东西，在执行的时候运行速度快。    2、动态链接：    动态链接的基本思想是把程序按照模块拆分成各个相对独立部分，在程序运行时才将它们链接在一起形成一个完整的程序，而不是像静态链接一样把所有程序模块都链接成一个单独的可执行文件。    共享库：就是即使需要每个程序都依赖同一个库，但是该库不会像静态链接那样在内存中存在多分，副本，而是这多个程序在执行时共享同一份副本；    更新方便：更新时只需要替换原来的目标文件，而无需将所有的程序再重新链接一遍。当程序下一次运行时，新版本的目标文件会被自动加载到内存并且链接起来，程序就完成了升级的目标。    性能损耗：因为把链接推迟到了程序运行时，所以每次执行程序都需要进行链接，所以性能会有一定损失。 

```
##### 220、请你来说一下微内核与宏内核

```
  参考回答:       宏内核：除了最基本的进程、线程管理、内存管理外，将文件系统，驱动，网络协议等等都集成在内核里面，例如linux内核。   优点：效率高。    缺点：稳定性差，开发过程中的bug经常会导致整个系统挂掉。    微内核：内核中只有最基本的调度、内存管理。驱动、文件系统等都是用户态的守护进程去实现的。    优点：稳定，驱动等的错误只会导致相应进程死掉，不会导致整个系统都崩溃    缺点：效率低。典型代表QNX，QNX的文件系统是跑在用户态的进程，称为resmgr的东西，是订阅发布机制，文件系统的错误只会导致这个守护进程挂掉。不过数据吞吐量就比较不乐观了。 

```
##### 221、
```
  参考回答:       1）正常进程   正常情况下，子进程是通过父进程创建的，子进程再创建新的进程。子进程的结束和父进程的运行是一个异步过程，即父进程永远无法预测子进程到底什么时候结束。 当一个进程完成它的工作终止之后，它的父进程需要调用wait()或者waitpid()系统调用取得子进程的终止状态。    unix提供了一种机制可以保证只要父进程想知道子进程结束时的状态信息， 就可以得到：在每个进程退出的时候，内核释放该进程所有的资源，包括打开的文件，占用的内存等。 但是仍然为其保留一定的信息，直到父进程通过wait / waitpid来取时才释放。保存信息包括：    1进程号the process ID    2退出状态the termination status of the process    3运行时间the amount of CPU time taken by the process等    2）孤儿进程    一个父进程退出，而它的一个或多个子进程还在运行，那么那些子进程将成为孤儿进程。孤儿进程将被init进程(进程号为1)所收养，并由init进程对它们完成状态收集工作。    3）僵尸进程    一个进程使用fork创建子进程，如果子进程退出，而父进程并没有调用wait或waitpid获取子进程的状态信息，那么子进程的进程描述符仍然保存在系统中。这种进程称之为僵尸进程。    僵尸进程是一个进程必然会经过的过程：这是每个子进程在结束时都要经过的阶段。    如果子进程在exit()之后，父进程没有来得及处理，这时用ps命令就能看到子进程的状态是“Z”。如果父进程能及时 处理，可能用ps命令就来不及看到子进程的僵尸状态，但这并不等于子进程不经过僵尸状态。    如果父进程在子进程结束之前退出，则子进程将由init接管。init将会以父进程的身份对僵尸状态的子进程进行处理。    危害：    如果进程不调用wait / waitpid的话， 那么保留的那段信息就不会释放，其进程号就会一直被占用，但是系统所能使用的进程号是有限的，如果大量的产生僵死进程，将因为没有可用的进程号而导致系统不能产生新的进程。    外部消灭：    通过kill发送SIGTERM或者SIGKILL信号消灭产生僵尸进程的进程，它产生的僵死进程就变成了孤儿进程，这些孤儿进程会被init进程接管，init进程会wait()这些孤儿进程，释放它们占用的系统进程表中的资源    内部解决：    1、子进程退出时向父进程发送SIGCHILD信号，父进程处理SIGCHILD信号。在信号处理函数中调用wait进行处理僵尸进程。    2、fork两次，原理是将子进程成为孤儿进程，从而其的父进程变为init进程，通过init进程可以处理僵尸进程。 

```
##### 222、
```
  参考回答:       1、GDB调试   GDB 是自由软件基金会（Free Software Foundation）的软件工具之一。它的作用是协助程序员找到代码中的错误。如果没有GDB的帮助，程序员要想跟踪代码的执行流程，唯一的办法就是添加大量的语句来产生特定的输出。但这一手段本身就可能会引入新的错误，从而也就无法对那些导致程序崩溃的错误代码进行分析。    GDB的出现减轻了开发人员的负担，他们可以在程序运行的时候单步跟踪自己的代码，或者通过断点暂时中止程序的执行。此外，他们还能够随时察看变量和内存的当前状态，并监视关键的数据结构是如何影响代码运行的。    2、条件断点    条件断点是当满足条件就中断程序运行，命令：break line-or-function if expr。    例如：(gdb)break 666 if testsize==100 

```
##### 223、
```
  参考回答:       1.阻塞IO:调用者调用了某个函数，等待这个函数返回，期间什么也不做，不停的去检查这个函数有没有返回，必须等这个函数返回才能进行下一步动作 2.非阻塞IO:非阻塞等待，每隔一段时间就去检测IO事件是否就绪。没有就绪就可以做其他事。 3.信号驱动IO:信号驱动IO:linux用套接口进行信号驱动IO，安装一个信号处理函数，进程继续运行并不阻塞，当IO时间就绪，进程收到SIGIO信号。然后处理IO事件。 4.IO复用/多路转接IO:linux用select/poll函数实现IO复用模型，这两个函数也会使进程阻塞，但是和阻塞IO所不同的是这两个函数可以同时阻塞多个IO操作。而且可以同时对多个读操作、写操作的IO函数进行检测。知道有数据可读或可写时，才真正调用IO操作函数 5.异步IO:linux中，可以调用aio_read函数告诉内核描述字缓冲区指针和缓冲区的大小、文件偏移及通知的方式，然后立即返回，当内核将数据拷贝到缓冲区后，再通知应用程序。

```
##### 224、
```
  参考回答:       事件循环就是不停循环等待时间的发生，然后将这个事件的所有处理器，以及他们订阅这个事件的时间顺序依次依次执行。当这个事件的所有处理器都被执行完毕之后，事件循环就会开始继续等待下一个事件的触发，不断往复。当同时并发地处理多个请求时，以上的概念也是正确的，可以这样理解：在单个的线程中，事件处理器是一个一个按顺序执行的。即如果某个事件绑定了两个处理器，那么第二个处理器会在第一个处理器执行完毕后，才开始执行。在这个事件的所有处理器都执行完毕之前，事件循环不会去检查是否有新的事件触发。在单个线程中，一切都是有顺序地一个一个地执行的！

```
##### 225、
```
  参考回答:       为了安全性。在cpu的一些指令中，有的指令如果用错，将会导致整个系统崩溃。分了内核态和用户态后，当用户需要操作这些指令时候，内核为其提供了API，可以通过系统调用陷入内核，让内核去执行这些操作。

```
##### 226、
```
  参考回答:       加快从磁盘读取文件的速率。page cache中有一部分磁盘文件的缓存，因为从磁盘中读取文件比较慢，所以读取文件先去page cache中去查找，如果命中，则不需要去磁盘中读取，大大加快读取速度。在 Linux 内核中，文件的每个数据块最多只能对应一个 Page Cache 项，它通过两个数据结构来管理这些 Cache 项，一个是radix tree，另一个是双向链表。Radix tree 是一种搜索树，Linux 内核利用这个数据结构来通过文件内偏移快速定位Cache 项

```
##### 227、
```
  参考回答:       这个需要看服务端的编程模型，如果如上一个问题的回答描述的这样，则处于阻塞状态，如果使用了epoll,select等这样的io复用情况下，处于运行状态

```
##### 228、
```
  参考回答:       多线程，线程池，io复用

```
##### 229、
```
  参考回答:       被调度使用cpu的运行权

```
##### 230、
```
  参考回答:       提前创建好一个线程池，用生产者消费者模型，创建一个任务队列，队列作为临界资源，有了新连接，就挂在到任务队列上，队列为空所有线程睡眠。改进死循环：使用select epoll这样的技术

```
##### 231、
```
  参考回答:       同步的时候用一个互斥量，在访问共享资源前对互斥量进行加锁，在访问完成后释放互斥量上的锁。对互斥量进行加锁以后，任何其他试图再次对互斥量加锁的线程将会被阻塞直到当前线程释放该互斥锁。如果释放互斥锁时有多个线程阻塞，所有在该互斥锁上的阻塞线程都会变成可运行状态，第一个变为运行状态的线程可以对互斥量加锁，其他线程将会看到互斥锁依然被锁住，只能回去再次等待它重新变为可用。在这种方式下，每次只有一个线程可以向前执行。

```
##### 232、
```
  参考回答:       单核cpu，并且开了抢占可以造成这种情况。

```
##### 233、
```

```
##### 234、
```
  参考回答:       1.设置一个生产者消费者队列，作为临界资源 2.初始化n个线程，并让其运行起来，加锁去队列取任务运行 3.当任务队列为空的时候，所有线程阻塞 4.当生产者队列来了一个任务后，先对队列加锁，把任务挂在到队列上，然后使用条件变量去通知阻塞中的一个线程

```
##### 235、
```
  参考回答:       sed -n '100,200p' inputfile   awk 'NR>=100&&NR<=200{print}' inputfile    head -200 inputfile|tail -100 

```
##### 236、
```
  参考回答:       1）作用：   样式扫描和处理语言。它允许创建简短的程序，这些程序读取输入文件、为数据排序、处理数据、对输入执行计算以及生成报表，还有无数其他的功能。    2）用法：    awk [-F  field-separator]  'commands'  input-file(s)    3）内置变量                      ARGC                         命令行参数个数                               ARGV                         命令行参数排列                               ENVIRON                         支持队列中系统环境变量的使用                               FILENAME                         awk浏览的文件名                               FNR                         浏览文件的记录数                               FS                         设置输入域分隔符，等价于命令行 -F选项                               NF                         浏览记录的域的个数                               NR                         已读的记录数                               OFS                         输出域分隔符                               ORS                         输出记录分隔符                               RS                         控制记录分隔符                   4）实例：    1、找到当前文件夹下所有的文件和子文件夹,并显示文件大小    > ls -l | awk '{print $5 "\t" $9}'    读入有'\n'换行符分割的一条记录，然后将记录按指定的域分隔符划分域，填充域。$0则表示所有域,$1表示第一个域,$n表示第n个域。默认域分隔符是"空白键" 或 "[tab]键"。    2、找到当前文件夹下所有的文件和子文件夹，并显示文件大小，并显示排序    > ls -l | awk 'BEGIN {COUNT = -1; print "BEGIN COUNT"}    {COUNT = COUNT + 1; print COUNT"\t"$5"\t"$9}    END {print "END, COUNT = "COUNT}'    先处理BEGIN， 然后进行文本分析，进行第二个{}的操作，分析完进行END操作。    3、找到当前文件夹下所有的子文件夹,并显示排序    > ls -l | awk 'BEGIN {print "BEGIN COUNT"} /4096/{print NR"\t"$5"\t"$9}    END {print "END"}'    * /4096/ 正则匹配式子    * 使用print $NF可以打印出一行中的最后一个字段，使用$(NF-1)则是打印倒数第二个字段，其他以此类推。     

```
##### 237、
```
  参考回答:  1）低精度时钟   Linux 2.6.16之前，内核只支持低精度时钟，内核定时器的工作方式：    1、系统启动后，会读取时钟源设备(RTC, HPET，PIT…)，初始化当前系统时间。    2、内核会根据HZ(系统定时器频率，节拍率)参数值，设置时钟事件设备，启动tick(节拍)中断。HZ表示1秒种产生多少个时钟硬件中断，tick就表示连续两个中断的间隔时间。    3、设置时钟事件设备后，时钟事件设备会定时产生一个tick中断，触发时钟中断处理函数，更新系统时钟,并检测timer wheel，进行超时事件的处理。    在上面工作方式下，Linux 2.6.16 之前，内核软件定时器采用timer wheel多级时间轮的实现机制，维护操作系统的所有定时事件。timer wheel的触发是基于系统tick周期性中断。    所以说这之前，linux只能支持ms级别的时钟，随着时钟源硬件设备的精度提高和软件高精度计时的需求，有了高精度时钟的内核设计。    2）高精度时钟    Linux 2.6.16 ，内核支持了高精度的时钟，内核采用新的定时器hrtimer，其实现逻辑和Linux 2.6.16 之前定时器逻辑区别：    hrtimer采用红黑树进行高精度定时器的管理，而不是时间轮；    高精度时钟定时器不在依赖系统的tick中断，而是基于事件触发。    旧内核的定时器实现依赖于系统定时器硬件定期的tick，基于该tick，内核会扫描timer wheel处理超时事件，会更新jiffies，wall time(墙上时间，现实时间)，process的使用时间等等工作。    新的内核不再会直接支持周期性的tick，新内核定时器框架采用了基于事件触发，而不是以前的周期性触发。新内核实现了hrtimer(high resolution timer)：于事件触发。    hrtimer的工作原理：    通过将高精度时钟硬件的下次中断触发时间设置为红黑树中最早到期的Timer 的时间，时钟到期后从红黑树中得到下一个 Timer 的到期时间，并设置硬件，如此循环反复。    在高精度时钟模式下，操作系统内核仍然需要周期性的tick中断，以便刷新内核的一些任务。hrtimer是基于事件的，不会周期性出发tick中断，所以为了实现周期性的tick中断(dynamic tick)：系统创建了一个模拟 tick 时钟的特殊 hrtimer，将其超时时间设置为一个tick时长，在超时回来后，完成对应的工作，然后再次设置下一个tick的超时时间，以此达到周期性tick中断的需求。    引入了dynamic tick，是为了能够在使用高精度时钟的同时节约能源，这样会产生tickless 情况下，会跳过一些 tick。    新内核对相关的时间硬件设备进行了统一的封装，定义了主要有下面两个结构：    时钟源设备(closk source device)：抽象那些能够提供计时功能的系统硬件，比如 RTC(Real Time Clock)、TSC(Time Stamp Counter)，HPET，ACPI PM-Timer，PIT等。不同时钟源提供的精度不一样，现在pc大都是支持高精度模式(high-resolution mode)也支持低精度模式(low-resolution mode)。    时钟事件设备(clock event device)：系统中可以触发 one-shot（单次）或者周期性中断的设备都可以作为时钟事件设备。    当前内核同时存在新旧timer wheel 和 hrtimer两套timer的实现，内核启动后会进行从低精度模式到高精度时钟模式的切换，hrtimer模拟的tick中断将驱动传统的低精度定时器系统（基于时间轮）和内核进程调度。 

```
##### 238、
```
  参考回答:    网络层等到数据链层用mac地址作为通信目标，数据包到达网络等准备往数据链层发送的时候，首先会去自己的arp缓存表(存着ip-mac对应关系)去查找改目标ip的mac地址，如果查到了，就讲目标ip的mac地址封装到链路层数据包的包头。如果缓存中没有找到，会发起一个广播：who is ip XXX tell ip XXX,所有收到的广播的机器看这个ip是不是自己的，如果是自己的，则以单拨的形式将自己的mac地址回复给请求的机器 

```
##### 239、
```
  参考回答:    根据端口区分；       看ip头中的协议标识字段，17是udp，6是tcp   

```
##### 240、
```
     参考回答:       服务端：socket-bind-listen-accept   客户端：socket-connect 

```
##### 241、
```
  参考回答:    这个需要看服务端的编程模型，如果如上一个问题的回答描述的这样，则处于阻塞状态，如果使用了epoll,select等这样的io复用情况下，处于运行状态 

```
##### 242、
```
     参考回答:       1.客户端发送syn0给服务器   2.服务器收到syn0，回复syn1,ack(syn0+1) 3.客户端收到syn1，回复ack(syn1+1) 

```
##### 243、
```
     参考回答:       两次不可以：tcp是全双工通信，两次握手只能确定单向数据链路是可以通信的，并不能保证反向的通信正常   不用四次： 本来握手应该和挥手一样都是需要确认两个方向都能联通的，本来模型应该是： 1.客户端发送syn0给服务器 2.服务器收到syn0，回复ack(syn0+1) 3.服务器发送syn1 4.客户端收到syn1，回复ack(syn1+1) 因为tcp是全双工的，上边的四部确认了数据在两个方向上都是可以正确到达的，但是2，3步没有没有上下的联系，可以将其合并，加快握手效率，所有就变成了3步握手。 

```
##### 244、
```
     参考回答:       发送方维持一个叫做拥塞窗口cwnd（congestion window）的状态变量。拥塞窗口的大小取决于网络的拥塞程度，并且动态地在变化。发送方让自己的发送窗口等于拥塞窗口，另外考虑到接受方的接收能力，发送窗口可能小于拥塞窗口。慢开始算法的思路就是，不要一开始就发送大量的数据，先探测一下网络的拥塞程度，也就是说由小到大逐渐增加拥塞窗口的大小。   过程cwnd的大小呈指数增长，直到超过慢启动门限，然后进入拥塞避免阶段，cwnd的大小线性增长，当出现网络拥塞(三个重复的ack或者超时)时候，将慢启动门限设置为出现拥塞时候大小的一半，cwnd的大小重新从0开始进入慢启动阶段。 快重传和快恢复：快重传要求接收方在收到一个失序的报文段后就立即发出重复确认（为的是使发送方及早知道有报文段没有到达对方）而不要等到自己发送数据时捎带确认。快重传算法规定，发送方只要一连收到三个重复确认就应当立即重传对方尚未收到的报文段，而不必继续等待设置的重传计时器时间到期 

```
##### 245、
```
  参考回答:    1）TCP和UDP区别    1） 连接    TCP是面向连接的传输层协议，即传输数据之前必须先建立好连接。    UDP无连接。    2） 服务对象    TCP是点对点的两点间服务，即一条TCP连接只能有两个端点；    UDP支持一对一，一对多，多对一，多对多的交互通信。    3） 可靠性    TCP是可靠交付：无差错，不丢失，不重复，按序到达。    UDP是尽最大努力交付，不保证可靠交付。    4）拥塞控制，流量控制    TCP有拥塞控制和流量控制保证数据传输的安全性。    UDP没有拥塞控制，网络拥塞不会影响源主机的发送效率。    5） 报文长度    TCP是动态报文长度，即TCP报文长度是根据接收方的窗口大小和当前网络拥塞情况决定的。    UDP面向报文，不合并，不拆分，保留上面传下来报文的边界。    6)   首部开销    TCP首部开销大，首部20个字节。    UDP首部开销小，8字节。（源端口，目的端口，数据长度，校验和）    2）TCP和UDP适用场景    从特点上我们已经知道，TCP 是可靠的但传输速度慢，UDP 是不可靠的但传输速度快。因此在选用具体协议通信时，应该根据通信数据的要求而决定。    若通信数据完整性需让位与通信实时性，则应该选用TCP 协议（如文件传输、重要状态的更新等）；反之，则使用 UDP 协议（如视频传输、实时通信等）。 

```
##### 246、
```
  参考回答:    1）TCP连接（三次握手）过程：    客户端A：发送SYN连接报文，序列号为x，进入SYNC-SENT状态。    服务端B：发送SYN连接确认报文（SYN=1，ACK = 1），序列号为y（seq = y），确认报文x（ack = x + 1），进入SYNC-RCVD状态。    客户端A：发送ACK确认报文（ACK = 1），序列号为x+1（seq = x + 1），确认报文y+1（ack = y + 1），进入ESTABLISHED状态。    服务器B：收到后进入ESTABLISHED状态。         2）三次握手原因：    三次握手是为了防止，客户端的请求报文在网络滞留，客户端超时重传了请求报文，服务端建立连接，传输数据，释放连接之后，服务器又收到了客户端滞留的请求报文，建立连接一直等待客户端发送数据。    服务器对客户端的请求进行回应(第二次握手)后，就会理所当然的认为连接已建立，而如果客户端并没有收到服务器的回应呢？此时，客户端仍认为连接未建立，服务器会对已建立的连接保存必要的资源，如果大量的这种情况，服务器会崩溃。    3） TCP释放（四次分手）过程：    服务端A：发送FIN报文（FIN = 1），序列号为u（seq = u），进入FIN-WAIT 1状态。    客户端B：发送ACK确认报文（ACK = 1），序列号为v（seq = v），确认报文u（ack = u + 1），进入CLOSE-WAIT状态，继续传送数据。    服务端A：收到上述报文进入FIN-WAIT2状态，继续接受B传输的数据。    客户端B：数据传输完毕后，发送FIN报文（FIN = 1，ACK = 1），序列号为w（seq = w），确认报文u（ack = u + 1），进入LAST-ACK状态。    服务端A：发送ACK确认报文（ACK = 1），序列号为u+1（seq = u + 1），确认报文w（ack = w + 1），进入TIME-WAIT状态，等待2MSL（最长报文段寿命），进入CLOSED状态。    客户端B：收到后上述报文后进入CLOSED状态。    4）为什么TCP协议终止链接要四次？    1、当客户端确认发送完数据且知道服务器已经接收完了，想要关闭发送数据口（当然确认信号还是可以发），就会发FIN给服务器。    2、服务器收到客户端发送的FIN，表示收到了，就会发送ACK回复。    3、但这时候服务器可能还在发送数据，没有想要关闭数据口的意思，所以服务器的FIN与ACK不是同时发送的，而是等到服务器数据发送完了，才会发送FIN给客户端。    4、客户端收到服务器发来的FIN，知道服务器的数据也发送完了，回复ACK， 客户端等待2MSL以后，没有收到服务器传来的任何消息，知道服务器已经收到自己的ACK了，客户端就关闭链接，服务器也关闭链接了。    5）2MSL意义：    1、保证最后一次握手报文能到B，能进行超时重传。    2、2MSL后，这次连接的所有报文都会消失，不会影响下一次连接。 

```
##### 247、
```
  1）HTTP协议：    HTTP协议是Hyper Text Transfer Protocol（超文本传输协议）的缩写，是用于从万维网（WWW:World Wide Web）服务器传输超文本到本地浏览器的传送协议。         HTTP是一个基于TCP/IP通信协议来传递数据（HTML 文件，图片文件，查询结果等）。    HTTP是一个属于应用层的面向对象的协议，由于其简捷、快速的方式，适用于分布式超媒体信息系统。它于1990年提出，经过几年的使用与发展，得到不断地完善和扩展。目前在WWW中使用的是HTTP/1.0的第六版，HTTP/1.1的规范化工作正在进行之中，而且HTTP-NG（Next Generation of HTTP）的建议已经提出。    HTTP协议工作于客户端-服务端架构为上。浏览器作为HTTP客户端通过URL向HTTP服务端即WEB服务器发送所有请求。Web服务器根据接收到的请求后，向客户端发送响应信息。    2）HTTP协议特点    1、简单快速：    客户向服务器请求服务时，只需传送请求方法和路径。请求方法常用的有GET、HEAD、POST。每种方法规定了客户与服务器联系的类型不同。由于HTTP协议简单，使得HTTP服务器的程序规模小，因而通信速度很快。    2、灵活：    HTTP允许传输任意类型的数据对象。正在传输的类型由Content-Type加以标记。    3、无连接：    无连接的含义是限制每次连接只处理一个请求。服务器处理完客户的请求，并收到客户的应答后，即断开连接。采用这种方式可以节省传输时间。    4、无状态：    HTTP协议是无状态协议。无状态是指协议对于事务处理没有记忆能力。缺少状态意味着如果后续处理需要前面的信息，则它必须重传，这样可能导致每次连接传送的数据量增大。另一方面，在服务器不需要先前信息时它的应答就较快。    5、支持B/S及C/S模式。    6、默认端口80    7、基于TCP协议    3）HTTP过程概述：    HTTP协议定义Web客户端如何从Web服务器请求Web页面，以及服务器如何把Web页面传送给客户端。HTTP协议采用了请求/响应模型。客户端向服务器发送一个请求报文，请求报文包含请求的方法、URL、协议版本、请求头部和请求数据。服务器以一个状态行作为响应，响应的内容包括协议的版本、成功或者错误代码、服务器信息、响应头部和响应数据。    HTTP 请求/响应的步骤如下：    1、客户端连接到Web服务器    一个HTTP客户端，通常是浏览器，与Web服务器的HTTP端口（默认为80）建立一个TCP套接字连接。例如，http://www.baidu.com。    2、发送HTTP请求    通过TCP套接字，客户端向Web服务器发送一个文本的请求报文，一个请求报文由请求行、请求头部、空行和请求数据4部分组成。    3、服务器接受请求并返回HTTP响应    Web服务器解析请求，定位请求资源。服务器将资源复本写到TCP套接字，由客户端读取。一个响应由状态行、响应头部、空行和响应数据4部分组成。    4、释放连接TCP连接    若connection 模式为close，则服务器主动关闭TCP连接，客户端被动关闭连接，释放TCP连接;若connection 模式为keepalive，则该连接会保持一段时间，在该时间内可以继续接收请求;    5、客户端浏览器解析HTML内容    客户端浏览器首先解析状态行，查看表明请求是否成功的状态代码。然后解析每一个响应头，响应头告知以下为若干字节的HTML文档和文档的字符集。客户端浏览器读取响应数据HTML，根据HTML的语法对其进行格式化，并在浏览器窗口中显示。    4、举例：    在浏览器地址栏键入URL，按下回车之后会经历以下流程：    1、浏览器向 DNS 服务器请求解析该 URL 中的域名所对应的 IP 地址；    2、解析出 IP 地址后，根据该 IP 地址和默认端口80，和服务器建立TCP连接；    3、浏览器发出读取文件（URL中域名后面部分对应的文件）的HTTP 请求，该请求报文作为 TCP 三次握手的第三个报文的数据发送给服务器；         4、服务器对浏览器请求作出响应，并把对应的 html 文本发送给浏览器；    5、释放 TCP连接；    6、浏览器将该 html 文本并显示内容； 

```
##### 248、
```
  参考回答:    1、概括    对于GET方式的请求，浏览器会把http header和data一并发送出去，服务器响应200（返回数据）；    而对于POST，浏览器先发送header，服务器响应100 continue，浏览器再发送data，服务器响应200 ok（返回数据）    2、区别：    1、get参数通过url传递，post放在request body中。    2、get请求在url中传递的参数是有长度限制的，而post没有。    3、get比post更不安全，因为参数直接暴露在url中，所以不能用来传递敏感信息。    4、get请求只能进行url编码，而post支持多种编码方式。    5、get请求会浏览器主动cache，而post支持多种编码方式。    6、get请求参数会被完整保留在浏览历史记录里，而post中的参数不会被保留。    7、GET和POST本质上就是TCP链接，并无差别。但是由于HTTP的规定和浏览器/服务器的限制，导致他们在应用过程中体现出一些不同。    8、GET产生一个TCP数据包；POST产生两个TCP数据包。 

```
##### 249、
```
  参考回答:    1）基于TCP的socket：    1、服务器端程序：    1创建一个socket，用函数socket()    2绑定IP地址、端口等信息到socket上，用函数bind()    3设置允许的最大连接数，用函数listen()    4接收客户端上来的连接，用函数accept()    5收发数据，用函数send()和recv()，或者read()和write()    6关闭网络连接    2、客户端程序：    1创建一个socket，用函数socket()    2设置要连接的对方的IP地址和端口等属性    3连接服务器，用函数connect()    4收发数据，用函数send()和recv()，或read()和write()    5关闭网络连接         2）基于UDP的socket：    1、服务器端流程    1建立套接字文件描述符，使用函数socket()，生成套接字文件描述符。    2设置服务器地址和侦听端口，初始化要绑定的网络地址结构。    3绑定侦听端口，使用bind()函数，将套接字文件描述符和一个地址类型变量进行绑定。    4接收客户端的数据，使用recvfrom()函数接收客户端的网络数据。    5向客户端发送数据，使用sendto()函数向服务器主机发送数据。    6关闭套接字，使用close()函数释放资源。UDP协议的客户端流程    2、客户端流程    1建立套接字文件描述符，socket()。    2设置服务器地址和端口，struct sockaddr。    3向服务器发送数据，sendto()。    4接收服务器的数据，recvfrom()。    5关闭套接字，close()。      

```
##### 250、
```
  参考回答:    1）概念：    数字证书是数字证书在一个身份和该身份的持有者所拥有的公/私钥对之间建立了一种联系，由认证中心（CA）或者认证中心的下级认证中心颁发的。根证书是认证中心与用户建立信任关系的基础。在用户使用数字证书之前必须首先下载和安装。    认证中心是一家能向用户签发数字证书以确认用户身份的管理机构。为了防止数字凭证的伪造，认证中心的公共密钥必须是可靠的，认证中心必须公布其公共密钥或由更高级别的认证中心提供一个电子凭证来证明其公共密钥的有效性，后一种方法导致了多级别认证中心的出现。    2）数字证书颁发过程：    数字证书颁发过程如下：用户产生了自己的密钥对，并将公共密钥及部分个人身份信息传送给一家认证中心。认证中心在核实身份后，将执行一些必要的步骤，以确信请求确实由用户发送而来，然后，认证中心将发给用户一个数字证书，该证书内附了用户和他的密钥等信息，同时还附有对认证中心公共密钥加以确认的数字证书。当用户想证明其公开密钥的合法性时，就可以提供这一数字证书。    3）内容：    数字证书的格式普遍采用的是X.509V3国际标准，一个标准的X.509数字证书包含以下一些内容：    1、证书的版本信息；    2、证书的序列号，每个证书都有一个唯一的证书序列号；    3、证书所使用的签名算法；    4、证书的发行机构名称，命名规则一般采用X.500格式；    5、证书的有效期，通用的证书一般采用UTC时间格式；    6、证书所有人的名称，命名规则一般采用X.500格式；    7、证书所有人的公开密钥；    8、证书发行者对证书的签名。 

```
##### 251、
```
  参考回答:    除非套接字已连接，否则异步错误是不会反悔到UDP套接字的。我们确实可以给UDP套接字调用connect，然而这样做的结果却与TCP连接不同的是没有三路握手过程。内核只是检查是否存在立即可知的错误，记录对端的IP地址和端口号，然后立即返回调用进程。    对于已连接UDP套接字，与默认的未连接UDP套接字相比，发生了三个变化。    其实一旦UDP套接字调用了connect系统调用，那么这个UDP上的连接就变成一对一的连接，但是通过这个UDP连接传输数据的性质还是不变的，仍然是不可靠的UDP连接。一旦变成一对一的连接，在调用系统调用发送和接受数据时也就可以使用TCP那一套系统调用了。    1、我们再也不能给输出操作指定目的IP地址和端口号。也就是说，我们不使用sendto，而改用write或send。写到已连接UDP套接字上的任何内容都自动发送到由connect指定的协议地址。可以给已连接的UDP套接字调用sendto，但是不能指定目的地址。sendto的第五个参数必须为空指针，第六个参数应该为0.    2、不必使用recvfrom以获悉数据报的发送者，而改用read、recv或recvmsg。在一个已连接UDP套接字上，由内核为输入操作返回的数据报只有那些来自connect指定协议地址的数据报。这样就限制一个已连接UDP套接字能且仅能与一个对端交换数据报。    3、由已连接UDP套接字引发的异步错误会返回给它们所在的进程，而未连接的UDP套接字不接收任何异步错误。    来自任何其他IP地址或断开的数据报不投递给这个已连接套接字，因为它们要么源IP地址要么源UDP端口不与该套接字connect到的协议地址相匹配。    UDP客户进程或服务器进程只在使用自己的UDP套接字与确定的唯一对端进行通信时，才可以调用connect。调用connect的通常是UDP客户，不过有些网络应用中的UDP服务器会与单个客户长时间通信TFTP，这种情况下，客户和服务器都可能调用connect。 

```
##### 252、
```
     参考回答:       三次握手   1.客户端发送syn0给服务器 2.服务器收到syn0，回复syn1,ack(syn0+1) 3.客户端收到syn1，回复ack(syn1+1) 四次挥手(这里以客户端主动断开为例) 1.客户端发送fin 2.服务端收到fin,回复ack,然后服务器去处理其他事 3.服务器事情处理完，回复fin 4.客户端回复ack 为什么用三次握手 本来握手应该和挥手一样都是需要确认两个方向都能联通的，本来模型应该是： 1.客户端发送syn0给服务器 2.服务器收到syn0，回复ack(syn0+1) 3.服务器发送syn1 3.客户端收到syn1，回复ack(syn1+1) 因为tcp是全双工的，上边的四部确认了数据在两个方向上都是可以正确到达的，但是2，3步没有没有上下的联系，可以将其合并，加快握手效率，所有就变成了3步握手。 

```
##### 253、
```
     参考回答:       阻塞和非阻塞：调用者在事件没有发生的时候，一直在等待事件发生，不能去处理别的任务这是阻塞。调用者在事件没有发生的时候，可以去处理别的任务这是非阻塞。   同步和异步：调用者必须循环自去查看事件有没有发生，这种情况是同步。调用者不用自己去查看事件有没有发生，而是等待着注册在事件上的回调函数通知自己，这种情况是异步 

```
##### 254、
```
     参考回答:       send函数用来向TCP连接的另一端发送数据。客户程序一般用send函数向服务器发送请求，而服务器则通常用send函数来向客户程序发送应答,send的作用是将要发送的数据拷贝到缓冲区，协议负责传输。   recv函数用来从TCP连接的另一端接收数据，当应用程序调用recv函数时，recv先等待s的发送缓冲中的数据被协议传送完毕，然后从缓冲区中读取接收到的内容给应用层。 accept函数用了接收一个连接，内核维护了半连接队列和一个已完成连接队列，当队列为空的时候，accept函数阻塞，不为空的时候accept函数从上边取下来一个已完成连接，返回一个文件描述符。 

```
##### 255、
```
  参考回答:    看tcp连接是否有断开的四部挥手阶段。 

```
##### 256、
```
     参考回答:       1.客户端发送syn0给服务器   2.服务器收到syn0，回复syn1,ack(syn0+1) 3.客户端收到syn1，回复ack(syn1+1) 

```
##### 257、
```
     参考回答:       1.客户端发送syn0给服务器   2.服务器收到syn0，回复ack(syn0+1) 3.服务器发送syn1 4.客户端收到syn1，回复ack(syn1+1) 

```
##### 258、
```
  参考回答:    网络层等到数据链层用mac地址作为通信目标，数据包到达网络等准备往数据链层发送的时候，首先会去自己的arp缓存表(存着ip-mac对应关系)去查找改目标ip的mac地址，如果查到了，就讲目标ip的mac地址封装到链路层数据包的包头。如果缓存中没有找到，会发起一个广播：who is ip XXX tell ip XXX,所有收到的广播的机器看这个ip是不是自己的，如果是自己的，则以单拨的形式将自己的mac地址回复给请求的机器 

```
##### 259、
```
     参考回答:       索引是对数据库表中一列或多列的值进行排序的一种结构，使用索引可快速访问数据库表中的特定信息。如果想按特定职员的姓来查找他或她，则与在表中搜索所有的行相比，索引有助于更快地获取信息。   索引的一个主要目的就是加快检索表中数据的方法，亦即能协助信息搜索者尽快的找到符合限制条件的记录ID的辅助数据结构。 

```
##### 260、
```
  参考回答:    数据库事务(Database Transaction) ，是指作为单个逻辑工作单元执行的一系列操作，要么完全地执行，要么完全地不执行。 事务处理可以确保除非事务性单元内的所有操作都成功完成，否则不会永久更新面向数据的资源。通过将一组相关操作组合为一个要么全部成功要么全部失败的单元，可以简化错误恢复并使应用程序更加可靠。一个逻辑工作单元要成为事务，必须满足所谓的ACID（原子性、一致性、隔离性和持久性）属性。事务是数据库运行中的逻辑工作单位，由DBMS中的事务管理子系统负责事务的处理。 

```
##### 261、
```
  参考回答:    同一时间，只允许一个事务请求同一数据，不同的事务之间彼此没有任何干扰。比如A正在从一张银行卡中取钱，在A取钱的过程结束前，B不能向这张卡转账。 

```
##### 262、
```
     参考回答:       left join(左联接) 返回包括左表中的所有记录和右表中联结字段相等的记录   right join(右联接) 返回包括右表中的所有记录和左表中联结字段相等的记录 inner join(等值连接) 只返回两个表中联结字段相等的行 

```
##### 263、
```
  参考回答:    事务（Transaction）是由一系列对系统中数据进行访问与更新的操作所组成的一个程序执行逻辑单元。事务是DBMS中最基础的单位，事务不可分割。    事务具有4个基本特征，分别是：原子性（Atomicity）、一致性（Consistency）、隔离性（Isolation）、持久性（Duration），简称ACID。    1）原子性（Atomicity）    原子性是指事务包含的所有操作要么全部成功，要么全部失败回滚，[删删删]因此事务的操作如果成功就必须要完全应用到数据库，如果操作失败则不能对数据库有任何影响。    2）一致性（Consistency）    一致性是指事务必须使数据库从一个一致性状态变换到另一个一致性状态，也就是说一个事务执行之前和执行之后都必须处于一致性状态。    拿转账来说，假设用户A和用户B两者的钱加起来一共是5000，那么不管A和B之间如何转账，转几次账，事务结束后两个用户的钱相加起来应该还得是5000，这就是事务的一致性。    3）隔离性（Isolation）    隔离性是当多个用户并发访问数据库时，比如操作同一张表时，数据库为每一个用户开启的事务，不能被其他事务的操作所干扰，多个并发事务之间要相互隔离。    即要达到这么一种效果：对于任意两个并发的事务T1和T2，在事务T1看来，T2要么在T1开始之前就已经结束，要么在T1结束之后才开始，这样每个事务都感觉不到有其他事务在并发地执行。    多个事务并发访问时，事务之间是隔离的，一个事务不应该影响其它事务运行效果。这指的是在并发环境中，当不同的事务同时操纵相同的数据时，每个事务都有各自的完整数据空间。由并发事务所做的修改必须与任何其他并发事务所做的修改隔离。    不同的隔离级别：    Read Uncommitted（读取未提交[添加中文释义]内容）：最低的隔离级别，什么都不需要做，一个事务可以读到另一个事务未提交的结果。所有的并发事务问题都会发生。    Read Committed（读取提交内容）：只有在事务提交后，其更新结果才会被其他事务看见。可以解决脏读问题。    Repeated Read（可重复读）：在一个事务中，对于同一份数据的读取结果总是相同的，无论是否有其他事务对这份数据进行操作，以及这个事务是否提交。可以解决脏读、不可重复读。    Serialization（可串行化）：事务串行化执行，隔离级别最高，牺牲了系统的并发性。可以解决并发事务的所有问题。    4）持久性（Durability）    持久性是指一个事务一旦被提交了，那么对数据库中的数据的改变就是永久性的，即便是在数据库系统遇到故障的情况下也不会丢失提交事务的操作。    例如我们在使用JDBC操作数据库时，在提交事务方法后，提示用户事务操作完成，当我们程序执行完成直到看到提示后，就可以认定事务以及正确提交，即使这时候数据库出现了问题，也必须要将我们的事务完全执行完成，否则就会造成我们看到提示事务处理完毕，但是数据库因为故障而没有执行事务的重大错误。 

```
##### 264、
```
  参考回答:    1、索引    数据库索引是为了增加查询速度而对表字段附加的一种标识，是对数据库表中一列或多列的值进行排序的一种结构。    DB在执行一条Sql语句的时候，默认的方式是根据搜索条件进行全表扫描，遇到匹配条件的就加入搜索结果集合。如果我们对某一字段增加索引，查询时就会先去索引列表中一次定位到特定值的行数，大大减少遍历匹配的行数，所以能明显增加查询的速度。    优点：    通过创建唯一性索引，可以保证数据库表中每一行数据的唯一性。    可以大大加快数据的检索速度，这也是创建索引的最主要的原因。    可以加速表和表之间的连接，特别是在实现数据的参考完整性方面特别有意义。    在使用分组和排序子句进行数据检索时，同样可以显著减少查询中分组和排序的时间。    通过使用索引，可以在查询的过程中，使用优化隐藏器，提高系统的性能。    缺点：    创建索引和维护索引要耗费时间，这种时间随着数据量的增加而增加。    索引需要占物理空间，除了数据表占数据空间之外，每一个索引还要占一定的物理空间，如果要建立聚簇索引，那么需要的空间就会更大。    当对表中的数据进行增加、删除和修改的时候，索引也要动态的维护，这样就降低了数据的维护速度。    2、添加索引原则    在查询中很少使用或者参考的列不应该创建索引。这是因为，既然这些列很少使用到，因此有索引或者无索引，并不能提高查询速度。相反，由于增加了索引，反而降低了系统的维护速度和增大了空间需求。    只有很少数据值的列也不应该增加索引。这是因为，由于这些列的取值很少，例如人事表的性别列，在查询的结果中，结果集的数据行占了表中数据行的很大比例，即需要在表中搜索的数据行的比例很大。增加索引，并不能明显加快检索速度。    定义为text、image和bit数据类型的列不应该增加索引。这是因为，这些列的数据量要么相当大，要么取值很少。    当修改性能远远大于检索性能时，不应该创建索引。这是因为，修改性能和检索性能是互相矛盾的。当增加索引时，会提高检索性能，但是会降低修改性能。当减少索引时，会提高修改性能，降低检索性能。因此，当修改性能远远大于检索性能时，不应该创建索引。 

```
##### 265、
```

```
##### 266、
```

```
##### 267、
```
  参考回答:    1、MySQL引擎    MySQL中的数据用各种不同的技术存储在文件（或者内存）中。这些技术中的每一种技术都使用不同的存储机制、索引技巧、锁定水平并且最终提供广泛的不同的功能和能力。通过选择不同的技术，你能够获得额外的速度或者功能，从而改善你的应用的整体功能。    数据库引擎是用于存储、处理和保护数据的核心服务。利用数据库引擎可控制访问权限并快速处理事务，从而满足企业内大多数需要处理大量数据的应用程序的要求。使用数据库引擎创建用于联机事务处理或联机分析处理数据的关系数据库。这包括创建用于存储数据的表和用于查看、管理和保护数据安全的数据库对象（如索引、视图和存储过程）。    MySQL存储引擎主要有： MyIsam、InnoDB、Memory、Blackhole、CSV、Performance_Schema、Archive、Federated、Mrg_Myisam。    但是最常用的是InnoDB和Mylsam。    2、InnoDB    InnoDB是一个事务型的存储引擎，有行级锁定和外键约束。    Innodb引擎提供了对数据库ACID事务的支持，并且实现了SQL标准的四种隔离级别，关于数据库事务与其隔离级别的内容请见数据库事务与其隔离级别这类型的文章。该引擎还提供了行级锁和外键约束，它的设计目标是处理大容量数据库系统，它本身其实就是基于MySQL后台的完整数据库系统，MySQL运行时Innodb会在内存中建立缓冲池，用于缓冲数据和索引。但是该引擎不支持FULLTEXT类型的索引，而且它没有保存表的行数，当SELECT COUNT(*) FROM TABLE时需要扫描全表。当需要使用数据库事务时，该引擎当然是首选。由于锁的粒度更小，写操作不会锁定全表，所以在并发较高时，使用Innodb引擎会提升效率。但是使用行级锁也不是绝对的，如果在执行一个SQL语句时MySQL不能确定要扫描的范围，InnoDB表同样会锁全表。    适用场景：    经常更新的表，适合处理多重并发的更新请求。    支持事务。    可以从灾难中恢复（通过bin-log日志等）。    外键约束。只有他支持外键。    支持自动增加列属性auto_increment。    索引结构：    InnoDB也是B+Treee索引结构。Innodb的索引文件本身就是数据文件，即B+Tree的数据域存储的就是实际的数据，这种索引就是聚集索引。这个索引的key就是数据表的主键，因此InnoDB表数据文件本身就是主索引。    InnoDB的辅助索引数据域存储的也是相应记录主键的值而不是地址，所以当以辅助索引查找时，会先根据辅助索引找到主键，再根据主键索引找到实际的数据。所以Innodb不建议使用过长的主键，否则会使辅助索引变得过大。建议使用自增的字段作为主键，这样B+Tree的每一个结点都会被顺序的填满，而不会频繁的分裂调整，会有效的提升插入数据的效率。    3、Mylsam    MyIASM是MySQL默认的引擎，但是它没有提供对数据库事务的支持，也不支持行级锁和外键，因此当INSERT或UPDATE数据时即写操作需要锁定整个表，效率便会低一些。MyIsam 存储引擎独立于操作系统，也就是可以在windows上使用，也可以比较简单的将数据转移到linux操作系统上去。    适用场景：    不支持事务的设计，但是并不代表着有事务操作的项目不能用MyIsam存储引擎，可以在service层进行根据自己的业务需求进行相应的控制。    不支持外键的表设计。    查询速度很快，如果数据库insert和update的操作比较多的话比较适用。    整天对表进行加锁的场景。    MyISAM极度强调快速读取操作。    MyIASM中存储了表的行数，于是SELECT COUNT(*) FROM TABLE时只需要直接读取已经保存好的值而不需要进行全表扫描。如果表的读操作远远多于写操作且不需要数据库事务的支持，那么MyIASM也是很好的选择。    缺点：就是不能在表损坏后主动恢复数据。    索引结构：    MyISAM索引结构：MyISAM索引用的B+ tree来储存数据，MyISAM索引的指针指向的是键值的地址，地址存储的是数据。B+Tree的数据域存储的内容为实际数据的地址，也就是说它的索引和实际的数据是分开的，只不过是用索引指向了实际的数据，这种索引就是所谓的非聚集索引。    3、InnoDB和Mylsam的区别：    1）事务：MyISAM类型不支持事务处理等高级处理，而InnoDB类型支持，提供事务支持已经外部键等高级数据库功能。    2）性能：MyISAM类型的表强调的是性能，其执行数度比InnoDB类型更快。    3）行数保存：InnoDB 中不保存表的具体行数，也就是说，执行select count() fromtable时，InnoDB要扫描一遍整个表来计算有多少行，但是MyISAM只要简单的读出保存好的行数即可。注意的是，当count()语句包含where条件时，两种表的操作是一样的。    4）索引存储：对于AUTO_INCREMENT类型的字段，InnoDB中必须包含只有该字段的索引，但是在MyISAM表中，可以和其他字段一起建立联合索引。MyISAM支持全文索引（FULLTEXT）、压缩索引，InnoDB不支持。    MyISAM的索引和数据是分开的，并且索引是有压缩的，内存使用率就对应提高了不少。能加载更多索引，而Innodb是索引和数据是紧密捆绑的，没有使用压缩从而会造成Innodb比MyISAM体积庞大不小。    InnoDB存储引擎被完全与MySQL服务器整合，InnoDB存储引擎为在主内存中缓存数据和索引而维持它自己的缓冲池。InnoDB存储它的表＆索引在一个表空间中，表空间可以包含数个文件（或原始磁盘分区）。这与MyISAM表不同，比如在MyISAM表中每个表被存在分离的文件中。InnoDB 表可以是任何尺寸，即使在文件尺寸被限制为2GB的操作系统上。    5）服务器数据备份：InnoDB必须导出SQL来备份，LOAD TABLE FROM MASTER操作对InnoDB是不起作用的，解决方法是首先把InnoDB表改成MyISAM表，导入数据后再改成InnoDB表，但是对于使用的额外的InnoDB特性(例如外键)的表不适用。    MyISAM应对错误编码导致的数据恢复速度快。MyISAM的数据是以文件的形式存储，所以在跨平台的数据转移中会很方便。在备份和恢复时可单独针对某个表进行操作。    InnoDB是拷贝数据文件、备份 binlog，或者用 mysqldump，在数据量达到几十G的时候就相对痛苦了。    6）锁的支持：MyISAM只支持表锁。InnoDB支持表锁、行锁 行锁大幅度提高了多用户并发操作的新能。但是InnoDB的行锁，只是在WHERE的主键是有效的，非主键的WHERE都会锁全表的。 

```
##### 268、
```
  参考回答:    unordered_map（哈希表)和map（红黑树） 

```
##### 269、
```
  参考回答:     参考博客https://blog.csdn.net/tanrui519521/article/details/80980135  

```
##### 270、
```
  参考回答:    考察点：算法    公司：京东，阿里巴巴    1）平衡二叉树（AVL树）：    红黑树是在AVL树的基础上提出来的。    平衡二叉树又称为AVL树，是一种特殊的二叉排序树。其左右子树都是平衡二叉树，且左右子树高度之差的绝对值不超过1。    AVL树中所有结点为根的树的左右子树高度之差的绝对值不超过1。    将二叉树上结点的左子树深度减去右子树深度的值称为平衡因子BF，那么平衡二叉树上的所有结点的平衡因子只可能是-1、0和1。只要二叉树上有一个结点的平衡因子的绝对值大于1，则该二叉树就是不平衡的。    2）红黑树：    红黑树是在AVL树的基础上发展而来的。红黑树是一种二叉查找树，但在每个节点增加一个存储位表示节点的颜色，可以是红或黑（非红即黑）。通过对任何一条从根到叶子的路径上各个节点着色的方式的限制，红黑树确保没有一条路径会比其它路径长出两倍，因此，红黑树是一种弱平衡二叉树，相对于要求严格的AVL树来说，它的旋转次数少，所以对于搜索，插入，删除操作较多的情况下，通常使用红黑树。    性质：    1. 每个节点非红即黑    2. 根节点是黑的;    3. 每个叶节点（叶节点即树尾端NULL指针或NULL节点）都是黑的;    4. 如果一个节点是红色的，则它的子节点必须是黑色的。    5. 对于任意节点而言，其到叶子点树NULL指针的每条路径都包含相同数目的黑节点;    从根到叶子的最长的可能路径不多于最短的可能路径的两倍长。它可以在O(log n)时间内做查找，插入和删除，这里的n 是树中元素的数目。恢复红黑属性需要少量(O(log n))的颜色变更(这在实践中是非常快速的)并且不超过三次树旋转(对于插入是两次)。这允许插入和删除保持为 O(log n) 次，         3）红黑树较AVL树的优点：    AVL 树是高度平衡的，频繁的插入和删除，会引起频繁的rebalance，导致效率下降；红黑树不是高度平衡的，算是一种折中，插入最多两次旋转，删除最多三次旋转。    所以红黑树在查找，插入删除的性能都是O(logn)，且性能稳定，所以STL里面很多结构包括map底层实现都是使用的红黑树。    4）红黑树旋转：    旋转：红黑树的旋转是一种能保持二叉搜索树性质的搜索树局部操作。有左旋和右旋两种旋转，通过改变树中某些结点的颜色以及指针结构来保持对红黑树进行插入和删除操作后的红黑性质。    左旋：对某个结点x做左旋操作时，假设其右孩子为y而不是T.nil：以x到y的链为“支轴”进行。使y成为该子树新的根结点，x成为y的左孩子，y的左孩子成为x的右孩子。     右旋：对某个结点x做右旋操作时，假设其左孩子为y而不是T.nil：以x到y的链为“支轴”进行。使y成为该子树新的根结点，x成为y的右孩子，y的右孩子成为x的左孩子。      

```
##### 271、
```

```
##### 272、
```
  参考回答:    void layerTrace(BTreeNode *T)    {    if(T== nullptr)return;    BTreeNode *p=T;    queue<BTreeNode*>q;    q.push(p);    while(!q.empty())    {    p=q.front();    q.pop();    cout<<<<p->data;    if(p->left!= nullptr)q.push(p->left);    if(p->right!= nullptr)q.push(p->right);        }    }``` 

```
##### 273、
```
  参考回答:    > 序列化：必须保存一个中序遍历结果，然后外加一个前序或者后序遍历结果    >反序列化：根据两次遍历生成的结果恢复二叉树，代码如下(前序和中序)：    ```TreeNode* helper(vector<int>pre,int startPre,int endPre,vector<int>in,int startIn,int endIn)    {    if(startPre>endPre||startIn>endIn)    return nullptr;    TreeNode * root=new TreeNode(pre[startPre]);    for(int i=startIn;i<=endIn;++i)    {    if(in[i]==pre[startPre])    {    root->left=helper(pre,startPre+1,startPre+i-startIn,in,startIn,i-1);    root->right=helper(pre,i-startIn+startPre+1,endPre,in,i+1,endIn);    break;    }    }    return root;    }    TreeNode* reConstructBinaryTree(vector<int> pre,vector<int> vin)    {    TreeNode *root=helper(pre,0,pre.size()-1,vin,0,vin.size()-1);    return root;    }     

```
##### 274、请你说一说小根堆特点

```
  参考回答:    堆是一棵完全二叉树（如果一共有h层，那么1~h-1层均满，在h层可能会连续缺失若干个右叶子）。    1）小根堆    若根节点存在左子女则根节点的值小于左子女的值；若根节点存在右子女则根节点的值小于右子女的值。    2）大根堆    若根节点存在左子女则根节点的值大于左子女的值；若根节点存在右子女则根节点的值大于右子女的值。 

```
##### 275、
```
  参考回答:    O（N2),元素本来倒序排列用时最多 

```
##### 276、
```
  参考回答:    基数排序、冒泡排序、直接插入排序、折半插入排序、归并排序     

```
##### 277、
```
  参考回答:    1、快排算法    根据哨兵元素，用两个指针指向待排序数组的首尾，首指针从前往后移动找到比哨兵元素大的，尾指针从后往前移动找到比哨兵元素小的，交换两个元素，直到两个指针相遇，这是一趟排序，经常这趟排序后，比哨兵元素大的在右边，小的在左边。经过多趟排序后，整个数组有序。    稳定性：不稳定    平均时间复杂度：O(nlogn)    2、稳定排序    假定在待排序的记录序列中，存在多个具有相同的关键字的记录，若经过排序，这些记录的相对次序保持不变，即在原序列中，r[i]=r[j]，且r[i]在r[j]之前，而在排序后的序列中，r[i]仍在r[j]之前，则称这种排序算法是稳定的；否则称为不稳定的。    快排算法是不稳定的排序算法。例如：    待排序数组:int a[] ={1, 2, 2, 3, 4, 5, 6};    若选择a[2]（即数组中的第二个2）为枢轴，而把大于等于比较子的数均放置在大数数组中，则a[1]（即数组中的第一个2）会到pivot的右边， 那么数组中的两个2非原序。    若选择a[1]为比较子，而把小于等于比较子的数均放置在小数数组中，则数组中的两个2顺序也非原序。    3、快排最差情况推倒    在快速排序的早期版本中呢，最左面或者是最右面的那个元素被选为枢轴，那最坏的情况就会在下面的情况下发生啦：    1）数组已经是正序排过序的。 （每次最右边的那个元素被选为枢轴）    2）数组已经是倒序排过序的。 （每次最左边的那个元素被选为枢轴）    3）所有的元素都相同（1、2的特殊情况）    因为这些案例在用例中十分常见，所以这个问题可以通过要么选择一个随机的枢轴，或者选择一个分区中间的下标作为枢轴，或者（特别是对于相比更长的分区）选择分区的第一个、中间、最后一个元素的中值作为枢轴。有了这些修改，那快排的最差的情况就不那么容易出现了，但是如果输入的数组最大（或者最小元素）被选为枢轴，那最坏的情况就又来了。    快速排序，在最坏情况退化为冒泡排序，需要比较O(n2)次（n(n - 1)/2次）。 

```
##### 278、
```
  参考回答:    考察点：hash冲突，数据结构    公司：腾讯    1、开放定址    开放地址法有个非常关键的特征，就是所有输入的元素全部存放在哈希表里，也就是说，位桶的实现是不需要任何的链表来实现的，换句话说，也就是这个哈希表的装载因子不会超过1。它的实现是在插入一个元素的时候，先通过哈希函数进行判断，若是发生哈希冲突，就以当前地址为基准，根据再寻址的方法（探查序列），去寻找下一个地址，若发生冲突再去寻找，直至找到一个为空的地址为止。所以这种方法又称为再散列法。    有几种常用的探查序列的方法：    ①线性探查    dii=1，2，3，…，m-1；这种方法的特点是：冲突发生时，顺序查看表中下一单元，直到找出一个空单元或查遍全表。    ②二次探查    di=12，-12，22，-22，…，k2，-k2    ( k<=m/2 )；这种方法的特点是：冲突发生时，在表的左右进行跳跃式探测，比较灵活。    ③ 伪随机探测    di=伪随机数序列；具体实现时，应建立一个伪随机数发生器，（如i=(i+p) % m），生成一个位随机序列，并给定一个随机数做起点，每次去加上这个伪随机数++就可以了。    2、链地址    每个位桶实现的时候，采用链表或者树的数据结构来去存取发生哈希冲突的输入域的关键字，也就是被哈希函数映射到同一个位桶上的关键字。         紫色部分即代表哈希表，也称为哈希数组，数组的每个元素都是一个单链表的头节点，链表是用来解决冲突的，如果不同的key映射到了数组的同一位置处，就将其放入单链表中，即链接在桶后。    3、公共溢出区    建立一个公共溢出区域，把hash冲突的元素都放在该溢出区里。查找时，如果发现hash表中对应桶里存在其他元素，还需要在公共溢出区里再次进行查找。    4、再hash    再散列法其实很简单，就是再使用哈希函数去散列一个输入的时候，输出是同一个位置就再次散列，直至不发生冲突位置。    缺点：每次冲突都要重新散列，计算时间增加。 

```
##### 279、
```
  参考回答:    struct ListNode {    int val;    struct ListNode *next;    ListNode(int x) :val(x), next(NULL) {}    }    ListNode* ReverseList(ListNode* pHead)    {    if(!pHead||!pHead->next)return pHead;    ListNode *pre=nullptr;    ListNode *p=pHead;    ListNode *next=pHead->next;    while(p)    {    p->next=pre;    pre=p;    p=next;    if(next)    next=next->next;    }    return pre;    } 

```
##### 280、
```
  参考回答:    考察点：数据结构，算法    公司：百度    1、单向链表    单向链表（单链表）是链表的一种，其特点是链表的链接方向是单向的，对链表的访问要通过顺序读取从头部开始；链表是使用指针进行构造的列表；又称为结点列表，因为链表是由一个个结点组装起来的；其中每个结点都有指针成员变量指向列表中的下一个结点。    列表是由结点构成，head指针指向第一个成为表头结点，而终止于最后一个指向nuLL的指针。         2、判断两个链表是否相交    1）方法1：    链表相交之后，后面的部分节点全部共用，可以用2个指针分别从这两个链表头部走到尾部，最后判断尾部指针的地址信息是否一样，若一样则代表链表相交！    2）方法2：    可以把其中一个链表的所有节点地址信息存到数组中，然后把另一个链表的每一个节点地址信息遍历数组，若相等，则跳出循环，说明链表相交。进一步优化则是进行hash排序，建立hash表。 

```
##### 281、
```
  参考回答:    考察点：密码学    公司：腾讯    1、单向加密    单向加密又称为不可逆加密算法，其密钥是由加密散列函数生成的。单向散列函数一般用于产生消息摘要，密钥加密等，常见的有：        MD5（Message Digest Algorithm 5）：是RSA数据安全公司开发的一种单向散列算法，非可逆，相同的明文产生相同的密文；    SHA（Secure Hash Algorithm）：可以对任意长度的数据运算生成一个160位的数值。其变种由SHA192，SHA256，SHA384等；    CRC-32，主要用于提供校验功能；    算法特征：    输入一样，输出必然相同；    雪崩效应，输入的微小改变，将会引起结果的巨大变化；    定长输出，无论原始数据多大，结果大小都是相同的；    不可逆，无法根据特征码还原原来的数据；    2、对称加密    采用单钥密码系统的加密方法，同一个密钥可以同时用作信息的加密和解密，这种加密方法称为对称加密，也称为单密钥加密。    特点：    1、加密方和解密方使用同一个密钥；    2、加密解密的速度比较快，适合数据比较长时的使用；    3、密钥传输的过程不安全，且容易被破解，密钥管理也比较麻烦；    优点：对称加密算法的优点是算法公开、计算量小、加密速度快、加密效率高。    缺点：对称加密算法的缺点是在数据传送前，发送方和接收方必须商定好秘钥，然后使双方都能保存好秘钥。其次如果一方的秘钥被泄露，那么加密信息也就不安全了。另外，每对用户每次使用对称加密算法时，都需要使用其他人不知道的唯一秘钥，这会使得收、发双方所拥有的钥匙数量巨大，密钥管理成为双方的负担。    3、非对称加密    非对称密钥加密也称为公钥加密，由一对公钥和私钥组成。公钥是从私钥提取出来的。可以用公钥加密，再用私钥解密，这种情形一般用于公钥加密，当然也可以用私钥加密，用公钥解密。常用于数字签名，因此非对称加密的主要功能就是加密和数字签名。    特征：    1）秘钥对，公钥(public key)和私钥(secret key)    2）主要功能：加密和签名    发送方用对方的公钥加密，可以保证数据的机密性（公钥加密）。    发送方用自己的私钥加密，可以实现身份验证（数字签名）。    3）公钥加密算法很少用来加密数据，速度太慢，通常用来实现身份验证。    常用的非对称加密算法    RSA：由 RSA公司发明，是一个支持变长密钥的公共密钥算法，需要加密的文件块的长度也是可变的；既可以实现加密，又可以实现签名。    DSA（Digital Signature Algorithm）：数字签名算法，是一种标准的 DSS（数字签名标准）。    ECC（Elliptic Curves Cryptography）：椭圆曲线密码编码。     

```
##### 282、
```
  参考回答:       LRU(最近最少使用)算法根据数据的历史访问记录来进行淘汰数据，其核心思想是“如果数据最近被访问过，那么将来被访问的几率也更高   实现：使用一个链表保存缓存数据，将新数据插入到头部，每当缓存命中时，则将命中的数据移动到链表头部，当链表满的时候，将链表尾部的数据丢弃。     

```
##### 283、
```
  参考回答:    考察点：    公司：腾讯    1、Fisher-Yates Shuffle算法    最早提出这个洗牌方法的是 Ronald A. Fisher 和 Frank Yates，即 Fisher–Yates Shuffle，其基本思想就是从原始数组中随机取一个之前没取过的数字到新的数组中，具体如下：    1）初始化原始数组和新数组，原始数组长度为n(已知)。    2）从还没处理的数组（假如还剩k个）中，随机产生一个[0, k)之间的数字p（假设数组从0开始）。    3）从剩下的k个数中把第p个数取出。    4）重复步骤2和3直到数字全部取完。    5）从步骤3取出的数字序列便是一个打乱了的数列。    时间复杂度为O(n*n)，空间复杂度为O(n)。    2）Knuth-Durstenfeld Shuffle    Knuth 和 Durstenfeld  在Fisher 等人的基础上对算法进行了改进，在原始数组上对数字进行交互，省去了额外O(n)的空间。该算法的基本思想和 Fisher 类似，每次从未处理的数据中随机取出一个数字，然后把该数字放在数组的尾部，即数组尾部存放的是已经处理过的数字。    算法步骤为：    1. 建立一个数组大小为 n 的数组 arr，分别存放 1 到 n 的数值；    2. 生成一个从 0 到 n - 1 的随机数 x；    3. 输出 arr 下标为 x 的数值，即为第一个随机数；    4. 将 arr 的尾元素和下标为 x 的元素互换；    5. 同2，生成一个从 0 到 n - 2 的随机数 x；    6. 输出 arr 下标为 x 的数值，为第二个随机数；    7. 将 arr 的倒数第二个元素和下标为 x 的元素互换；    ……    如上，直到输出m 个数为止    时间复杂度为O(n)，空间复杂度为O(1)，缺点必须知道数组长度n。 

```
##### 284、
```
      参考回答:    使用哈希的思想，建立256个bool数组array，初始都为false,从头开始扫描字符串，扫到一个，将以其ascii码为下标的元素置true。例如扫描到A的时候，执行：array['A']=true。第二边扫描，扫到一个字母就以其ascii码为下标，去array数组中看其值，如果是true,返回改字母，如果是false，继续扫描下一个字母。 

```
##### 285、
```
  参考回答:    解耦，代码复用，更改功能容易。 

```
##### 286、
```
  参考回答:    观察者模式中分为观察者和被观察者，当被观察者发生装填改变时，观察者会受到通知。主要为了解决对象状态改变给其他对象通知的问题，其实现类似于观察者在被观察者那注册了一个回调函数。 

```
##### 287、
```
  参考回答:    C++的实现有两种，一种通过局部静态变量，利用其只初始化一次的特点，返回对象。另外一种，则是定义全局的指针，getInstance判断该指针是否为空，为空时才实例化对象 

```
##### 288、
```
  参考回答:    使用锁机制，防止多次访问,可以这样，第一次判断为空不加锁，若为空，再进行加锁判断是否为空，若为空则生成对象。 

```
##### 289、
```
  参考回答:    考察点：设计模式    公司：百度    1、装饰器模式    装饰器模式主要是为了动态的为一个对象增加新的功能，装饰器模式是一种用于代替继承的技术，无需通过继承增加子类就能扩展对象的新功能。这种模式创建了一个装饰类，用来包装原有的类，并在保持类方法签名完整性的前提下，提供了额外的功能。使用对象的关联关系代替继承关系，更加灵活，同时避免类型体系的快速膨胀。    优点：装饰类和被装饰类可以独立发展，不会相互耦合，装饰模式是继承的一个替代模式，装饰模式可以动态扩展一个实现类的功能。    缺点：多层装饰比较复杂。        使用场景：1、扩展一个类的功能。 2、动态增加功能，动态撤销。    2、单例模式    单例模式是一种常用的软件设计模式，其定义是单例对象的类只能允许一个实例存在。这种模式涉及到一个单一的类，该类负责创建自己的对象，同时确保只有单个对象被创建。这个类提供了一种访问其唯一的对象的方式，可以直接访问，不需要实例化该类的对象。    优点：1、在内存里只有一个实例，减少了内存的开销，尤其是频繁的创建和销毁实例（比如管理学院首页页面缓存）。 2、避免对资源的多重占用（比如写文件操作）。    缺点：没有接口，不能继承，与单一职责原则冲突，一个类应该只关心内部逻辑，而不关心外面怎么样来实例化。    使用场景：1、要求生产唯一序列号。 2、WEB 中的计数器，不用每次刷新都在数据库里加一次，用单例先缓存起来。 3、创建的一个对象需要消耗的资源过多，比如 I/O 与数据库的连接等。    实现：    单例模式要求类能够有返回对象一个引用(永远是同一个)和一个获得该实例的方法（必须是静态方法，通常使用getInstance这个名称）。    单例的实现主要是通过以下两个步骤：    将该类的构造方法定义为私有方法，这样其他处的代码就无法通过调用该类的构造方法来实例化该类的对象，只有通过该类提供的静态方法来得到该类的唯一实例；    在该类内提供一个静态方法，当我们调用这个方法时，如果类持有的引用不为空就返回这个引用，如果类保持的引用为空就创建该类的实例并将实例的引用赋予该类保持的引用。    注意事项：getInstance() 方法中需要使用同步锁 synchronized (Singleton.class) 防止多线程同时进入造成 instance 被多次实例化。    3）单例模式举例（常手撕）    class SingleTon    {    private:    SingleTon() {};    SingleTon(const SingleTon&) {}; // 禁止拷贝    SingleTon& operator=(const SingleTon&) {}; // 禁止赋值        static T* uniqueInstance;    static pthread_mutex_t mutex;    public:    static T* GetInstance()    {    pthread_mutex_lock(&mutex);    if (uniqueInstance == nullptr)    {    uniqueInstance = new T();    }    pthread_mutex_unlock(&mutex);    return uniqueInstance;    }    };    template <class T>    pthread_mutex_t SingleTon<T>::mutex = PTHREAD_MUTEX_INITIALIZER;    template <class T>    T* SingleTon<T>::uniqueInstance = nullptr; 

```
##### 290、
```

```
##### 291、
```

```
